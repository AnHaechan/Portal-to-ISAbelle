[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow>\n    nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)", "extra context": "lemma nextss_closed_dfs'[rule_format]: \n \"nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)\"", "action": "by (induct g xs ys rule:dfs.induct, auto simp add:nextss_Cons List.member_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys", "extra context": "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\"", "action": "unfolding reachable_def", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set (xs @ ys) =\n    (set g)\\<^sup>* `` set xs \\<union> (set g)\\<^sup>* `` set ys", "extra context": "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\" \\n unfolding reachable_def", "action": "by auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. dfs g (xs @ ys) zs = dfs g ys (dfs g xs zs)", "extra context": "lemma dfs_app: \"dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)\"", "action": "by (induct g xs zs rule: dfs.induct) auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g xs []) = reachable g xs", "extra context": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "action": "proof", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs\n 2. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof", "action": "have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []", "extra context": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\"", "action": "by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])", "complete": false}, {"observation": "proof (state)\nthis:\n  set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\n\ngoal (2 subgoals):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs\n 2. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" \\n by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])", "action": "thus \"set (dfs g xs []) \\<subseteq> reachable g xs\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\n\ngoal (1 subgoal):\n 1. set (dfs g xs []) \\<subseteq> reachable g xs", "extra context": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" \\n by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"]) \\n thus \"set (dfs g xs []) \\<subseteq> reachable g xs\"", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  set (dfs g xs []) \\<subseteq> reachable g xs\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" \\n by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"]) \\n thus \"set (dfs g xs []) \\<subseteq> reachable g xs\" \\n by simp", "action": "qed(rule reachable_closed_dfs)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (dfs g xs ys)", "extra context": "lemma visit_subset_dfs: \"set ys \\<subseteq> set (dfs g xs ys)\"", "action": "by (induct g xs ys rule: dfs.induct) auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. reachable g (nexts g x) \\<subseteq> reachable g [x]", "extra context": "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "action": "unfolding reachable_def", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set (nexts g x)\n    \\<subseteq> (set g)\\<^sup>* `` set [x]", "extra context": "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n unfolding reachable_def", "action": "by (auto intro: converse_rtrancl_into_rtrancl simp: nexts_set)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes_of g - set ys)", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "action": "proof(rule finite_subset)", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. nodes_of g - set ys \\<subseteq> ?B\n 2. finite ?B", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset)", "action": "show \"finite (nodes_of g)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes_of g)", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\"", "action": "by (auto simp add: nodes_of_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  finite (nodes_of g)\n\ngoal (1 subgoal):\n 1. nodes_of g - set ys \\<subseteq> nodes_of g", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def)", "action": "qed (auto)", "complete": false}, {"observation": "proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>g ys. x = (g, [], ys) \\<Longrightarrow> P;\n        \\<And>g xa xs ys. x = (g, xa # xs, ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>g ys ga ysa.\n       (g, [], ys) = (ga, [], ysa) \\<Longrightarrow> ys = ysa\n 3. \\<And>g ys ga x xs ysa.\n       (g, [], ys) = (ga, x # xs, ysa) \\<Longrightarrow>\n       ys =\n       (if List.member ysa x then dfs_sumC (ga, xs, ysa)\n        else dfs_sumC (ga, nexts ga x @ xs, x # ysa))\n 4. \\<And>g x xs ys ga xa xsa ysa.\n       (g, x # xs, ys) = (ga, xa # xsa, ysa) \\<Longrightarrow>\n       (if List.member ys x then dfs_sumC (g, xs, ys)\n        else dfs_sumC (g, nexts g x @ xs, x # ys)) =\n       (if List.member ysa xa then dfs_sumC (ga, xsa, ysa)\n        else dfs_sumC (ga, nexts ga xa @ xsa, xa # ysa))", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto)", "action": "by pat_completeness auto", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. All dfs_dom", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto", "action": "apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")", "complete": false}, {"observation": "proof (prove)\ngoal (3 subgoals):\n 1. wf (inv_image (finite_psubset <*lex*> less_than)\n         (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)))\n 2. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 3. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x @ xs, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")", "action": "apply auto[1]", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 2. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x @ xs, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1]", "action": "apply (simp_all add: finite_psubset_def)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g x ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or>\n       nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and>\n       nexts g x = []", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def)", "action": "by (case_tac  \"x \\<in> nodes_of g\") (auto simp add: List.member_def)", "complete": false}, {"observation": "proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>g ys. x = (g, [], ys) \\<Longrightarrow> P;\n        \\<And>g xa xs ys. x = (g, xa # xs, ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>g ys ga ysa.\n       (g, [], ys) = (ga, [], ysa) \\<Longrightarrow> ys = ysa\n 3. \\<And>g ys ga x xs ysa.\n       (g, [], ys) = (ga, x # xs, ysa) \\<Longrightarrow>\n       ys =\n       (if List.member ysa x then dfs2_sumC (ga, xs, ysa)\n        else dfs2_sumC (ga, xs, dfs2_sumC (ga, nexts ga x, x # ysa)))\n 4. \\<And>g x xs ys ga xa xsa ysa.\n       (g, x # xs, ys) = (ga, xa # xsa, ysa) \\<Longrightarrow>\n       (if List.member ys x then dfs2_sumC (g, xs, ys)\n        else dfs2_sumC (g, xs, dfs2_sumC (g, nexts g x, x # ys))) =\n       (if List.member ysa xa then dfs2_sumC (ga, xsa, ysa)\n        else dfs2_sumC (ga, xsa, dfs2_sumC (ga, nexts ga xa, xa # ysa)))", "extra context": "lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) \\n by (case_tac  \"x \\<in> nodes_of g\") (auto simp add: List.member_def)", "action": "by pat_completeness auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. dfs2_dom (g, xs, ys) \\<Longrightarrow>\n    set ys \\<subseteq> set (dfs2 g xs ys)", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "action": "by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. All dfs2_dom", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+", "action": "apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")", "complete": false}, {"observation": "proof (prove)\ngoal (4 subgoals):\n 1. wf (inv_image (finite_psubset <*lex*> less_than)\n         (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)))\n 2. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 3. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 4. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs,\n                          ys)\n                         \\<in> inv_image (finite_psubset <*lex*> less_than)\n                                (\\<lambda>(g, xs, ys).\n                                    (nodes_of g - set ys, length xs))", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")", "action": "apply auto[1]", "complete": false}, {"observation": "proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g x xs ys.\n       List.member ys x \\<Longrightarrow>\n       ((g, xs, ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 2. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       ((g, nexts g x, x # ys), g, x # xs, ys)\n       \\<in> inv_image (finite_psubset <*lex*> less_than)\n              (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))\n 3. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs,\n                          ys)\n                         \\<in> inv_image (finite_psubset <*lex*> less_than)\n                                (\\<lambda>(g, xs, ys).\n                                    (nodes_of g - set ys, length xs))", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1]", "action": "apply (simp_all add: finite_psubset_def)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g x xs ys.\n       \\<not> List.member ys x \\<Longrightarrow>\n       nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or>\n       nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and>\n       length (nexts g x) < Suc (length xs)\n 2. \\<And>g x ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys))\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - set (dfs2 g (nexts g x) (x # ys)) =\n                         nodes_of g - set ys", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def)", "action": "apply (case_tac  \"x \\<in> nodes_of g\")", "complete": false}, {"observation": "proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x; x \\<in> nodes_of g\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - insert x (set ys)\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - insert x (set ys) =\n                         nodes_of g - set ys \\<and>\n                         length (nexts g x) < Suc (length xs)\n 2. \\<And>g x xs ys.\n       \\<lbrakk>\\<not> List.member ys x; x \\<notin> nodes_of g\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - insert x (set ys)\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - insert x (set ys) =\n                         nodes_of g - set ys \\<and>\n                         length (nexts g x) < Suc (length xs)\n 3. \\<And>g x ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys))\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - set (dfs2 g (nexts g x) (x # ys)) =\n                         nodes_of g - set ys", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) \\n apply (case_tac  \"x \\<in> nodes_of g\")", "action": "apply (auto simp add: List.member_def)[2]", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g x ys.\n       \\<lbrakk>\\<not> List.member ys x;\n        dfs2_dom (g, nexts g x, x # ys)\\<rbrakk>\n       \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys))\n                         \\<subset> nodes_of g - set ys \\<or>\n                         nodes_of g - set (dfs2 g (nexts g x) (x # ys)) =\n                         nodes_of g - set ys", "extra context": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than)  \n                   (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) \\n apply (case_tac  \"x \\<in> nodes_of g\") \\n apply (auto simp add: List.member_def)[2]", "action": "by (insert dfs2_invariant) force", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []", "extra context": "lemma [simp]: \"x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []\"", "action": "by (induct g) (auto simp add: nodes_of_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "action": "proof(induct g xs ys rule: dfs.induct)", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>g ys. set (dfs g [] ys) \\<subseteq> reachable g [] \\<union> set ys\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct)", "action": "case 1", "complete": false}, {"observation": "proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>g ys. set (dfs g [] ys) \\<subseteq> reachable g [] \\<union> set ys\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1", "action": "then", "complete": false}, {"observation": "proof (chain)\npicking this:", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g_ [] ys_) \\<subseteq> reachable g_ [] \\<union> set ys_", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  set (dfs g_ [] ys_) \\<subseteq> reachable g_ [] \\<union> set ys_\n\ngoal (1 subgoal):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next", "action": "case (2 g x xs ys)", "complete": false}, {"observation": "proof (state)\nthis:\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n\ngoal (1 subgoal):\n 1. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set (dfs g xs ys)\n                \\<subseteq> reachable g xs \\<union> set ys;\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (dfs g (nexts g x @ xs) (x # ys))\n        \\<subseteq> reachable g (nexts g x @ xs) \\<union>\n                    set (x # ys)\\<rbrakk>\n       \\<Longrightarrow> set (dfs g (x # xs) ys)\n                         \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys)", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case", "action": "proof (cases \"x \\<in> set ys\")", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\")", "action": "case True", "complete": false}, {"observation": "proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True", "action": "with 2", "complete": false}, {"observation": "proof (chain)\npicking this:\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  x \\<in> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2", "action": "show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"", "action": "by (auto simp add: reachable_def List.member_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next", "action": "case False", "complete": false}, {"observation": "proof (state)\nthis:\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False", "action": "have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. reachable g (nexts g x) \\<subseteq> reachable g [x]", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "action": "by (rule reachable_nexts)", "complete": false}, {"observation": "proof (state)\nthis:\n  reachable g (nexts g x) \\<subseteq> reachable g [x]\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts)", "action": "hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  reachable g (nexts g x) \\<subseteq> reachable g [x]\n\ngoal (1 subgoal):\n 1. reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"", "action": "by(simp add: reachable_append, auto simp add: reachable_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def)", "action": "with False 2", "complete": false}, {"observation": "proof (chain)\npicking this:\n  x \\<notin> set ys\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2", "action": "show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  x \\<notin> set ys\n  List.member ys x \\<Longrightarrow>\n  set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (dfs g (nexts g x @ xs) (x # ys))\n  \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\n  reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)\n\ngoal (1 subgoal):\n 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"", "action": "by (auto simp add: reachable_def List.member_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n\ngoal:\nNo subgoals!", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def)", "action": "qed", "complete": false}, {"observation": "proof (state)\nthis:\n  set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys\n\ngoal:\nNo subgoals!", "extra context": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n qed", "action": "qed", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X = X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "action": "proof", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. r\\<^sup>* `` X \\<subseteq> X\n 2. X \\<subseteq> r\\<^sup>* `` X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof", "action": "show \"r\\<^sup>* `` X \\<subseteq> X\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\"", "action": "proof -", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof -", "action": "{", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n {", "action": "fix x y", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y", "action": "assume y: \"y \\<in> X\"", "complete": false}, {"observation": "proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\"", "action": "assume \"(y,x) \\<in> r\\<^sup>*\"", "complete": false}, {"observation": "proof (state)\nthis:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\"", "action": "then", "complete": false}, {"observation": "proof (chain)\npicking this:\n  (y, x) \\<in> r\\<^sup>*", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then", "action": "have \"x \\<in> X\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<in> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\"", "action": "by (induct) (insert assms y, auto simp add: Image_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def)", "action": "}", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n }", "action": "then", "complete": false}, {"observation": "proof (chain)\npicking this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. r\\<^sup>* `` X \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis", "action": "unfolding Image_def", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?x2 \\<in> X\n\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>X. (x, y) \\<in> r\\<^sup>*} \\<subseteq> X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis \\n unfolding Image_def", "action": "by auto", "complete": false}, {"observation": "proof (state)\nthis:\n  r\\<^sup>* `` X \\<subseteq> X\n\ngoal:\nNo subgoals!", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis \\n unfolding Image_def \\n by auto", "action": "qed", "complete": false}, {"observation": "proof (state)\nthis:\n  r\\<^sup>* `` X \\<subseteq> X\n\ngoal (1 subgoal):\n 1. X \\<subseteq> r\\<^sup>* `` X", "extra context": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis \\n unfolding Image_def \\n by auto \\n qed", "action": "qed auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (dfs g [x] [])) = ((x, y) \\<in> (set g)\\<^sup>*)", "extra context": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\"", "action": "by(simp only:dfs_eq_reachable reachable_def, auto)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(node, equal_class)", "extra context": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\" \\n by(simp only:dfs_eq_reachable reachable_def, auto)", "action": "proof", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "extra context": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\" \\n by(simp only:dfs_eq_reachable reachable_def, auto) \\n proof", "action": "qed (simp add: equal_node_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set (dfs g xs ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "action": "proof(induct g xs ys rule:dfs.induct)", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set xs \\<subseteq> set (dfs g xs ys);\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (nexts g x @ xs)\n        \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\\<rbrakk>\n       \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct)", "action": "case(2 g x xs ys)", "complete": false}, {"observation": "proof (state)\nthis:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n\ngoal (2 subgoals):\n 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)\n 2. \\<And>g x xs ys.\n       \\<lbrakk>List.member ys x \\<Longrightarrow>\n                set xs \\<subseteq> set (dfs g xs ys);\n        \\<not> List.member ys x \\<Longrightarrow>\n        set (nexts g x @ xs)\n        \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\\<rbrakk>\n       \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys)", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case", "action": "proof(cases \"x \\<in> set ys\")", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\")", "action": "case True", "complete": false}, {"observation": "proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True", "action": "have \"set ys \\<subseteq> set (dfs g xs ys)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (dfs g xs ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\"", "action": "by (rule visit_subset_dfs)", "complete": false}, {"observation": "proof (state)\nthis:\n  set ys \\<subseteq> set (dfs g xs ys)\n\ngoal (2 subgoals):\n 1. x \\<in> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n 2. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs)", "action": "with 2 and True", "complete": false}, {"observation": "proof (chain)\npicking this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<in> set ys\n  set ys \\<subseteq> set (dfs g xs ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<in> set ys\n  set ys \\<subseteq> set (dfs g xs ys)\n\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis", "action": "by (auto simp add: List.member_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next", "action": "case False", "complete": false}, {"observation": "proof (state)\nthis:\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False", "action": "have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"", "action": "by(rule visit_subset_dfs)", "complete": false}, {"observation": "proof (state)\nthis:\n  set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n\ngoal (1 subgoal):\n 1. x \\<notin> set ys \\<Longrightarrow>\n    set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs)", "action": "with 2 and False", "complete": false}, {"observation": "proof (chain)\npicking this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<notin> set ys\n  set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys)\n  \\<not> List.member ys x \\<Longrightarrow>\n  set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n  x \\<notin> set ys\n  set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\n\ngoal (1 subgoal):\n 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False \\n show ?thesis", "action": "by (auto simp add: List.member_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n\ngoal:\nNo subgoals!", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False \\n show ?thesis \\n by (auto simp add: List.member_def)", "action": "qed", "complete": false}, {"observation": "proof (state)\nthis:\n  set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)", "extra context": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False \\n show ?thesis \\n by (auto simp add: List.member_def) \\n qed", "action": "qed(simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. nextss g (x # xs) = set (nexts g x) \\<union> nextss g xs", "extra context": "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\"", "action": "unfolding nextss_def", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set g `` set (x # xs) = set (nexts g x) \\<union> set g `` set xs", "extra context": "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\" \\n unfolding nextss_def", "action": "by (auto simp add:Image_def nexts_set)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "action": "proof -", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof -", "action": "have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> reachable g (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"", "action": "unfolding reachable_def", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set xs\n    \\<subseteq> (set g)\\<^sup>* `` set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def", "action": "by (rule Image_mono) (auto simp add: next_subset_dfs)", "complete": false}, {"observation": "proof (state)\nthis:\n  reachable g xs \\<subseteq> reachable g (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs)", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  reachable g xs \\<subseteq> reachable g (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also", "action": "have \"\\<dots> = set(dfs g xs [])\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. reachable g (dfs g xs []) = set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\"", "action": "unfolding reachable_def", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (set g)\\<^sup>* `` set (dfs g xs []) = set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def", "action": "proof (rule Image_closed_trancl)", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl)", "action": "from nextss_closed_dfs", "complete": false}, {"observation": "proof (chain)\npicking this:\n  nextss ?g (dfs ?g ?xs []) \\<subseteq> set (dfs ?g ?xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs", "action": "show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  nextss ?g (dfs ?g ?xs []) \\<subseteq> set (dfs ?g ?xs [])\n\ngoal (1 subgoal):\n 1. set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"", "action": "by (simp add: nextss_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\n\ngoal:\nNo subgoals!", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def)", "action": "qed", "complete": false}, {"observation": "proof (state)\nthis:\n  reachable g (dfs g xs []) = set (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed", "action": "finally", "complete": false}, {"observation": "proof (chain)\npicking this:\n  reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed \\n finally", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  reachable g xs \\<subseteq> set (dfs g xs [])\n\ngoal (1 subgoal):\n 1. reachable g xs \\<subseteq> set (dfs g xs [])", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed \\n finally \\n show ?thesis", "action": ".", "complete": false}, {"observation": "proof (state)\nthis:\n  reachable g xs \\<subseteq> set (dfs g xs [])\n\ngoal:\nNo subgoals!", "extra context": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed \\n finally \\n show ?thesis \\n .", "action": "qed", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])", "extra context": "lemma nextss_closed_dfs: \"nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])\"", "action": "by (rule nextss_closed_dfs', simp add: nextss_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun \\<langle>l, x, r\\<rangle>; heap l; heap r\\<rbrakk>\n    \\<Longrightarrow> heap (merge l r)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "action": "proof(induction l r rule: merge.induct)", "complete": false}, {"observation": "proof (state)\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle>; heap l;\n        heap \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (merge l \\<langle>\\<rangle>)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 3. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct)", "action": "case 1", "complete": false}, {"observation": "proof (state)\nthis:\n  braun \\<langle>l_, x, \\<langle>\\<rangle>\\<rangle>\n  heap l_\n  heap \\<langle>\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle>; heap l;\n        heap \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (merge l \\<langle>\\<rangle>)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 3. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun \\<langle>l_, x, \\<langle>\\<rangle>\\<rangle>\n  heap l_\n  heap \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge l_ \\<langle>\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  heap (merge l_ \\<langle>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next", "action": "case (2 l1 a1 r1 l2 a2 r2)", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1;\n   heap r1\\<rbrakk>\n  \\<Longrightarrow> heap (merge l1 r1)\n  braun\n   \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n    \\<langle>l2, a2, r2\\<rangle>\\<rangle>\n  heap \\<langle>l1, a1, r1\\<rangle>\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2)", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case", "action": "proof cases", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases", "action": "assume \"a1 \\<le> a2\"", "complete": false}, {"observation": "proof (state)\nthis:\n  a1 \\<le> a2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\"", "action": "thus ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis", "action": "using 2", "complete": false}, {"observation": "proof (prove)\nusing this:\n  a1 \\<le> a2\n  \\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1;\n   heap r1\\<rbrakk>\n  \\<Longrightarrow> heap (merge l1 r1)\n  braun\n   \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n    \\<langle>l2, a2, r2\\<rangle>\\<rangle>\n  heap \\<langle>l1, a1, r1\\<rangle>\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2", "action": "by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)", "complete": false}, {"observation": "proof (state)\nthis:\n  heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next", "action": "assume \"\\<not> a1 \\<le> a2\"", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<not> a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\"", "action": "let ?l = \"Node l1 a1 r1\"", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\"", "action": "let ?r = \"Node l2 a2 r2\"", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\"", "action": "have \"braun ?r\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l2, a2, r2\\<rangle>", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\"", "action": "using \"2.prems\"(1)", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun\n   \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n    \\<langle>l2, a2, r2\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. braun \\<langle>l2, a2, r2\\<rangle>", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1)", "action": "by auto", "complete": false}, {"observation": "proof (state)\nthis:\n  braun \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto", "action": "obtain x l' where dl: \"del_left ?l = (x, l')\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x l'.\n        del_left \\<langle>l1, a1, r1\\<rangle> = (x, l') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\"", "action": "by (metis surj_pair)", "complete": false}, {"observation": "proof (state)\nthis:\n  del_left \\<langle>l1, a1, r1\\<rangle> = (x, l')\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair)", "action": "from del_left_heap[OF this _ \"2.prems\"(2)]", "complete": false}, {"observation": "proof (chain)\npicking this:\n  \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  heap l'", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)]", "action": "have \"heap l'\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  heap l'\n\ngoal (1 subgoal):\n 1. heap l'", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\"", "action": "by auto", "complete": false}, {"observation": "proof (state)\nthis:\n  heap l'\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto", "action": "have hr: \"heap(replace_min x ?r)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\"", "action": "using \\<open>braun ?r\\<close> \"2.prems\"(3)", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun \\<langle>l2, a2, r2\\<rangle>\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3)", "action": "by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)", "complete": false}, {"observation": "proof (state)\nthis:\n  heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)", "action": "have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"", "action": "using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close>", "complete": false}, {"observation": "proof (prove)\nusing this:\n  heap \\<langle>l1, a1, r1\\<rangle>\n  \\<not> a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close>", "action": "by (auto simp: ball_Un)", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un)", "action": "moreover", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover", "action": "have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> &&&\n    x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"", "action": "using del_left_mset[OF dl]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  x \\<in># mset_tree \\<langle>l1, a1, r1\\<rangle> \\<and>\n  mset_tree l' = mset_tree \\<langle>l1, a1, r1\\<rangle> - {#x#}\n\ngoal (1 subgoal):\n 1. set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> &&&\n    x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl]", "action": "by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle>\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)", "action": "ultimately", "complete": false}, {"observation": "proof (chain)\npicking this:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n  set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle>\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately", "action": "have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n  set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle>\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree l'. a2 \\<le> x", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"", "action": "by blast", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<forall>x\\<in>set_tree l'. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast", "action": "have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"", "action": "using \\<open>heap ?r\\<close>", "complete": false}, {"observation": "proof (prove)\nusing this:\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close>", "action": "by auto", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto", "action": "thus ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis", "action": "using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close>", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x\n  \\<not> a1 \\<le> a2\n  del_left \\<langle>l1, a1, r1\\<rangle> = (x, l')\n  heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)\n  heap l'\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n  \\<forall>x\\<in>set_tree l'. a2 \\<le> x\n  braun \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close>", "action": "by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps)", "complete": false}, {"observation": "proof (state)\nthis:\n  heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n\ngoal:\nNo subgoals!", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps)", "action": "qed", "complete": false}, {"observation": "proof (state)\nthis:\n  heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps) \\n qed", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps) \\n qed \\n next", "action": "case 3", "complete": false}, {"observation": "proof (state)\nthis:\n  braun\n   \\<langle>\\<langle>\\<rangle>, x, \\<langle>v_, va_, vb_\\<rangle>\\<rangle>\n  heap \\<langle>\\<rangle>\n  heap \\<langle>v_, va_, vb_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps) \\n qed \\n next \\n case 3", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun\n   \\<langle>\\<langle>\\<rangle>, x, \\<langle>v_, va_, vb_\\<rangle>\\<rangle>\n  heap \\<langle>\\<rangle>\n  heap \\<langle>v_, va_, vb_\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>\\<rangle> \\<langle>v_, va_, vb_\\<rangle>)", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps) \\n qed \\n next \\n case 3 \\n thus ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  heap (merge \\<langle>\\<rangle> \\<langle>v_, va_, vb_\\<rangle>)\n\ngoal:\nNo subgoals!", "extra context": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps) \\n qed \\n next \\n case 3 \\n thus ?case \\n by simp", "action": "qed", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    braun (merge l r) \\<and> size (merge l r) = size l + size r", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "action": "apply(induction l r rule: merge.induct)", "complete": false}, {"observation": "proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l.\n       braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle> \\<Longrightarrow>\n       braun (merge l \\<langle>\\<rangle>) \\<and>\n       size (merge l \\<langle>\\<rangle>) = size l + size \\<langle>\\<rangle>\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2;\n                 braun \\<langle>l1, x, r1\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> braun (merge l1 r1) \\<and>\n                                  size (merge l1 r1) = size l1 + size r1;\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) \\<and>\n                         size\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) =\n                         size \\<langle>l1, a1, r1\\<rangle> +\n                         size \\<langle>l2, a2, r2\\<rangle>\n 3. \\<And>v va vb.\n       braun\n        \\<langle>\\<langle>\\<rangle>, x,\n         \\<langle>v, va, vb\\<rangle>\\<rangle> \\<Longrightarrow>\n       braun (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>) \\<and>\n       size (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>) =\n       size \\<langle>\\<rangle> + size \\<langle>v, va, vb\\<rangle>", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct)", "action": "apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split)", "action": "done", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue \\<langle>\\<rangle> (\\<lambda>h. h = \\<langle>\\<rangle>)\n     insert get_min del_min2 (\\<lambda>h. braun h \\<and> heap h) mset_tree", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done", "action": "proof(standard, goal_cases)", "complete": false}, {"observation": "proof (state)\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases)", "action": "case 1", "complete": false}, {"observation": "proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>\\<rangle> = {#}", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next", "action": "case 2", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next", "action": "case 3", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case", "action": "by(simp add: mset_insert)", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next", "action": "case 4", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#}", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case", "action": "by(auto simp: mset_tree_merge neq_Leaf_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next", "action": "case 5", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case", "action": "using get_min mset_tree.simps(1)", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n  \\<lbrakk>heap ?t; ?t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t)\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1)", "action": "by blast", "complete": false}, {"observation": "proof (state)\nthis:\n  get_min q_ = Min_mset (mset_tree q_)\n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next", "action": "case 6", "complete": false}, {"observation": "proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case", "action": "by(simp)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next", "action": "case 7", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n\ngoal (1 subgoal):\n 1. braun (insert x_ q_) \\<and> heap (insert x_ q_)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case", "action": "by(simp add: heap_insert braun_insert)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun (insert x_ q_) \\<and> heap (insert x_ q_)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next", "action": "case 8", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. braun (del_min2 q_) \\<and> heap (del_min2 q_)", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case", "action": "by(auto simp: heap_merge braun_size_merge neq_Leaf_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun (del_min2 q_) \\<and> heap (del_min2 q_)\n\ngoal:\nNo subgoals!", "extra context": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case \\n by(auto simp: heap_merge braun_size_merge neq_Leaf_iff)", "action": "qed", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    mset_tree (merge l r) = mset_tree l + mset_tree r", "extra context": "lemma mset_tree_merge:\n  \"braun (Node l x r) \\<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r\"", "action": "by(induction l r rule: merge.induct)\n  (auto simp: Let_def tree.set_sel(2) mset_sift_down replace_min_sift_down\n        simp del: replace_min.simps dest!: del_left_mset split!: prod.split)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    replace_min x \\<langle>l, a, r\\<rangle> = sift_down l x r", "extra context": "lemma replace_min_sift_down: \"braun (Node l a r) \\<Longrightarrow> replace_min x (Node l a r) = sift_down l x r\"", "action": "by(induction l x r rule: sift_down.induct)(auto)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); braun t;\n     t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> braun t' \\<and> size t = size t' + 1", "extra context": "lemma del_left_braun_size:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t' \\<and> size t = size t' + 1\"", "action": "by (simp add: del_left_braun del_left_size)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>;\n     heap t\\<rbrakk>\n    \\<Longrightarrow> heap t'", "extra context": "lemma del_left_heap:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> heap t \\<Longrightarrow> heap t'\"", "action": "by (induction t arbitrary: x t' rule: del_left.induct;\n    fastforce split: prod.splits dest: del_left_set[THEN equalityD2])", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "action": "proof(cases t rule: del_min.cases)", "complete": false}, {"observation": "proof (state)\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases)", "action": "case 1", "complete": false}, {"observation": "proof (state)\nthis:\n  t = \\<langle>\\<rangle>\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1", "action": "with assms", "complete": false}, {"observation": "proof (chain)\npicking this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<rangle>", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (del_min t) = mset_tree t - {#get_min t#}\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next", "action": "case 2", "complete": false}, {"observation": "proof (state)\nthis:\n  t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2", "action": "with assms", "complete": false}, {"observation": "proof (chain)\npicking this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis", "action": "by (simp)", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (del_min t) = mset_tree t - {#get_min t#}\n\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next", "action": "case [simp]: (3 ll b lr a r)", "complete": false}, {"observation": "proof (state)\nthis:\n  t = \\<langle>\\<langle>ll, b, lr\\<rangle>, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r)", "action": "have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l'", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l'", "action": "using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and>\n  mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#}\n  \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  size \\<langle>ll, b, lr\\<rangle> = size l' + 1\n  \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>;\n   \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> braun l'\n  \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\n\ngoal (1 subgoal):\n 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del]", "action": "apply (subst mset_sift_down)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>braun t; t \\<noteq> \\<langle>\\<rangle>;\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and>\n     mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#};\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     size \\<langle>ll, b, lr\\<rangle> = size l' + 1;\n     \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>;\n      \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> braun l';\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\\<rbrakk>\n    \\<Longrightarrow> braun \\<langle>r, y, l'\\<rangle>\n 2. \\<lbrakk>braun t; t \\<noteq> \\<langle>\\<rangle>;\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and>\n     mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#};\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     size \\<langle>ll, b, lr\\<rangle> = size l' + 1;\n     \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>;\n      \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> braun l';\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\\<rbrakk>\n    \\<Longrightarrow> {#y#} + (mset_tree r + mset_tree l') =\n                      mset_tree t - {#a#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down)", "action": "apply (auto simp: ac_simps del_left_mset_plus[OF del])", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del])", "action": "done", "complete": false}, {"observation": "proof (state)\nthis:\n  del_left \\<langle>ll, b, lr\\<rangle> = (?y, ?l') \\<Longrightarrow>\n  mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#}\n\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done", "action": "thus ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  del_left \\<langle>ll, b, lr\\<rangle> = (?y, ?l') \\<Longrightarrow>\n  mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis", "action": "by(auto split: prod.split)", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (del_min t) = mset_tree t - {#get_min t#}\n\ngoal:\nNo subgoals!", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split)", "action": "qed", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue \\<langle>\\<rangle> (\\<lambda>h. h = \\<langle>\\<rangle>)\n     insert get_min del_min (\\<lambda>h. braun h \\<and> heap h) mset_tree", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed", "action": "proof(standard, goal_cases)", "complete": false}, {"observation": "proof (state)\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases)", "action": "case 1", "complete": false}, {"observation": "proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>\\<rangle> = {#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next", "action": "case 2", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next", "action": "case 3", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case", "action": "by(simp add: mset_insert)", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next", "action": "case 4", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case", "action": "by(simp add: mset_del_min)", "complete": false}, {"observation": "proof (state)\nthis:\n  mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next", "action": "case 5", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case", "action": "using get_min mset_tree.simps(1)", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n  \\<lbrakk>heap ?t; ?t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t)\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1)", "action": "by blast", "complete": false}, {"observation": "proof (state)\nthis:\n  get_min q_ = Min_mset (mset_tree q_)\n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next", "action": "case 6", "complete": false}, {"observation": "proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case", "action": "by(simp)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next", "action": "case 7", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n\ngoal (1 subgoal):\n 1. braun (insert x_ q_) \\<and> heap (insert x_ q_)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case", "action": "by(simp add: heap_insert braun_insert)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun (insert x_ q_) \\<and> heap (insert x_ q_)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert)", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next", "action": "case 8", "complete": false}, {"observation": "proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. braun (del_min q_) \\<and> heap (del_min q_)", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case", "action": "by(simp add: heap_del_min braun_del_min)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun (del_min q_) \\<and> heap (del_min q_)\n\ngoal:\nNo subgoals!", "extra context": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case \\n by(simp add: heap_del_min braun_del_min)", "action": "qed", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> braun (insert x t)", "extra context": "lemma braun_insert: \"braun t \\<Longrightarrow> braun(insert x t)\"", "action": "by(induction t arbitrary: x) auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (insert x t) = {#x#} + mset_tree t", "extra context": "lemma mset_insert: \"mset_tree(insert x t) = {#x#} + mset_tree t\"", "action": "by(induction t arbitrary: x) (auto simp: ac_simps)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set_tree (insert x t) = {x} \\<union> set_tree t", "extra context": "lemma set_insert[simp]: \"set_tree(insert x t) = {x} \\<union> (set_tree t)\"", "action": "by(simp add: mset_insert flip: set_mset_tree)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. heap t \\<Longrightarrow> heap (insert x t)", "extra context": "lemma heap_insert: \"heap t \\<Longrightarrow> heap(insert x t)\"", "action": "by(induction t arbitrary: x) (auto  simp add: ball_Un)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    size (sift_down l a r) = size l + size r + 1", "extra context": "lemma size_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> size(sift_down l a r) = size l + size r + 1\"", "action": "by(induction l a r rule: sift_down.induct) (auto simp: Let_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'", "extra context": "lemma del_left_mset_plus:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'\"", "action": "by (induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun \\<langle>l, a, r\\<rangle>; heap l; heap r\\<rbrakk>\n    \\<Longrightarrow> heap (sift_down l a r)", "extra context": "lemma heap_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap(sift_down l a r)\"", "action": "by (induction l a r rule: sift_down.induct) (auto simp: set_sift_down ball_Un Let_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap t; t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> get_min t = Min_mset (mset_tree t)", "extra context": "lemma get_min: \"\\<lbrakk> heap t;  t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)\"", "action": "by (auto simp add: eq_Min_iff neq_Leaf_iff)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> 2 ^ height t \\<le> 2 * size t + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "action": "proof(induction t)", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. braun \\<langle>\\<rangle> \\<Longrightarrow>\n    2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>braun t1 \\<Longrightarrow>\n                2 ^ height t1 \\<le> 2 * size t1 + 1;\n        braun t2 \\<Longrightarrow> 2 ^ height t2 \\<le> 2 * size t2 + 1;\n        braun \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height \\<langle>t1, x2, t2\\<rangle>\n                         \\<le> 2 * size \\<langle>t1, x2, t2\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t)", "action": "case (Node t1)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (2 subgoals):\n 1. braun \\<langle>\\<rangle> \\<Longrightarrow>\n    2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>braun t1 \\<Longrightarrow>\n                2 ^ height t1 \\<le> 2 * size t1 + 1;\n        braun t2 \\<Longrightarrow> 2 ^ height t2 \\<le> 2 * size t2 + 1;\n        braun \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height \\<langle>t1, x2, t2\\<rangle>\n                         \\<le> 2 * size \\<langle>t1, x2, t2\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1)", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case", "action": "proof (cases \"height t1\")", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. height t1 = 0 \\<Longrightarrow>\n    2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n 2. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\")", "action": "case 0", "complete": false}, {"observation": "proof (state)\nthis:\n  height t1 = 0\n\ngoal (2 subgoals):\n 1. height t1 = 0 \\<Longrightarrow>\n    2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n 2. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0", "action": "thus ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  height t1 = 0\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis", "action": "using Node", "complete": false}, {"observation": "proof (prove)\nusing this:\n  height t1 = 0\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n  \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next", "action": "case (Suc n)", "complete": false}, {"observation": "proof (state)\nthis:\n  height t1 = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n)", "action": "hence \"2 ^ n \\<le> size t1\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  height t1 = Suc n\n\ngoal (1 subgoal):\n 1. 2 ^ n \\<le> size t1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\"", "action": "using Node", "complete": false}, {"observation": "proof (prove)\nusing this:\n  height t1 = Suc n\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 ^ n \\<le> size t1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  2 ^ n \\<le> size t1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp", "action": "thus ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  2 ^ n \\<le> size t1\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis", "action": "using Suc Node", "complete": false}, {"observation": "proof (prove)\nusing this:\n  2 ^ n \\<le> size t1\n  height t1 = Suc n\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis \\n using Suc Node", "action": "by(auto simp: max_def)", "complete": false}, {"observation": "proof (state)\nthis:\n  2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n  \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n\ngoal:\nNo subgoals!", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis \\n using Suc Node \\n by(auto simp: max_def)", "action": "qed", "complete": false}, {"observation": "proof (state)\nthis:\n  2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n  \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. braun \\<langle>\\<rangle> \\<Longrightarrow>\n    2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1", "extra context": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis \\n using Suc Node \\n by(auto simp: max_def) \\n qed", "action": "qed simp", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    set_tree (sift_down l a r) =\n    {a} \\<union> (set_tree l \\<union> set_tree r)", "extra context": "lemma set_sift_down: \"braun(Node l a r)\n  \\<Longrightarrow> set_tree(sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)\"", "action": "by(drule arg_cong[where f=set_mset, OF mset_sift_down]) (simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    mset_tree (sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)", "extra context": "lemma mset_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)\"", "action": "by(induction l a r rule: sift_down.induct) (auto simp: ac_simps Let_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    braun (sift_down l a r)", "extra context": "lemma braun_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> braun(sift_down l a r)\"", "action": "by(induction l a r rule: sift_down.induct) (auto simp: size_sift_down Let_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'", "extra context": "lemma del_left_set:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'\"", "action": "by(simp add: del_left_mset_plus flip: set_mset_tree)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap t; braun t\\<rbrakk> \\<Longrightarrow> heap (del_min t)", "extra context": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "action": "apply(cases t rule: del_min.cases)", "complete": false}, {"observation": "proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>heap t; braun t; t = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> heap (del_min t)\n 2. \\<And>x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)\n 3. \\<And>v va vb x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)", "extra context": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases)", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)\n 2. \\<And>v va vb x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)", "extra context": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)", "extra context": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp", "action": "apply (fastforce split: prod.split intro!: heap_sift_down\n  dest: del_left_size del_left_braun del_left_heap)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp \\n apply (fastforce split: prod.split intro!: heap_sift_down\n  dest: del_left_size del_left_braun del_left_heap)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> size t = size t' + 1", "extra context": "lemma del_left_size:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> size t = size t' + 1\"", "action": "by(induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); braun t;\n     t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> braun t'", "extra context": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"", "action": "by(induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits dest: del_left_size)", "complete": false}, {"observation": "proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>a uu_.\n                   x = (\\<langle>\\<rangle>, a, uu_) \\<Longrightarrow> P;\n        \\<And>xa uv_ a.\n           x =\n           (\\<langle>\\<langle>\\<rangle>, xa, uv_\\<rangle>, a,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>l1 x1 r1 a l2 x2 r2.\n           x =\n           (\\<langle>l1, x1, r1\\<rangle>, a,\n            \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>vc vd ve va vb b.\n           x =\n           (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a uu_ aa uua_.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>\\<rangle>, aa, uua_) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       \\<langle>\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle>\n 3. \\<And>a uu_ x uv_ aa.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       (if aa \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              aa, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, aa,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>)\n 4. \\<And>a uu_ l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2\n           then \\<langle>t1, aa, t2\\<rangle>\n           else if x1 \\<le> x2\n                then \\<langle>sift_down_sumC (l1, aa, r1), x1, t2\\<rangle>\n                else \\<langle>t1, x2, sift_down_sumC (l2, aa, r2)\\<rangle>)\n 5. \\<And>a uu_ vc vd ve va vb b.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       undefined\n 6. \\<And>x uv_ a xa uva_ aa.\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>\\<rangle>, xa, uva_\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       (if a \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              a, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>) =\n       (if aa \\<le> xa\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, xa,\n                       \\<langle>\\<rangle>\\<rangle>,\n              aa, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, aa,\n                       \\<langle>\\<rangle>\\<rangle>,\n              xa, \\<langle>\\<rangle>\\<rangle>)\n 7. \\<And>x uv_ a l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       (if a \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              a, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>) =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2\n           then \\<langle>t1, aa, t2\\<rangle>\n           else if x1 \\<le> x2\n                then \\<langle>sift_down_sumC (l1, aa, r1), x1, t2\\<rangle>\n                else \\<langle>t1, x2, sift_down_sumC (l2, aa, r2)\\<rangle>)\n 8. \\<And>x uv_ a vc vd ve va vb b.\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       (if a \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              a, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>) =\n       undefined\n 9. \\<And>l1 x1 r1 a l2 x2 r2 l1a x1a r1a aa l2a x2a r2a.\n       (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) =\n       (\\<langle>l1a, x1a, r1a\\<rangle>, aa,\n        \\<langle>l2a, x2a, r2a\\<rangle>) \\<Longrightarrow>\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if a \\<le> x1 \\<and> a \\<le> x2 then \\<langle>t1, a, t2\\<rangle>\n           else if x1 \\<le> x2\n                then \\<langle>sift_down_sumC (l1, a, r1), x1, t2\\<rangle>\n                else \\<langle>t1, x2, sift_down_sumC (l2, a, r2)\\<rangle>) =\n       (let t2 = \\<langle>l2a, x2a, r2a\\<rangle>;\n            t1 = \\<langle>l1a, x1a, r1a\\<rangle>\n        in if aa \\<le> x1a \\<and> aa \\<le> x2a\n           then \\<langle>t1, aa, t2\\<rangle>\n           else if x1a \\<le> x2a\n                then \\<langle>sift_down_sumC (l1a, aa, r1a), x1a,\n                      t2\\<rangle>\n                else \\<langle>t1, x2a,\n                      sift_down_sumC (l2a, aa, r2a)\\<rangle>)\n 10. \\<And>l1 x1 r1 a l2 x2 r2 vc vd ve va vb b.\n        (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) =\n        (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n         \\<langle>\\<rangle>) \\<Longrightarrow>\n        (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n             t1 = \\<langle>l1, x1, r1\\<rangle>\n         in if a \\<le> x1 \\<and> a \\<le> x2 then \\<langle>t1, a, t2\\<rangle>\n            else if x1 \\<le> x2\n                 then \\<langle>sift_down_sumC (l1, a, r1), x1, t2\\<rangle>\n                 else \\<langle>t1, x2,\n                       sift_down_sumC (l2, a, r2)\\<rangle>) =\n        undefined\nA total of 11 subgoals...", "extra context": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\" \\n by(induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits dest: del_left_size)", "action": "by pat_completeness auto", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. All sift_down_dom", "extra context": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\" \\n by(induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits dest: del_left_size) \\n by pat_completeness auto", "action": "by (relation \"measure (%(l,a,r). size l + size r)\") auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. size (insert x t) = size t + 1", "extra context": "lemma size_insert[simp]: \"size(insert x t) = size t + 1\"", "action": "by(induction t arbitrary: x) auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> braun (del_min t)", "extra context": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "action": "apply(cases t rule: del_min.cases)", "complete": false}, {"observation": "proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>braun t; t = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> braun (del_min t)\n 2. \\<And>x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)\n 3. \\<And>v va vb x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)", "extra context": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases)", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)\n 2. \\<And>v va vb x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)", "extra context": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)", "extra context": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp", "action": "apply (fastforce split: prod.split intro!: braun_sift_down\n  dest: del_left_size del_left_braun)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp \\n apply (fastforce split: prod.split intro!: braun_sift_down\n  dest: del_left_size del_left_braun)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify n xs = (t, ys); n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> ys = drop n xs", "extra context": "lemma heapify_snd_tup:\n  \"heapify n xs = (t, ys) \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow> ys = drop n xs\"", "action": "by (drule heapify_snd, simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_A t\n    \\<le> 2 * nat \\<lceil>log 2 (real (size t + 1))\\<rceil> * size t", "extra context": "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\"", "action": "using t_list_of_A_bound[of t]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  t_list_of_A t \\<le> 2 * height t * size t\n\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_A t\n    \\<le> 2 * nat \\<lceil>log 2 (real (size t + 1))\\<rceil> * size t", "extra context": "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\" \\n using t_list_of_A_bound[of t]", "action": "by (simp add: height_acomplete acomplete_if_braun size1_size)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. heap (heap_of_A xs)", "extra context": "lemma heap_heap_of_A: \"heap (heap_of_A xs)\"", "action": "by(induction xs)(simp_all add: heap_insert)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "action": "proof -", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof -", "action": "have \"?lhs \\<le> ?lhs\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\"", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n  \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n  \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also", "action": "note t_heap_of_A_log_bound[of xs]", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs\n  \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs]", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs\n  \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also", "action": "note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]", "complete": false}, {"observation": "proof (state)\nthis:\n  t_list_of_A (heap_of_A xs)\n  \\<le> 2 * nat \\<lceil>log 2 (real (size (heap_of_A xs) + 1))\\<rceil> *\n        size (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]", "action": "finally", "complete": false}, {"observation": "proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_A (heap_of_A xs)\n              \\<le> y + t_list_of_A (heap_of_A xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + x\n      \\<le> length xs *\n            (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) +\n            y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n                    \\<le> length xs *\n                          (nat \\<lceil>log 2\n  (real (length xs + 1))\\<rceil> +\n                           1) +\n                          2 *\n                          nat \\<lceil>log 2\n (real (size (heap_of_A xs) + 1))\\<rceil> *\n                          size (heap_of_A xs)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_A (heap_of_A xs)\n              \\<le> y + t_list_of_A (heap_of_A xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + x\n      \\<le> length xs *\n            (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) +\n            y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n                    \\<le> length xs *\n                          (nat \\<lceil>log 2\n  (real (length xs + 1))\\<rceil> +\n                           1) +\n                          2 *\n                          nat \\<lceil>log 2\n (real (size (heap_of_A xs) + 1))\\<rceil> *\n                          size (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally \\n show ?thesis", "action": "by (simp add: size_heap_of_A)", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n  \\<le> 3 * length xs *\n        (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)\n\ngoal:\nNo subgoals!", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally \\n show ?thesis \\n by (simp add: size_heap_of_A)", "action": "qed", "complete": false}, {"observation": "proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = \\<langle>\\<rangle> \\<Longrightarrow> P;\n        \\<And>l a r.\n           x = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<langle>\\<rangle> = \\<langle>\\<rangle> \\<Longrightarrow> [] = []\n 3. \\<And>l a r.\n       \\<langle>\\<rangle> = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n       [] = a # list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>)\n 4. \\<And>l a r la aa ra.\n       \\<langle>l, a, r\\<rangle> =\n       \\<langle>la, aa, ra\\<rangle> \\<Longrightarrow>\n       a # list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) =\n       aa # list_of_B_sumC (del_min \\<langle>la, aa, ra\\<rangle>)", "extra context": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally \\n show ?thesis \\n by (simp add: size_heap_of_A) \\n qed", "action": "by pat_completeness auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_B t \\<le> 3 * (height t + 1) * size t", "extra context": "lemma t_list_of_B_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t\"", "action": "by (erule t_list_of_B_induct, simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_merge l r \\<le> max (height l) (height r)", "extra context": "lemma t_merge_height:\n  \"t_merge l r \\<le> max (height l) (height r)\"", "action": "by (induct rule: t_merge.induct, auto)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "action": "apply (cases t rule: t_del_min.cases; simp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>(Suc (size v + size vb) = size r \\<or>\n                 size v + size vb = size r) \\<and>\n                (size v = size vb \\<or> size v = Suc (size vb)) \\<and>\n                braun v \\<and> braun vb \\<and> braun r;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (case del_left \\<langle>v, va, vb\\<rangle> of\n                          (y, l') \\<Rightarrow>\n                            t_del_left \\<langle>v, va, vb\\<rangle> +\n                            t_sift_down r y l')\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp)", "action": "apply (clarsimp split: prod.split)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split)", "action": "apply (frule del_left_braun, simp+)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2);\n        braun x2\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+)", "action": "apply (frule del_left_size, simp+)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+)", "action": "apply (frule del_left_height, simp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp)", "action": "apply (rule order_trans)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> ?y30 v va vb x r x1 x2\n 2. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ?y30 v va vb x r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans)", "action": "apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> Suc (max (height v) (height vb))\\<rbrakk>\n       \\<Longrightarrow> size r = size x2 \\<or> size r = Suc (size x2)\n 2. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 * height \\<langle>v, va, vb\\<rangle> +\n                         height \\<langle>r, x1, x2\\<rangle>\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]", "action": "apply auto[1]", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 * height \\<langle>v, va, vb\\<rangle> +\n                         height \\<langle>r, x1, x2\\<rangle>\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] \\n apply auto[1]", "action": "apply (simp add: max_def)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] \\n apply auto[1] \\n apply (simp add: max_def)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. height l \\<le> Suc (height r)", "extra context": "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\"", "action": "using b acomplete_if_braun[OF b] min_height_le_height[of r]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun \\<langle>l, x, r\\<rangle>\n  acomplete \\<langle>l, x, r\\<rangle>\n  min_height r \\<le> height r\n\ngoal (1 subgoal):\n 1. height l \\<le> Suc (height r)", "extra context": "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\" \\n using b acomplete_if_braun[OF b] min_height_le_height[of r]", "action": "by (simp add: acomplete_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length xs \\<Longrightarrow>\n    t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "action": "proof (induct i xs rule: t_heapify.induct)", "complete": false}, {"observation": "proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       0 \\<le> length xs \\<Longrightarrow>\n       t_heapify 0 xs + height (fst (heapify 0 xs)) \\<le> 5 * 0 + 1\n 2. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 3. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct)", "action": "case (1 vs)", "complete": false}, {"observation": "proof (state)\nthis:\n  0 \\<le> length vs\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       0 \\<le> length xs \\<Longrightarrow>\n       t_heapify 0 xs + height (fst (heapify 0 xs)) \\<le> 5 * 0 + 1\n 2. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 3. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs)", "action": "thus ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  0 \\<le> length vs\n\ngoal (1 subgoal):\n 1. t_heapify 0 vs + height (fst (heapify 0 vs)) \\<le> 5 * 0 + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heapify 0 vs + height (fst (heapify 0 vs)) \\<le> 5 * 0 + 1\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp", "action": "next", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next", "action": "case (2 i x xs)", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa;\n   Suc i div 2 \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> t_heapify (Suc i div 2) xs +\n                    height (fst (heapify (Suc i div 2) xs))\n                    \\<le> 5 * (Suc i div 2) + 1\n  \\<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa;\n   ?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ?y;\n   (?xac, ?ya) = ?xab; i div 2 \\<le> length ?y\\<rbrakk>\n  \\<Longrightarrow> t_heapify (i div 2) ?y +\n                    height (fst (heapify (i div 2) ?y))\n                    \\<le> 5 * (i div 2) + 1\n  Suc i \\<le> length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs)", "action": "obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l ys.\n        heapify (Suc i div 2) xs = (l, ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"", "action": "by (simp add: prod_eq_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  heapify (Suc i div 2) xs = (l, ys)\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff)", "action": "note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]", "complete": false}, {"observation": "proof (state)\nthis:\n  Suc i div 2 \\<le> length xs \\<Longrightarrow>\n  t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs))\n  \\<le> Suc (5 * (Suc i div 2))\n  \\<lbrakk>?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ys;\n   (?xac, ?ya) = ?xab; i div 2 \\<le> length ys\\<rbrakk>\n  \\<Longrightarrow> t_heapify (i div 2) ys +\n                    height (fst (heapify (i div 2) ys))\n                    \\<le> Suc (5 * (i div 2))\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]", "action": "obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r zs.\n        heapify (i div 2) ys = (r, zs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"", "action": "by (simp add: prod_eq_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  heapify (i div 2) ys = (r, zs)\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff)", "action": "from \"2.prems\" heapify_snd_tup[OF h1]", "complete": false}, {"observation": "proof (chain)\npicking this:\n  Suc i \\<le> length (x # xs)\n  Suc i div 2 \\<le> length xs \\<Longrightarrow> ys = drop (Suc i div 2) xs", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1]", "action": "have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  Suc i \\<le> length (x # xs)\n  Suc i div 2 \\<le> length xs \\<Longrightarrow> ys = drop (Suc i div 2) xs\n\ngoal (1 subgoal):\n 1. Suc i div 2 \\<le> length xs &&&\n    i div 2 \\<le> length xs &&& i div 2 \\<le> length ys", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\"", "action": "by simp_all", "complete": false}, {"observation": "proof (state)\nthis:\n  Suc i div 2 \\<le> length xs\n  i div 2 \\<le> length xs\n  i div 2 \\<le> length ys\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all", "action": "note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs))\n  \\<le> Suc (5 * (Suc i div 2))\n  t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))\n  \\<le> Suc (5 * (i div 2))\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]", "action": "note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) +\n  (t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))) +\n  3\n  \\<le> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]", "action": "from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]", "complete": false}, {"observation": "proof (chain)\npicking this:\n  size l = Suc i div 2 \\<and>\n  heap l \\<and> braun l \\<and> mset_tree l = mset (take (Suc i div 2) xs)\n  size r = i div 2 \\<and>\n  heap r \\<and> braun r \\<and> mset_tree r = mset (take (i div 2) ys)", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]", "action": "have braun: \"braun \\<langle>l, x, r\\<rangle>\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  size l = Suc i div 2 \\<and>\n  heap l \\<and> braun l \\<and> mset_tree l = mset (take (Suc i div 2) xs)\n  size r = i div 2 \\<and>\n  heap r \\<and> braun r \\<and> mset_tree r = mset (take (i div 2) ys)\n\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle>", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\"", "action": "by auto", "complete": false}, {"observation": "proof (state)\nthis:\n  braun \\<langle>l, x, r\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto", "action": "have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_sift_down l x r \\<le> height l + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\"", "action": "using t_sift_down_height[OF braun] braun_height_r_le[OF braun]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>\n  height r \\<le> height l\n\ngoal (1 subgoal):\n 1. t_sift_down l x r \\<le> height l + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun]", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  t_sift_down l x r \\<le> height l + 1\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp", "action": "from t_sift_down_height[OF braun]", "complete": false}, {"observation": "proof (chain)\npicking this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun]", "action": "have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. height (sift_down l x r) \\<le> height r + 2", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\"", "action": "using sift_down_height[OF braun] braun_height_l_le[OF braun]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>\n  height (sift_down l x r) \\<le> height \\<langle>l, x, r\\<rangle>\n  height l \\<le> Suc (height r)\n\ngoal (1 subgoal):\n 1. height (sift_down l x r) \\<le> height r + 2", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun]", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  height (sift_down l x r) \\<le> height r + 2\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp", "action": "from h1 h2 t_sift_l height_sift_r \"2.prems\"", "complete": false}, {"observation": "proof (chain)\npicking this:\n  heapify (Suc i div 2) xs = (l, ys)\n  heapify (i div 2) ys = (r, zs)\n  t_sift_down l x r \\<le> height l + 1\n  height (sift_down l x r) \\<le> height r + 2\n  Suc i \\<le> length (x # xs)", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\"", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  heapify (Suc i div 2) xs = (l, ys)\n  heapify (i div 2) ys = (r, zs)\n  t_sift_down l x r \\<le> height l + 1\n  height (sift_down l x r) \\<le> height r + 2\n  Suc i \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs)))\n    \\<le> 5 * Suc i + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> t_heapify (Suc i div 2) xs +\n                      (t_heapify (i div 2) ys +\n                       (t_sift_down l x r + height (sift_down l x r)))\n                      \\<le> 5 + 5 * i", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp", "action": "apply (rule order_trans, rule order_trans[rotated], rule prem)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> t_heapify (Suc i div 2) xs +\n                      (t_heapify (i div 2) ys +\n                       (t_sift_down l x r + height (sift_down l x r)))\n                      \\<le> t_heapify (Suc i div 2) xs +\n                            height (fst (heapify (Suc i div 2) xs)) +\n                            (t_heapify (i div 2) ys +\n                             height (fst (heapify (i div 2) ys))) +\n                            3\n 2. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3\n                      \\<le> 5 + 5 * i", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem)", "action": "apply simp_all", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> 5 * (Suc i div 2) + 5 * (i div 2) \\<le> 5 * i", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all", "action": "apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> 0 < 5 \\<longrightarrow> Suc i div 2 + i div 2 \\<le> i", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all \\n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all \\n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) \\n apply simp", "action": "done", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs)))\n  \\<le> 5 * Suc i + 1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "extra context": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all \\n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) \\n apply simp \\n done", "action": "qed simp_all", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs\n    \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\"", "action": "using t_heap_of_A_bound[of xs]\n    acomplete_if_braun[OF braun_heap_of_A, of xs]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n  acomplete (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs\n    \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "extra context": "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\" \\n using t_heap_of_A_bound[of xs]\n    acomplete_if_braun[OF braun_heap_of_A, of xs]", "action": "by (simp add: height_acomplete size1_size size_heap_of_A)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. sorted (list_of_B (heap_of_B xs))", "extra context": "lemma sortedB: \"sorted (list_of_B (heap_of_B xs))\"", "action": "by (simp add: heap_of_B_def braun_heapify heap_heapify sorted_list_of_B)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_list_of_A t \\<le> 2 * height t * size t", "extra context": "lemma t_list_of_A_bound:\n  \"t_list_of_A t \\<le> 2 * height t * size t\"", "action": "by (rule t_list_of_A_induct, simp)", "complete": true}]
[]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> height (del_min t) \\<le> height t", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "action": "apply (cases t rule: del_min.cases; simp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>(Suc (size v + size vb) = size r \\<or>\n                 size v + size vb = size r) \\<and>\n                (size v = size vb \\<or> size v = Suc (size vb)) \\<and>\n                braun v \\<and> braun vb \\<and> braun r;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> height\n                          (case del_left \\<langle>v, va, vb\\<rangle> of\n                           (x, xa) \\<Rightarrow> sift_down r x xa)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp)", "action": "apply (clarsimp split: prod.split)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split)", "action": "apply (frule del_left_braun, simp+)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2);\n        braun x2\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+)", "action": "apply (frule del_left_size, simp+)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+)", "action": "apply (drule del_left_height)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; braun x2; size v + size vb = size x2\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v, va, vb\\<rangle> \\<noteq>\n                         \\<langle>\\<rangle>\n 2. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; braun x2; size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (drule del_left_height)", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; braun x2; size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (drule del_left_height) \\n apply simp", "action": "apply (rule order_trans, rule sift_down_height, auto)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (drule del_left_height) \\n apply simp \\n apply (rule order_trans, rule sift_down_height, auto)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs", "extra context": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "action": "apply (induct xs arbitrary: n rule: measure_induct[where f=length])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<forall>y.\n                   length y < length x \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        n \\<le> length x\\<rbrakk>\n       \\<Longrightarrow> snd (heapify n x) = drop n x", "extra context": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length])", "action": "apply (case_tac n; simp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n nat.\n       \\<lbrakk>\\<forall>y.\n                   length y < length x \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        Suc nat \\<le> length x; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> snd (heapify (Suc nat) x) = drop (Suc nat) x", "extra context": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp)", "action": "apply (clarsimp simp: Suc_le_length_iff case_prod_beta)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat ys.\n       \\<lbrakk>\\<forall>y.\n                   length y < Suc (length ys) \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        nat \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> drop (nat div 2 + Suc nat div 2) ys = drop nat ys", "extra context": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) \\n apply (clarsimp simp: Suc_le_length_iff case_prod_beta)", "action": "apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat ys.\n       \\<lbrakk>\\<forall>y.\n                   length y < Suc (length ys) \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        nat \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> nat div 2 + Suc nat div 2 = nat", "extra context": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) \\n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) \\n apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs])", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) \\n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) \\n apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs]) \\n apply simp", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. height \\<langle>l, x, r\\<rangle> = Suc (height l)", "extra context": "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\"", "action": "using b braun_height_r_le[OF b]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  braun \\<langle>l, x, r\\<rangle>\n  height r \\<le> height l\n\ngoal (1 subgoal):\n 1. height \\<langle>l, x, r\\<rangle> = Suc (height l)", "extra context": "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\" \\n using b braun_height_r_le[OF b]", "action": "by (auto simp add: max_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. sorted (list_of_A (heap_of_A xs))", "extra context": "lemma sortedA: \"sorted (list_of_A (heap_of_A xs))\"", "action": "by (simp add: heap_heap_of_A sorted_list_of_A)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap l; heap r\\<rbrakk> \\<Longrightarrow> heap (merge l r)", "extra context": "lemma merge_heap:\n  \"heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap (merge l r)\"", "action": "by (induct l r rule: merge.induct; auto simp: ball_Un)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set_tree (merge l r) = set_tree l \\<union> set_tree r", "extra context": "lemma set_tree_merge[simp]:\n  \"set_tree (merge l r) = set_tree l \\<union> set_tree r\"", "action": "by (induct l r rule: merge.induct; simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))", "extra context": "lemma braun_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))\"", "action": "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_A t) = mset_tree t", "extra context": "lemma mset_list_of_A[simp]:\n  \"mset (list_of_A t) = mset_tree t\"", "action": "by (induct t rule: list_of_A.induct; simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. height (merge l r) \\<le> Suc (max (height l) (height r))", "extra context": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"", "action": "by (induct rule: merge.induct, auto)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. height (merge l r) \\<le> height \\<langle>l, x, r\\<rangle>", "extra context": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\" \\n by (induct rule: merge.induct, auto)", "action": "using merge_height", "complete": false}, {"observation": "proof (prove)\nusing this:\n  height (merge ?l ?r) \\<le> Suc (max (height ?l) (height ?r))\n\ngoal (1 subgoal):\n 1. height (merge l r) \\<le> height \\<langle>l, x, r\\<rangle>", "extra context": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\" \\n by (induct rule: merge.induct, auto) \\n using merge_height", "action": "by simp", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    mset_tree (fst (heapify n xs)) = mset (take n xs)", "extra context": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"", "action": "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "complete": false}, {"observation": "proof (prove)\ngoal (22 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>a.\n                   x =\n                   (\\<langle>\\<rangle>, a,\n                    \\<langle>\\<rangle>) \\<Longrightarrow>\n                   P;\n        \\<And>xa a.\n           x =\n           (\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, a,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>l1 x1 r1 a l2 x2 r2.\n           x =\n           (\\<langle>l1, x1, r1\\<rangle>, a,\n            \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>vc vd ve va vb b.\n           x =\n           (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>v va vc vd ve b.\n           x =\n           (\\<langle>v, va, \\<langle>vc, vd, ve\\<rangle>\\<rangle>, b,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>b v va vb.\n           x =\n           (\\<langle>\\<rangle>, b,\n            \\<langle>v, va, vb\\<rangle>) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a aa.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = 1\n 3. \\<And>a x aa.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = 2\n 4. \\<And>a l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       1 =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2 then 1\n           else if x1 \\<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1)\n                else 1 + t_sift_down_sumC (l2, aa, r2))\n 5. \\<And>a vc vd ve va vb b.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = undefined\n 6. \\<And>a v va vc vd ve b.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>v, va, \\<langle>vc, vd, ve\\<rangle>\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = undefined\n 7. \\<And>a b v va vb.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<rangle>, b,\n        \\<langle>v, va, vb\\<rangle>) \\<Longrightarrow>\n       1 = undefined\n 8. \\<And>x a xa aa.\n       (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       2 = 2\n 9. \\<And>x a l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       2 =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2 then 1\n           else if x1 \\<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1)\n                else 1 + t_sift_down_sumC (l2, aa, r2))\n 10. \\<And>x a vc vd ve va vb b.\n        (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a,\n         \\<langle>\\<rangle>) =\n        (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n         \\<langle>\\<rangle>) \\<Longrightarrow>\n        2 = undefined\nA total of 22 subgoals...", "extra context": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\" \\n by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "action": "by pat_completeness auto", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. All t_sift_down_dom", "extra context": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\" \\n by (cases \"heapify n xs\", drule(1) heapify_correct, simp) \\n by pat_completeness auto", "action": "by (relation \"measure (%(l,a,r). size l + size r)\") auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. height t \\<le> height (insert x t)", "extra context": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"", "action": "apply (induct t arbitrary: x; simp add: le_max_iff_disj)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 x.\n       \\<lbrakk>\\<And>x. height t1 \\<le> height (insert x t1);\n        \\<And>x. height t2 \\<le> height (insert x t2)\\<rbrakk>\n       \\<Longrightarrow> (x < x2 \\<longrightarrow>\n                          height t1 \\<le> height (insert x2 t2) \\<or>\n                          height t2 \\<le> height t1) \\<and>\n                         (\\<not> x < x2 \\<longrightarrow>\n                          height t1 \\<le> height (insert x t2) \\<or>\n                          height t2 \\<le> height t1)", "extra context": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\" \\n apply (induct t arbitrary: x; simp add: le_max_iff_disj)", "action": "apply (metis less_imp_le_nat less_le_trans not_le_imp_less)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\" \\n apply (induct t arbitrary: x; simp add: le_max_iff_disj) \\n apply (metis less_imp_le_nat less_le_trans not_le_imp_less)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    t_del_left t \\<le> 2 * height t", "extra context": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"", "action": "apply (induct rule: t_del_left.induct; clarsimp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb r.\n       (\\<And>a b xb y.\n           \\<lbrakk>(a, b) = del_left \\<langle>v, va, vb\\<rangle>;\n            (xb, y) = del_left \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle>\n                             \\<le> Suc (Suc\n   (2 * max (height v) (height vb)))) \\<Longrightarrow>\n       t_del_left \\<langle>v, va, vb\\<rangle>\n       \\<le> 2 * max (Suc (max (height v) (height vb))) (height r)", "extra context": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" \\n apply (induct rule: t_del_left.induct; clarsimp)", "action": "apply (atomize(full); clarsimp simp: prod_eq_iff)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb r.\n       t_del_left \\<langle>v, va, vb\\<rangle>\n       \\<le> Suc (Suc (2 * max (height v) (height vb))) \\<Longrightarrow>\n       t_del_left \\<langle>v, va, vb\\<rangle>\n       \\<le> 2 * max (Suc (max (height v) (height vb))) (height r)", "extra context": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" \\n apply (induct rule: t_del_left.induct; clarsimp) \\n apply (atomize(full); clarsimp simp: prod_eq_iff)", "action": "apply (simp add: nat_mult_max_right le_max_iff_disj)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" \\n apply (induct rule: t_del_left.induct; clarsimp) \\n apply (atomize(full); clarsimp simp: prod_eq_iff) \\n apply (simp add: nat_mult_max_right le_max_iff_disj)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t", "extra context": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"", "action": "apply (induct t rule: measure_induct[where f=size])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   mset (list_of_B y) = mset_tree y;\n        braun x\\<rbrakk>\n       \\<Longrightarrow> mset (list_of_B x) = mset_tree x", "extra context": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" \\n apply (induct t rule: measure_induct[where f=size])", "action": "apply (case_tac x; simp add: list_of_B_braun_simps)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x21 x22 x23.\n       \\<lbrakk>\\<forall>y.\n                   size y < Suc (size x21 + size x23) \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   mset (list_of_B y) = mset_tree y;\n        (size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and>\n        braun x21 \\<and> braun x23;\n        x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> mset\n                          (list_of_B\n                            (del_min \\<langle>x21, x22, x23\\<rangle>)) =\n                         mset_tree x21 + mset_tree x23", "extra context": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps)", "action": "apply (simp add: size_del_min braun_del_min mset_del_min)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) \\n apply (simp add: size_del_min braun_del_min mset_del_min)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_B (heap_of_B xs)) = mset xs", "extra context": "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\"", "action": "by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B)", "complete": false}, {"observation": "proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = \\<langle>\\<rangle> \\<Longrightarrow> P;\n        \\<And>l a r.\n           x = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<langle>\\<rangle> = \\<langle>\\<rangle> \\<Longrightarrow> 0 = 0\n 3. \\<And>l a r.\n       \\<langle>\\<rangle> = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n       0 =\n       1 + t_del_min \\<langle>l, a, r\\<rangle> +\n       t_list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>)\n 4. \\<And>l a r la aa ra.\n       \\<langle>l, a, r\\<rangle> =\n       \\<langle>la, aa, ra\\<rangle> \\<Longrightarrow>\n       1 + t_del_min \\<langle>l, a, r\\<rangle> +\n       t_list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) =\n       1 + t_del_min \\<langle>la, aa, ra\\<rangle> +\n       t_list_of_B_sumC (del_min \\<langle>la, aa, ra\\<rangle>)", "extra context": "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\" \\n by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B)", "action": "by pat_completeness auto", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; heapify n xs = (t, ys)\\<rbrakk>\n    \\<Longrightarrow> size t = n \\<and>\n                      heap t \\<and>\n                      braun t \\<and> mset_tree t = mset (take n xs)", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "action": "proof (induct n xs arbitrary: t ys rule: heapify.induct)", "complete": false}, {"observation": "proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct)", "action": "case (2 n x xs)", "complete": false}, {"observation": "proof (state)\nthis:\n  \\<lbrakk>Suc n div 2 \\<le> length xs;\n   heapify (Suc n div 2) xs = (?t, ?ys)\\<rbrakk>\n  \\<Longrightarrow> size ?t = Suc n div 2 \\<and>\n                    heap ?t \\<and>\n                    braun ?t \\<and>\n                    mset_tree ?t = mset (take (Suc n div 2) xs)\n  \\<lbrakk>?xa = heapify (Suc n div 2) xs; (?xb, ?y) = ?xa;\n   n div 2 \\<le> length ?y; heapify (n div 2) ?y = (?t, ?ys)\\<rbrakk>\n  \\<Longrightarrow> size ?t = n div 2 \\<and>\n                    heap ?t \\<and>\n                    braun ?t \\<and> mset_tree ?t = mset (take (n div 2) ?y)\n  Suc n \\<le> length (x # xs)\n  heapify (Suc n) (x # xs) = (t, ys)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs)", "action": "note len = \"2.prems\"(1)", "complete": false}, {"observation": "proof (state)\nthis:\n  Suc n \\<le> length (x # xs)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1)", "action": "obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1 ys1.\n        heapify (Suc n div 2) xs = (t1, ys1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"", "action": "by (simp add: prod_eq_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  heapify (Suc n div 2) xs = (t1, ys1)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff)", "action": "obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t2 ys2.\n        heapify (n div 2) ys1 = (t2, ys2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"", "action": "by (simp add: prod_eq_iff)", "complete": false}, {"observation": "proof (state)\nthis:\n  heapify (n div 2) ys1 = (t2, ys2)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff)", "action": "from len", "complete": false}, {"observation": "proof (chain)\npicking this:\n  Suc n \\<le> length (x # xs)", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len", "action": "have le1: \"Suc n div 2 \\<le> length xs\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  Suc n \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. Suc n div 2 \\<le> length xs", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\"", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  Suc n div 2 \\<le> length xs\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp", "action": "note ys1 = heapify_snd_tup[OF h1 le1]", "complete": false}, {"observation": "proof (state)\nthis:\n  ys1 = drop (Suc n div 2) xs\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1]", "action": "from len", "complete": false}, {"observation": "proof (chain)\npicking this:\n  Suc n \\<le> length (x # xs)", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len", "action": "have le2: \"n div 2 \\<le> length ys1\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  Suc n \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. n div 2 \\<le> length ys1", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\"", "action": "by (simp add: ys1)", "complete": false}, {"observation": "proof (state)\nthis:\n  n div 2 \\<le> length ys1\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1)", "action": "note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]", "complete": false}, {"observation": "proof (state)\nthis:\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]", "action": "hence braun: \"braun (Node t1 x t2)\"", "complete": false}, {"observation": "proof (prove)\nusing this:\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n\ngoal (1 subgoal):\n 1. braun \\<langle>t1, x, t2\\<rangle>", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\"", "action": "by (simp, linarith)", "complete": false}, {"observation": "proof (state)\nthis:\n  braun \\<langle>t1, x, t2\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith)", "action": "have eq:\n    \"n div 2 + Suc n div 2 = n\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. n div 2 + Suc n div 2 = n", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\"", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  n div 2 + Suc n div 2 = n\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp", "action": "have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n    mset (take n xs)", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"", "action": "apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n    mset (take (Suc n div 2) (take n xs)) +\n    mset (drop (Suc n div 2) (take n xs))", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append)", "action": "apply (simp add: take_drop min_absorb1 le1 eq ys1)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1)", "action": "done", "complete": false}, {"observation": "proof (state)\nthis:\n  mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n  mset (take n xs)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done", "action": "from \"2.prems\" app_hyps msets", "complete": false}, {"observation": "proof (chain)\npicking this:\n  Suc n \\<le> length (x # xs)\n  heapify (Suc n) (x # xs) = (t, ys)\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n  mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n  mset (take n xs)", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  Suc n \\<le> length (x # xs)\n  heapify (Suc n) (x # xs) = (t, ys)\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n  mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n  mset (take n xs)\n\ngoal (1 subgoal):\n 1. size t = Suc n \\<and>\n    heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs))", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case", "action": "apply (clarsimp simp: h1 h2 le2)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs;\n     mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n     mset (take n xs);\n     ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2;\n     size t2 = n div 2; heap t1; heap t2; braun t1;\n     mset_tree t1 = mset (take (Suc n div 2) xs); braun t2;\n     mset_tree t2 = mset (take (n div 2) ys1)\\<rbrakk>\n    \\<Longrightarrow> size (sift_down t1 x t2) = Suc n \\<and>\n                      heap (sift_down t1 x t2) \\<and>\n                      braun (sift_down t1 x t2) \\<and>\n                      mset_tree (sift_down t1 x t2) =\n                      add_mset x (mset (take n xs))", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2)", "action": "apply (clarsimp simp: size_sift_down[OF braun]\n                       braun_sift_down[OF braun]\n                       mset_sift_down[OF braun])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs;\n     mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n     mset (take n xs);\n     ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2;\n     size t2 = n div 2; heap t1; heap t2; braun t1;\n     mset_tree t1 = mset (take (Suc n div 2) xs); braun t2;\n     mset_tree t2 = mset (take (n div 2) ys1)\\<rbrakk>\n    \\<Longrightarrow> Suc n div 2 + n div 2 = n \\<and>\n                      heap (sift_down t1 x t2)", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) \\n apply (clarsimp simp: size_sift_down[OF braun]\n                       braun_sift_down[OF braun]\n                       mset_sift_down[OF braun])", "action": "apply (simp add: heap_sift_down[OF braun])", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) \\n apply (clarsimp simp: size_sift_down[OF braun]\n                       braun_sift_down[OF braun]\n                       mset_sift_down[OF braun]) \\n apply (simp add: heap_sift_down[OF braun])", "action": "done", "complete": false}, {"observation": "proof (state)\nthis:\n  size t = Suc n \\<and>\n  heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "extra context": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq:\n    \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) \\n apply (clarsimp simp: size_sift_down[OF braun]\n                       braun_sift_down[OF braun]\n                       mset_sift_down[OF braun]) \\n apply (simp add: heap_sift_down[OF braun]) \\n done", "action": "qed simp_all", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_measure f; is_measure g\\<rbrakk>\n    \\<Longrightarrow> is_measure (size_prod f g)", "extra context": "lemma size_prod_measure[measure_function]:\n  \"is_measure f \\<Longrightarrow> is_measure g \\<Longrightarrow> is_measure (size_prod f g)\"", "action": "by (rule is_measure_trivial)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> list_of_B_dom t", "extra context": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"", "action": "apply (induct t rule: measure_induct[where f=size])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> list_of_B_dom y;\n        braun x\\<rbrakk>\n       \\<Longrightarrow> list_of_B_dom x", "extra context": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size])", "action": "apply (rule accpI, erule list_of_B_rel.cases)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y l a r.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> list_of_B_dom y;\n        braun x; y = del_min \\<langle>l, a, r\\<rangle>;\n        x = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> list_of_B_dom y", "extra context": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule list_of_B_rel.cases)", "action": "apply (clarsimp simp: size_del_min braun_del_min)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule list_of_B_rel.cases) \\n apply (clarsimp simp: size_del_min braun_del_min)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> t_list_of_B_dom t", "extra context": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"", "action": "apply (induct t rule: measure_induct[where f=size])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> t_list_of_B_dom y;\n        braun x\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B_dom x", "extra context": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size])", "action": "apply (rule accpI, erule t_list_of_B_rel.cases)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y l a r.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> t_list_of_B_dom y;\n        braun x; y = del_min \\<langle>l, a, r\\<rangle>;\n        x = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B_dom y", "extra context": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule t_list_of_B_rel.cases)", "action": "apply (clarsimp simp: size_del_min braun_del_min)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule t_list_of_B_rel.cases) \\n apply (clarsimp simp: size_del_min braun_del_min)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun t; heap t\\<rbrakk> \\<Longrightarrow> sorted (list_of_B t)", "extra context": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "action": "apply (induct t rule: measure_induct[where f=size])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   heap y \\<longrightarrow> sorted (list_of_B y);\n        braun x; heap x\\<rbrakk>\n       \\<Longrightarrow> sorted (list_of_B x)", "extra context": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size])", "action": "apply (case_tac x; simp add: list_of_B_braun_simps)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x21 x22 x23.\n       \\<lbrakk>\\<forall>y.\n                   size y < Suc (size x21 + size x23) \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   heap y \\<longrightarrow> sorted (list_of_B y);\n        (size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and>\n        braun x21 \\<and> braun x23;\n        (\\<forall>x\\<in>set_tree x21 \\<union> set_tree x23.\n            x22 \\<le> x) \\<and>\n        heap x21 \\<and> heap x23;\n        x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set\n    (list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>)).\n                             x22 \\<le> x) \\<and>\n                         sorted\n                          (list_of_B\n                            (del_min \\<langle>x21, x22, x23\\<rangle>))", "extra context": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps)", "action": "apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 xa.\n       \\<lbrakk>\\<forall>y.\n                   size y < Suc (size x21 + size x23) \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   heap y \\<longrightarrow> sorted (list_of_B y);\n        xa \\<in> set_tree (del_min \\<langle>x21, x22, x23\\<rangle>);\n        size x21 = size x23 \\<or> size x21 = Suc (size x23);\n        \\<forall>x\\<in>set_tree x21 \\<union> set_tree x23. x22 \\<le> x;\n        braun x21; braun x23; heap x21; heap x23\\<rbrakk>\n       \\<Longrightarrow> x22 \\<le> xa", "extra context": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) \\n apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)", "action": "apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) \\n apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min) \\n apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree)", "action": "done", "complete": true}]
[]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))", "extra context": "lemma heap_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))\"", "action": "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (heap_of_A xs) = mset xs", "extra context": "lemma mset_tree_heap_of_A: \"mset_tree (heap_of_A xs) = mset xs\"", "action": "by(induction xs)(simp_all add: mset_insert)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    height (sift_down l x r) \\<le> height \\<langle>l, x, r\\<rangle>", "extra context": "lemma sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> height (sift_down l x r) \\<le> height (Node l x r)\"", "action": "by (induct l x r rule: sift_down.induct; auto simp: Let_def)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. heap t \\<Longrightarrow> sorted (list_of_A t)", "extra context": "lemma sorted_list_of_A:\n  \"heap t \\<Longrightarrow> sorted (list_of_A t)\"", "action": "by (induct t rule: list_of_A.induct; simp add: merge_heap)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (merge l r) = mset_tree l + mset_tree r", "extra context": "lemma mset_tree_merge[simp]:\n  \"mset_tree (merge l r) = mset_tree l + mset_tree r\"", "action": "by (induct l r rule: merge.induct; simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. size (heap_of_A xs) = length xs", "extra context": "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\"", "action": "using arg_cong[OF mset_tree_heap_of_A, of size xs]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  size (mset_tree (heap_of_A xs)) = size (mset xs)\n\ngoal (1 subgoal):\n 1. size (heap_of_A xs) = length xs", "extra context": "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\" \\n using arg_cong[OF mset_tree_heap_of_A, of size xs]", "action": "by simp", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    height r \\<le> height l", "extra context": "lemma braun_height_r_le:\n  \"braun (Node l x r) \\<Longrightarrow> height r \\<le> height l\"", "action": "by (rule acomplete_optimal, auto intro: acomplete_if_braun)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> set (list_of_B t) = set_tree t", "extra context": "lemma set_list_of_B:\n  \"braun t \\<Longrightarrow> set (list_of_B t) = set_tree t\"", "action": "by (simp only: set_mset_mset[symmetric] mset_list_of_B, simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1", "extra context": "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\"", "action": "using t_heapify_induct[of i xs]", "complete": false}, {"observation": "proof (prove)\nusing this:\n  i \\<le> length xs \\<Longrightarrow>\n  t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\n\ngoal (1 subgoal):\n 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1", "extra context": "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\" \\n using t_heapify_induct[of i xs]", "action": "by simp", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. size (merge l r) = size l + size r", "extra context": "lemma merge_size[termination_simp]:\n  \"size (merge l r) = size l + size r\"", "action": "by (induct rule: merge.induct; simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "action": "proof (induct xs)", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs)", "action": "case (Cons x xs)", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs)", "action": "let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"", "complete": false}, {"observation": "proof (state)\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"", "action": "have \"?lhs \\<le> ?lhs\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_insert x (heap_of_A xs) + t_heap_of_A xs\n    \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\"", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  t_insert x (heap_of_A xs) + t_heap_of_A xs\n  \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  t_insert x (heap_of_A xs) + t_heap_of_A xs\n  \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also", "action": "note Cons", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also", "action": "note height_insert_ge[of \"heap_of_A xs\" x]", "complete": false}, {"observation": "proof (state)\nthis:\n  height (heap_of_A xs) \\<le> height (insert x (heap_of_A xs))\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x]", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  height (heap_of_A xs) \\<le> height (insert x (heap_of_A xs))\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also", "action": "note t_insert_height[of x \"heap_of_A xs\"]", "complete": false}, {"observation": "proof (state)\nthis:\n  t_insert x (heap_of_A xs) \\<le> height (heap_of_A xs) + 1\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"]", "action": "finally", "complete": false}, {"observation": "proof (chain)\npicking this:\n  \\<lbrakk>\\<And>xa y.\n              xa \\<le> y \\<Longrightarrow>\n              t_insert x (heap_of_A xs) + xa\n              \\<le> t_insert x (heap_of_A xs) + y;\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      t_insert x (heap_of_A xs) + length xs * (xa + 1)\n      \\<le> t_insert x (heap_of_A xs) + length xs * (y + 1);\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + length xs * (height (insert x (heap_of_A xs)) + 1)\n      \\<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\\<rbrakk>\n  \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs\n                    \\<le> height (heap_of_A xs) + 1 +\n                          length xs * (height (insert x (heap_of_A xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally", "action": "show ?case", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xa y.\n              xa \\<le> y \\<Longrightarrow>\n              t_insert x (heap_of_A xs) + xa\n              \\<le> t_insert x (heap_of_A xs) + y;\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      t_insert x (heap_of_A xs) + length xs * (xa + 1)\n      \\<le> t_insert x (heap_of_A xs) + length xs * (y + 1);\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + length xs * (height (insert x (heap_of_A xs)) + 1)\n      \\<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\\<rbrakk>\n  \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs\n                    \\<le> height (heap_of_A xs) + 1 +\n                          length xs * (height (insert x (heap_of_A xs)) + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A (x # xs)\n    \\<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_insert x (heap_of_A xs) + t_heap_of_A xs\n    \\<le> Suc (height (heap_of_A xs) +\n               (length xs +\n                length xs *\n                height (insert x (heap_of_A xs)))) \\<Longrightarrow>\n    t_insert x (heap_of_A xs) + t_heap_of_A xs\n    \\<le> Suc (length xs +\n               (height (insert x (heap_of_A xs)) +\n                length xs * height (insert x (heap_of_A xs))))", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp", "action": "apply (erule order_trans)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. Suc (height (heap_of_A xs) +\n         (length xs + length xs * height (insert x (heap_of_A xs))))\n    \\<le> Suc (length xs +\n               (height (insert x (heap_of_A xs)) +\n                length xs * height (insert x (heap_of_A xs))))", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp \\n apply (erule order_trans)", "action": "apply (simp add: height_insert_ge)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp \\n apply (erule order_trans) \\n apply (simp add: height_insert_ge)", "action": "done", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_A (x # xs)\n  \\<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)", "extra context": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp \\n apply (erule order_trans) \\n apply (simp add: height_insert_ge) \\n done", "action": "qed simp_all", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "action": "apply (induct rule: t_list_of_A.induct)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. height \\<langle>\\<rangle> \\<le> n \\<Longrightarrow>\n    t_list_of_A \\<langle>\\<rangle> \\<le> 2 * n * size \\<langle>\\<rangle>\n 2. \\<And>l a r.\n       \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow>\n                t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r);\n        height \\<langle>l, a, r\\<rangle> \\<le> n\\<rbrakk>\n       \\<Longrightarrow> t_list_of_A \\<langle>l, a, r\\<rangle>\n                         \\<le> 2 * n * size \\<langle>l, a, r\\<rangle>", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct)", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a r.\n       \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow>\n                t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r);\n        height \\<langle>l, a, r\\<rangle> \\<le> n\\<rbrakk>\n       \\<Longrightarrow> t_list_of_A \\<langle>l, a, r\\<rangle>\n                         \\<le> 2 * n * size \\<langle>l, a, r\\<rangle>", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow>\n                t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r);\n        Suc (max (height l) (height r)) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp", "action": "apply (drule meta_mp)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l r.\n       Suc (max (height l) (height r)) \\<le> n \\<Longrightarrow>\n       height (merge l r) \\<le> n\n 2. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp)", "action": "apply (rule order_trans, rule merge_height)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l r.\n       Suc (max (height l) (height r)) \\<le> n \\<Longrightarrow>\n       Suc (max (height l) (height r)) \\<le> n\n 2. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height)", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp", "action": "apply (simp add: merge_size)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * (size l + size r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp \\n apply (simp add: merge_size)", "action": "apply (cut_tac l=l and r=r in t_merge_height)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * (size l + size r);\n        t_merge l r \\<le> max (height l) (height r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp \\n apply (simp add: merge_size) \\n apply (cut_tac l=l and r=r in t_merge_height)", "action": "apply linarith", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp \\n apply (simp add: merge_size) \\n apply (cut_tac l=l and r=r in t_merge_height) \\n apply linarith", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun t; height t \\<le> n\\<rbrakk>\n    \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "action": "apply (induct t rule: measure_induct[where f=size])", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   height y \\<le> n \\<longrightarrow>\n                   t_list_of_B y \\<le> 3 * (n + 1) * size y;\n        braun x; height x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size])", "action": "apply (drule_tac x=\"del_min x\" in spec)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>braun x; height x \\<le> n;\n        size (del_min x) < size x \\<longrightarrow>\n        braun (del_min x) \\<longrightarrow>\n        height (del_min x) \\<le> n \\<longrightarrow>\n        t_list_of_B (del_min x)\n        \\<le> 3 * (n + 1) * size (del_min x)\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec)", "action": "apply (frule del_min_height)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>braun x; height x \\<le> n;\n        size (del_min x) < size x \\<longrightarrow>\n        braun (del_min x) \\<longrightarrow>\n        height (del_min x) \\<le> n \\<longrightarrow>\n        t_list_of_B (del_min x) \\<le> 3 * (n + 1) * size (del_min x);\n        height (del_min x) \\<le> height x\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height)", "action": "apply (case_tac x; simp add: t_list_of_B_braun_simps)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x21 x22 x23.\n       \\<lbrakk>(size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and>\n                braun x21 \\<and> braun x23;\n        Suc (max (height x21) (height x23)) \\<le> n;\n        size (del_min \\<langle>x21, x22, x23\\<rangle>)\n        < Suc (size x21 + size x23) \\<longrightarrow>\n        braun (del_min \\<langle>x21, x22, x23\\<rangle>) \\<longrightarrow>\n        t_list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>)\n        \\<le> (3 + 3 * n) * size (del_min \\<langle>x21, x22, x23\\<rangle>);\n        height (del_min \\<langle>x21, x22, x23\\<rangle>)\n        \\<le> Suc (max (height x21) (height x23));\n        x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>x21, x22, x23\\<rangle> +\n                         t_list_of_B\n                          (del_min \\<langle>x21, x22, x23\\<rangle>)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size x21 + size x23)))", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps)", "action": "apply (rename_tac l x' r)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l x' r.\n       \\<lbrakk>(size l = size r \\<or> size l = Suc (size r)) \\<and>\n                braun l \\<and> braun r;\n        Suc (max (height l) (height r)) \\<le> n;\n        size (del_min \\<langle>l, x', r\\<rangle>)\n        < Suc (size l + size r) \\<longrightarrow>\n        braun (del_min \\<langle>l, x', r\\<rangle>) \\<longrightarrow>\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * size (del_min \\<langle>l, x', r\\<rangle>);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        x = \\<langle>l, x', r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> +\n                         t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r)", "action": "apply (clarsimp simp: braun_del_min size_del_min)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> +\n                         t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min)", "action": "apply (rule order_trans)", "complete": false}, {"observation": "proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> +\n                         t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n                         \\<le> ?y21 l x' r\n 2. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> ?y21 l x' r\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) \\n apply (rule order_trans)", "action": "apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> 3 * height \\<langle>l, x', r\\<rangle> +\n                         (3 + 3 * n) * (size l + size r)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1] \\n apply simp", "action": "done", "complete": true}]
[]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_insert x t \\<le> height t + 1", "extra context": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"", "action": "apply (induct t arbitrary: x; simp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 x.\n       \\<lbrakk>\\<And>x. t_insert x t1 \\<le> Suc (height t1);\n        \\<And>x. t_insert x t2 \\<le> Suc (height t2)\\<rbrakk>\n       \\<Longrightarrow> (x < x2 \\<longrightarrow>\n                          t_insert x2 t2\n                          \\<le> Suc (max (height t1) (height t2))) \\<and>\n                         (\\<not> x < x2 \\<longrightarrow>\n                          t_insert x t2\n                          \\<le> Suc (max (height t1) (height t2)))", "extra context": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\" \\n apply (induct t arbitrary: x; simp)", "action": "apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\" \\n apply (induct t arbitrary: x; simp) \\n apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp)", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>", "extra context": "lemma t_sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> t_sift_down l x r \\<le> height (Node l x r)\"", "action": "by (induct l x r rule: t_sift_down.induct; auto)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (v, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> height t' \\<le> height t", "extra context": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"", "action": "apply (induct t arbitrary: v t' rule: del_left.induct; simp)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r vc t'.\n       \\<lbrakk>\\<And>vaa t'.\n                   del_left \\<langle>v, va, vb\\<rangle> =\n                   (vaa, t') \\<Longrightarrow>\n                   height t' \\<le> Suc (max (height v) (height vb));\n        (case del_left \\<langle>v, va, vb\\<rangle> of\n         (y, l') \\<Rightarrow> (y, \\<langle>r, x, l'\\<rangle>)) =\n        (vc, t')\\<rbrakk>\n       \\<Longrightarrow> height t'\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "extra context": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" \\n apply (induct t arbitrary: v t' rule: del_left.induct; simp)", "action": "apply (atomize(full), clarsimp split: prod.splits)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb r x1 x2.\n       \\<lbrakk>height x2 \\<le> Suc (max (height v) (height vb));\n        del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> height x2\n                         \\<le> max (Suc (max (height v) (height vb)))\n                                (height r)", "extra context": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" \\n apply (induct t arbitrary: v t' rule: del_left.induct; simp) \\n apply (atomize(full), clarsimp split: prod.splits)", "action": "apply simp", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" \\n apply (induct t arbitrary: v t' rule: del_left.induct; simp) \\n apply (atomize(full), clarsimp split: prod.splits) \\n apply simp", "action": "done", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "action": "proof -", "complete": false}, {"observation": "proof (state)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof -", "action": "have \"?lhs \\<le> ?lhs\"", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\"", "action": "by simp", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n  \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n  \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also", "action": "note t_heap_of_B_bound[of xs]", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_B xs \\<le> 6 * length xs + 1\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs]", "action": "also", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_B xs \\<le> 6 * length xs + 1\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also", "action": "note t_list_of_B_log_bound[of \"heap_of_B xs\"]", "complete": false}, {"observation": "proof (state)\nthis:\n  braun (heap_of_B xs) \\<Longrightarrow>\n  t_list_of_B (heap_of_B xs)\n  \\<le> 3 *\n        (nat \\<lceil>log 2 (real (size (heap_of_B xs) + 1))\\<rceil> + 1) *\n        size (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"]", "action": "finally", "complete": false}, {"observation": "proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_B (heap_of_B xs)\n              \\<le> y + t_list_of_B (heap_of_B xs);\n   braun (heap_of_B xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      6 * length xs + 1 + x \\<le> 6 * length xs + 1 + y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n                    \\<le> 6 * length xs + 1 +\n                          3 *\n                          (nat \\<lceil>log 2\n  (real (size (heap_of_B xs) + 1))\\<rceil> +\n                           1) *\n                          size (heap_of_B xs)", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally", "action": "show ?thesis", "complete": false}, {"observation": "proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_B (heap_of_B xs)\n              \\<le> y + t_list_of_B (heap_of_B xs);\n   braun (heap_of_B xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      6 * length xs + 1 + x \\<le> 6 * length xs + 1 + y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n                    \\<le> 6 * length xs + 1 +\n                          3 *\n                          (nat \\<lceil>log 2\n  (real (size (heap_of_B xs) + 1))\\<rceil> +\n                           1) *\n                          size (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis", "action": "apply (simp add: size_heapify braun_heapify heap_of_B_def)", "complete": false}, {"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs))\n    \\<le> Suc (6 * length xs +\n               (3 + 3 * nat \\<lceil>log 2 (1 + real (length xs))\\<rceil>) *\n               length xs) \\<Longrightarrow>\n    t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs))\n    \\<le> Suc (3 * length xs *\n               (nat \\<lceil>log 2 (1 + real (length xs))\\<rceil> + 3))", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis \\n apply (simp add: size_heapify braun_heapify heap_of_B_def)", "action": "apply (simp add: field_simps)", "complete": false}, {"observation": "proof (prove)\ngoal:\nNo subgoals!", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis \\n apply (simp add: size_heapify braun_heapify heap_of_B_def) \\n apply (simp add: field_simps)", "action": "done", "complete": false}, {"observation": "proof (state)\nthis:\n  t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n  \\<le> 3 * length xs *\n        (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n        1\n\ngoal:\nNo subgoals!", "extra context": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis \\n apply (simp add: size_heapify braun_heapify heap_of_B_def) \\n apply (simp add: field_simps) \\n done", "action": "qed", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. set (list_of_A t) = set_tree t", "extra context": "lemma set_list_of_A[simp]:\n  \"set (list_of_A t) = set_tree t\"", "action": "by (induct t rule: list_of_A.induct; simp)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_A (heap_of_A xs)) = mset xs", "extra context": "lemma msetA: \"mset (list_of_A (heap_of_A xs)) = mset xs\"", "action": "by (simp add: mset_tree_heap_of_A)", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs \\<le> 6 * length xs + 1", "extra context": "lemma t_heap_of_B_bound:\n  \"t_heap_of_B xs \\<le> 6 * length xs + 1\"", "action": "by (simp add: t_heap_of_B_def order_trans[OF t_heapify_bound])", "complete": true}]
[{"observation": "proof (prove)\ngoal (1 subgoal):\n 1. braun (heap_of_A xs)", "extra context": "lemma braun_heap_of_A: \"braun (heap_of_A xs)\"", "action": "by(induction xs)(simp_all add: braun_insert)", "complete": true}]
