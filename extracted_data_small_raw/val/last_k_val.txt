<ISA_LAST_1> by(subst size_sift_down) (auto dest: del_left_size del_left_braun) <ISA_OBS> proof (state) this: size (sift_down r y l') = size t - 1 goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge } <|endoftext|> <ISA_LAST_1> hence "size(sift_down r y l') = size t - 1" <ISA_OBS> proof (prove) using this: del_left \<langle>ll, b, lr\<rangle> = (y, l') goal (1 subgoal): 1. size (sift_down r y l') = size t - 1 Cambridge using assms <|endoftext|> <ISA_LAST_1> lemma nexts_set: "y \<in> set (nexts g x) = ((x,y) \<in> set g)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (y \<in> set (nexts g x)) = ((x, y) \<in> set g) Cambridge by (induct g) auto <|endoftext|> <ISA_LAST_1> apply (frule t_list_of_B_bound) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>braun t; t_list_of_B t \<le> 3 * (height t + 1) * size t\<rbrakk> \<Longrightarrow> t_list_of_B t \<le> 3 * (nat \<lceil>log 2 (real (size t + 1))\<rceil> + 1) * size t Cambridge apply (simp add: height_acomplete acomplete_if_braun size1_size) <|endoftext|> <ISA_LAST_1> lemma del_left_mset: "del_left t = (x,t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> x \<in># mset_tree t \<and> mset_tree t' = mset_tree t - {#x#}" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> x \<in># mset_tree t \<and> mset_tree t' = mset_tree t - {#x#} Cambridge by (simp add: del_left_mset_plus) <|endoftext|> <ISA_LAST_1> lemma t_list_of_B_log_bound: "braun t \<Longrightarrow> t_list_of_B t \<le> 3 * (nlog2 (size t + 1) + 1) * size t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> t_list_of_B t \<le> 3 * (nat \<lceil>log 2 (real (size t + 1))\<rceil> + 1) * size t Cambridge apply (frule t_list_of_B_bound) <|endoftext|> <ISA_LAST_1> using assms <ISA_OBS> proof (prove) using this: del_left \<langle>ll, b, lr\<rangle> = (y, l') braun t goal (1 subgoal): 1. size (sift_down r y l') = size t - 1 Cambridge by(subst size_sift_down) (auto dest: del_left_size del_left_braun) <|endoftext|> <ISA_LAST_1> lemma size_del_min: assumes "braun t" shows "size(del_min t) = size t - 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (del_min t) = size t - 1 Cambridge proof(cases t rule: del_min.cases) <|endoftext|> <ISA_LAST_1> case [simp]: (3 ll b lr a r) <ISA_OBS> proof (state) this: t = \<langle>\<langle>ll, b, lr\<rangle>, a, r\<rangle> goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge { <|endoftext|> <ISA_LAST_1> apply (simp add: height_acomplete acomplete_if_braun size1_size) <ISA_OBS> proof (prove) goal: No subgoals! Cambridge done <|endoftext|> <ISA_LAST_1> by(auto split: prod.split) <ISA_OBS> proof (state) this: size (del_min t) = size t - 1 goal (2 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge qed (insert assms, auto) <|endoftext|> <ISA_LAST_1> { <ISA_OBS> proof (state) this: t = \<langle>\<langle>ll, b, lr\<rangle>, a, r\<rangle> goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge fix y l' <|endoftext|> <ISA_LAST_1> fix y l' <ISA_OBS> proof (state) goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge assume "del_left (Node ll b lr) = (y,l')" <|endoftext|> <ISA_LAST_1> assume "del_left (Node ll b lr) = (y,l')" <ISA_OBS> proof (state) this: del_left \<langle>ll, b, lr\<rangle> = (y, l') goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge hence "size(sift_down r y l') = size t - 1" <|endoftext|> <ISA_LAST_1> proof(cases t rule: del_min.cases) <ISA_OBS> proof (state) goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge case [simp]: (3 ll b lr a r) <|endoftext|> <ISA_LAST_1> lemma "dfs2 g xs ys = dfs g xs ys" <ISA_OBS> proof (prove) goal (1 subgoal): 1. dfs2 g xs ys = dfs g xs ys Cambridge by (induct g xs ys rule: dfs2.induct) (auto simp add: dfs_app) <|endoftext|> <ISA_LAST_1> thus ?thesis <ISA_OBS> proof (prove) using this: del_left \<langle>ll, b, lr\<rangle> = (?y2, ?l'2) \<Longrightarrow> size (sift_down r ?y2 ?l'2) = size t - 1 goal (1 subgoal): 1. size (del_min t) = size t - 1 Cambridge by(auto split: prod.split) <|endoftext|> <ISA_LAST_1> } <ISA_OBS> proof (state) this: del_left \<langle>ll, b, lr\<rangle> = (?y2, ?l'2) \<Longrightarrow> size (sift_down r ?y2 ?l'2) = size t - 1 goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> size (del_min t) = size t - 1 Cambridge thus ?thesis <|endoftext|> 