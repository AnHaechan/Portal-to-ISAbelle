{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. r\\<^sup>* `` X = X", "y": "proof", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof <ISA_OBS> proof (state) goal (2 subgoals): 1. r\\<^sup>* `` X \\<subseteq> X 2. X \\<subseteq> r\\<^sup>* `` X", "y": "show \"r\\<^sup>* `` X \\<subseteq> X\"", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "proof -", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "{", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { <ISA_OBS> proof (state) goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "fix x y", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y <ISA_OBS> proof (state) goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "assume y: \"y \\<in> X\"", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" <ISA_OBS> proof (state) this: y \\<in> X goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "assume \"(y,x) \\<in> r\\<^sup>*\"", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" <ISA_OBS> proof (state) this: (y, x) \\<in> r\\<^sup>* goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "then", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then <ISA_OBS> proof (chain) picking this: (y, x) \\<in> r\\<^sup>*", "y": "have \"x \\<in> X\"", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" <ISA_OBS> proof (prove) using this: (y, x) \\<in> r\\<^sup>* goal (1 subgoal): 1. x \\<in> X", "y": "by (induct) (insert assms y, auto simp add: Image_def)", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) <ISA_OBS> proof (state) this: x \\<in> X goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "}", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } <ISA_OBS> proof (state) this: \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk> \\<Longrightarrow> ?x2 \\<in> X goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "then", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)<SEP>}"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then <ISA_OBS> proof (chain) picking this: \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk> \\<Longrightarrow> ?x2 \\<in> X", "y": "show ?thesis", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)<SEP>}<SEP>then"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis <ISA_OBS> proof (prove) using this: \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk> \\<Longrightarrow> ?x2 \\<in> X goal (1 subgoal): 1. r\\<^sup>* `` X \\<subseteq> X", "y": "unfolding Image_def", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)<SEP>}<SEP>then<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis \\n unfolding Image_def <ISA_OBS> proof (prove) using this: \\<lbrakk>?y2 \\<in> X; (?y2, ?x2) \\<in> r\\<^sup>*\\<rbrakk> \\<Longrightarrow> ?x2 \\<in> X goal (1 subgoal): 1. {y. \\<exists>x\\<in>X. (x, y) \\<in> r\\<^sup>*} \\<subseteq> X", "y": "by auto", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)<SEP>}<SEP>then<SEP>show ?thesis<SEP>unfolding Image_def"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis \\n unfolding Image_def \\n by auto <ISA_OBS> proof (state) this: r\\<^sup>* `` X \\<subseteq> X goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)<SEP>}<SEP>then<SEP>show ?thesis<SEP>unfolding Image_def<SEP>by auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"", "x": "<ISA_PRF> lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\" \\n proof \\n show \"r\\<^sup>* `` X \\<subseteq> X\" \\n proof - \\n { \\n fix x y \\n assume y: \"y \\<in> X\" \\n assume \"(y,x) \\<in> r\\<^sup>*\" \\n then \\n have \"x \\<in> X\" \\n by (induct) (insert assms y, auto simp add: Image_def) \\n } \\n then \\n show ?thesis \\n unfolding Image_def \\n by auto \\n qed <ISA_OBS> proof (state) this: r\\<^sup>* `` X \\<subseteq> X goal (1 subgoal): 1. X \\<subseteq> r\\<^sup>* `` X", "y": "qed auto", "proof_script_until_now": "lemma Image_closed_trancl: assumes \"r `` X \\<subseteq> X\" shows \"r\\<^sup>* `` X = X\"<SEP>proof<SEP>show \"r\\<^sup>* `` X \\<subseteq> X\"<SEP>proof -<SEP>{<SEP>fix x y<SEP>assume y: \"y \\<in> X\"<SEP>assume \"(y,x) \\<in> r\\<^sup>*\"<SEP>then<SEP>have \"x \\<in> X\"<SEP>by (induct) (insert assms y, auto simp add: Image_def)<SEP>}<SEP>then<SEP>show ?thesis<SEP>unfolding Image_def<SEP>by auto<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. finite (nodes_of g - set ys)", "y": "proof(rule finite_subset)", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) <ISA_OBS> proof (state) goal (2 subgoals): 1. nodes_of g - set ys \\<subseteq> ?B 2. finite ?B", "y": "show \"finite (nodes_of g)\"", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. finite (nodes_of g)", "y": "by (auto simp add: nodes_of_def)", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) <ISA_OBS> proof (state) this: finite (nodes_of g) goal (1 subgoal): 1. nodes_of g - set ys \\<subseteq> nodes_of g", "y": "qed (auto)", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) <ISA_OBS> proof (prove) goal (4 subgoals): 1. \\<And>P x. \\<lbrakk>\\<And>g ys. x = (g, [], ys) \\<Longrightarrow> P; \\<And>g xa xs ys. x = (g, xa # xs, ys) \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P 2. \\<And>g ys ga ysa. (g, [], ys) = (ga, [], ysa) \\<Longrightarrow> ys = ysa 3. \\<And>g ys ga x xs ysa. (g, [], ys) = (ga, x # xs, ysa) \\<Longrightarrow> ys = (if List.member ysa x then dfs_sumC (ga, xs, ysa) else dfs_sumC (ga, nexts ga x @ xs, x # ysa)) 4. \\<And>g x xs ys ga xa xsa ysa. (g, x # xs, ys) = (ga, xa # xsa, ysa) \\<Longrightarrow> (if List.member ys x then dfs_sumC (g, xs, ys) else dfs_sumC (g, nexts g x @ xs, x # ys)) = (if List.member ysa xa then dfs_sumC (ga, xsa, ysa) else dfs_sumC (ga, nexts ga xa @ xsa, xa # ysa))", "y": "by pat_completeness auto", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)<SEP>qed (auto)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto <ISA_OBS> proof (prove) goal (1 subgoal): 1. All dfs_dom", "y": "apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)<SEP>qed (auto)<SEP>by pat_completeness auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") <ISA_OBS> proof (prove) goal (3 subgoals): 1. wf (inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))) 2. \\<And>g x xs ys. List.member ys x \\<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 3. \\<And>g x xs ys. \\<not> List.member ys x \\<Longrightarrow> ((g, nexts g x @ xs, x # ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "y": "apply auto[1]", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)<SEP>qed (auto)<SEP>by pat_completeness auto<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>g x xs ys. List.member ys x \\<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 2. \\<And>g x xs ys. \\<not> List.member ys x \\<Longrightarrow> ((g, nexts g x @ xs, x # ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "y": "apply (simp_all add: finite_psubset_def)", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)<SEP>qed (auto)<SEP>by pat_completeness auto<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>g x ys. \\<not> List.member ys x \\<Longrightarrow> nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and> nexts g x = []", "y": "by (case_tac \"x \\<in> nodes_of g\") (auto simp add: List.member_def)", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)<SEP>qed (auto)<SEP>by pat_completeness auto<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]<SEP>apply (simp_all add: finite_psubset_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"finite (nodes_of g - set ys)\"", "x": "<ISA_PRF> lemma [simp]: \"finite (nodes_of g - set ys)\" \\n proof(rule finite_subset) \\n show \"finite (nodes_of g)\" \\n by (auto simp add: nodes_of_def) \\n qed (auto) \\n by pat_completeness auto \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) \\n by (case_tac \"x \\<in> nodes_of g\") (auto simp add: List.member_def) <ISA_OBS> proof (prove) goal (4 subgoals): 1. \\<And>P x. \\<lbrakk>\\<And>g ys. x = (g, [], ys) \\<Longrightarrow> P; \\<And>g xa xs ys. x = (g, xa # xs, ys) \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P 2. \\<And>g ys ga ysa. (g, [], ys) = (ga, [], ysa) \\<Longrightarrow> ys = ysa 3. \\<And>g ys ga x xs ysa. (g, [], ys) = (ga, x # xs, ysa) \\<Longrightarrow> ys = (if List.member ysa x then dfs2_sumC (ga, xs, ysa) else dfs2_sumC (ga, xs, dfs2_sumC (ga, nexts ga x, x # ysa))) 4. \\<And>g x xs ys ga xa xsa ysa. (g, x # xs, ys) = (ga, xa # xsa, ysa) \\<Longrightarrow> (if List.member ys x then dfs2_sumC (g, xs, ys) else dfs2_sumC (g, xs, dfs2_sumC (g, nexts g x, x # ys))) = (if List.member ysa xa then dfs2_sumC (ga, xsa, ysa) else dfs2_sumC (ga, xsa, dfs2_sumC (ga, nexts ga xa, xa # ysa)))", "y": "by pat_completeness auto", "proof_script_until_now": "lemma [simp]: \"finite (nodes_of g - set ys)\"<SEP>proof(rule finite_subset)<SEP>show \"finite (nodes_of g)\"<SEP>by (auto simp add: nodes_of_def)<SEP>qed (auto)<SEP>by pat_completeness auto<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]<SEP>apply (simp_all add: finite_psubset_def)<SEP>by (case_tac \"x \\<in> nodes_of g\") (auto simp add: List.member_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma [simp]: \"x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []\"", "x": "<ISA_PRF> lemma [simp]: \"x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []", "y": "by (induct g) (auto simp add: nodes_of_def)", "proof_script_until_now": "lemma [simp]: \"x \\<notin> nodes_of g \\<Longrightarrow> nexts g x = []\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys", "y": "proof(induct g xs ys rule: dfs.induct)", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>g ys. set (dfs g [] ys) \\<subseteq> reachable g [] \\<union> set ys 2. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys; \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\\<rbrakk> \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "case 1", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 <ISA_OBS> proof (state) this: goal (2 subgoals): 1. \\<And>g ys. set (dfs g [] ys) \\<subseteq> reachable g [] \\<union> set ys 2. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys; \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\\<rbrakk> \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "then", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then <ISA_OBS> proof (chain) picking this:", "y": "show ?case", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g_ [] ys_) \\<subseteq> reachable g_ [] \\<union> set ys_", "y": "by simp", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp <ISA_OBS> proof (state) this: set (dfs g_ [] ys_) \\<subseteq> reachable g_ [] \\<union> set ys_ goal (1 subgoal): 1. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys; \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\\<rbrakk> \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "next", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys; \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\\<rbrakk> \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "case (2 g x xs ys)", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) <ISA_OBS> proof (state) this: List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys) goal (1 subgoal): 1. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys; \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys)\\<rbrakk> \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "show ?case", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "proof (cases \"x \\<in> set ys\")", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") <ISA_OBS> proof (state) goal (2 subgoals): 1. x \\<in> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys 2. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "case True", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True <ISA_OBS> proof (state) this: x \\<in> set ys goal (2 subgoals): 1. x \\<in> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys 2. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "with 2", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 <ISA_OBS> proof (chain) picking this: List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys) x \\<in> set ys", "y": "show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" <ISA_OBS> proof (prove) using this: List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys) x \\<in> set ys goal (1 subgoal): 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "by (auto simp add: reachable_def List.member_def)", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) <ISA_OBS> proof (state) this: set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "next", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "case False", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False <ISA_OBS> proof (state) this: x \\<notin> set ys goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (nexts g x) \\<subseteq> reachable g [x]", "y": "by (rule reachable_nexts)", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) <ISA_OBS> proof (state) this: reachable g (nexts g x) \\<subseteq> reachable g [x] goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" <ISA_OBS> proof (prove) using this: reachable g (nexts g x) \\<subseteq> reachable g [x] goal (1 subgoal): 1. reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)", "y": "by(simp add: reachable_append, auto simp add: reachable_def)", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)<SEP>hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) <ISA_OBS> proof (state) this: reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs) goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "with False 2", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)<SEP>hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"<SEP>by(simp add: reachable_append, auto simp add: reachable_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 <ISA_OBS> proof (chain) picking this: x \\<notin> set ys List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys) reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs)", "y": "show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)<SEP>hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"<SEP>by(simp add: reachable_append, auto simp add: reachable_def)<SEP>with False 2"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" <ISA_OBS> proof (prove) using this: x \\<notin> set ys List.member ys x \\<Longrightarrow> set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys \\<not> List.member ys x \\<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \\<subseteq> reachable g (nexts g x @ xs) \\<union> set (x # ys) reachable g (nexts g x @ xs) \\<subseteq> reachable g (x # xs) goal (1 subgoal): 1. set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys", "y": "by (auto simp add: reachable_def List.member_def)", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)<SEP>hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"<SEP>by(simp add: reachable_append, auto simp add: reachable_def)<SEP>with False 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) <ISA_OBS> proof (state) this: set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)<SEP>hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"<SEP>by(simp add: reachable_append, auto simp add: reachable_def)<SEP>with False 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"", "x": "<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\" \\n proof(induct g xs ys rule: dfs.induct) \\n case 1 \\n then \\n show ?case \\n by simp \\n next \\n case (2 g x xs ys) \\n show ?case \\n proof (cases \"x \\<in> set ys\") \\n case True \\n with 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n next \\n case False \\n have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n by (rule reachable_nexts) \\n hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\" \\n by(simp add: reachable_append, auto simp add: reachable_def) \\n with False 2 \\n show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\" \\n by (auto simp add: reachable_def List.member_def) \\n qed <ISA_OBS> proof (state) this: set (dfs g (x # xs) ys) \\<subseteq> reachable g (x # xs) \\<union> set ys goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma dfs_subset_reachable_visit_nodes: \"set (dfs g xs ys) \\<subseteq> reachable g xs \\<union> set ys\"<SEP>proof(induct g xs ys rule: dfs.induct)<SEP>case 1<SEP>then<SEP>show ?case<SEP>by simp<SEP>next<SEP>case (2 g x xs ys)<SEP>show ?case<SEP>proof (cases \"x \\<in> set ys\")<SEP>case True<SEP>with 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>next<SEP>case False<SEP>have \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>by (rule reachable_nexts)<SEP>hence a: \"reachable g (nexts g x @ xs) \\<subseteq> reachable g (x#xs)\"<SEP>by(simp add: reachable_append, auto simp add: reachable_def)<SEP>with False 2<SEP>show \"set (dfs g (x#xs) ys) \\<subseteq> reachable g (x#xs) \\<union> set ys\"<SEP>by (auto simp add: reachable_def List.member_def)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs_app: \"dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)\"", "x": "<ISA_PRF> lemma dfs_app: \"dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. dfs g (xs @ ys) zs = dfs g ys (dfs g xs zs)", "y": "by (induct g xs zs rule: dfs.induct) auto", "proof_script_until_now": "lemma dfs_app: \"dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\"", "x": "<ISA_PRF> lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. nextss g (x # xs) = set (nexts g x) \\<union> nextss g xs", "y": "unfolding nextss_def", "proof_script_until_now": "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\"", "x": "<ISA_PRF> lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\" \\n unfolding nextss_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. set g `` set (x # xs) = set (nexts g x) \\<union> set g `` set xs", "y": "by (auto simp add:Image_def nexts_set)", "proof_script_until_now": "lemma nextss_Cons: \"nextss g (x#xs) = set (nexts g x) \\<union> nextss g xs\"<SEP>unfolding nextss_def"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\"", "x": "<ISA_PRF> lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys", "y": "unfolding reachable_def", "proof_script_until_now": "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\"", "x": "<ISA_PRF> lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\" \\n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\\<^sup>* `` set (xs @ ys) = (set g)\\<^sup>* `` set xs \\<union> (set g)\\<^sup>* `` set ys", "y": "by auto", "proof_script_until_now": "lemma reachable_append: \"reachable g (xs @ ys) = reachable g xs \\<union> reachable g ys\"<SEP>unfolding reachable_def"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "x": "<ISA_PRF> lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (nexts g x) \\<subseteq> reachable g [x]", "y": "unfolding reachable_def", "proof_script_until_now": "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"", "x": "<ISA_PRF> lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\" \\n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\\<^sup>* `` set (nexts g x) \\<subseteq> (set g)\\<^sup>* `` set [x]", "y": "by (auto intro: converse_rtrancl_into_rtrancl simp: nexts_set)", "proof_script_until_now": "lemma reachable_nexts: \"reachable g (nexts g x) \\<subseteq> reachable g [x]\"<SEP>unfolding reachable_def"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma visit_subset_dfs: \"set ys \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma visit_subset_dfs: \"set ys \\<subseteq> set (dfs g xs ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set ys \\<subseteq> set (dfs g xs ys)", "y": "by (induct g xs ys rule: dfs.induct) auto", "proof_script_until_now": "lemma visit_subset_dfs: \"set ys \\<subseteq> set (dfs g xs ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\"", "x": "<ISA_PRF> theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (y \\<in> set (dfs g [x] [])) = ((x, y) \\<in> (set g)\\<^sup>*)", "y": "by(simp only:dfs_eq_reachable reachable_def, auto)", "proof_script_until_now": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\"", "x": "<ISA_PRF> theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\" \\n by(simp only:dfs_eq_reachable reachable_def, auto) <ISA_OBS> proof (prove) goal (1 subgoal): 1. OFCLASS(node, equal_class)", "y": "proof", "proof_script_until_now": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\"<SEP>by(simp only:dfs_eq_reachable reachable_def, auto)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\"", "x": "<ISA_PRF> theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\" \\n by(simp only:dfs_eq_reachable reachable_def, auto) \\n proof <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>x y. equal_class.equal x y = (x = y)", "y": "qed (simp add: equal_node_def)", "proof_script_until_now": "theorem \"y \\<in> set (dfs g [x] []) = ((x,y) \\<in> (set g)\\<^sup>*)\"<SEP>by(simp only:dfs_eq_reachable reachable_def, auto)<SEP>proof"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "proof -", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g xs \\<subseteq> reachable g (dfs g xs [])", "y": "unfolding reachable_def", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\\<^sup>* `` set xs \\<subseteq> (set g)\\<^sup>* `` set (dfs g xs [])", "y": "by (rule Image_mono) (auto simp add: next_subset_dfs)", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) <ISA_OBS> proof (state) this: reachable g xs \\<subseteq> reachable g (dfs g xs []) goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "also", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also <ISA_OBS> proof (state) this: reachable g xs \\<subseteq> reachable g (dfs g xs []) goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "have \"\\<dots> = set(dfs g xs [])\"", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (dfs g xs []) = set (dfs g xs [])", "y": "unfolding reachable_def", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\\<^sup>* `` set (dfs g xs []) = set (dfs g xs [])", "y": "proof (rule Image_closed_trancl)", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) <ISA_OBS> proof (state) goal (1 subgoal): 1. set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])", "y": "from nextss_closed_dfs", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs <ISA_OBS> proof (chain) picking this: nextss ?g (dfs ?g ?xs []) \\<subseteq> set (dfs ?g ?xs [])", "y": "show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" <ISA_OBS> proof (prove) using this: nextss ?g (dfs ?g ?xs []) \\<subseteq> set (dfs ?g ?xs []) goal (1 subgoal): 1. set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])", "y": "by (simp add: nextss_def)", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs<SEP>show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) <ISA_OBS> proof (state) this: set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs []) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs<SEP>show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"<SEP>by (simp add: nextss_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed <ISA_OBS> proof (state) this: reachable g (dfs g xs []) = set (dfs g xs []) goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "finally", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs<SEP>show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"<SEP>by (simp add: nextss_def)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed \\n finally <ISA_OBS> proof (chain) picking this: reachable g xs \\<subseteq> set (dfs g xs [])", "y": "show ?thesis", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs<SEP>show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"<SEP>by (simp add: nextss_def)<SEP>qed<SEP>finally"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed \\n finally \\n show ?thesis <ISA_OBS> proof (prove) using this: reachable g xs \\<subseteq> set (dfs g xs []) goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": ".", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs<SEP>show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"<SEP>by (simp add: nextss_def)<SEP>qed<SEP>finally<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"", "x": "<ISA_PRF> lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\" \\n proof - \\n have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\" \\n unfolding reachable_def \\n by (rule Image_mono) (auto simp add: next_subset_dfs) \\n also \\n have \"\\<dots> = set(dfs g xs [])\" \\n unfolding reachable_def \\n proof (rule Image_closed_trancl) \\n from nextss_closed_dfs \\n show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\" \\n by (simp add: nextss_def) \\n qed \\n finally \\n show ?thesis \\n . <ISA_OBS> proof (state) this: reachable g xs \\<subseteq> set (dfs g xs []) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma reachable_closed_dfs: \"reachable g xs \\<subseteq> set(dfs g xs [])\"<SEP>proof -<SEP>have \"reachable g xs \\<subseteq> reachable g (dfs g xs [])\"<SEP>unfolding reachable_def<SEP>by (rule Image_mono) (auto simp add: next_subset_dfs)<SEP>also<SEP>have \"\\<dots> = set(dfs g xs [])\"<SEP>unfolding reachable_def<SEP>proof (rule Image_closed_trancl)<SEP>from nextss_closed_dfs<SEP>show \"set g `` set (dfs g xs []) \\<subseteq> set (dfs g xs [])\"<SEP>by (simp add: nextss_def)<SEP>qed<SEP>finally<SEP>show ?thesis<SEP>."}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "x": "<ISA_PRF> theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g xs []) = reachable g xs", "y": "proof", "proof_script_until_now": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "x": "<ISA_PRF> theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof <ISA_OBS> proof (state) goal (2 subgoals): 1. set (dfs g xs []) \\<subseteq> reachable g xs 2. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\"", "proof_script_until_now": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"<SEP>proof"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "x": "<ISA_PRF> theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []", "y": "by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])", "proof_script_until_now": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"<SEP>proof<SEP>have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "x": "<ISA_PRF> theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" \\n by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"]) <ISA_OBS> proof (state) this: set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set [] goal (2 subgoals): 1. set (dfs g xs []) \\<subseteq> reachable g xs 2. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "thus \"set (dfs g xs []) \\<subseteq> reachable g xs\"", "proof_script_until_now": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"<SEP>proof<SEP>have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\"<SEP>by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "x": "<ISA_PRF> theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" \\n by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"]) \\n thus \"set (dfs g xs []) \\<subseteq> reachable g xs\" <ISA_OBS> proof (prove) using this: set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set [] goal (1 subgoal): 1. set (dfs g xs []) \\<subseteq> reachable g xs", "y": "by simp", "proof_script_until_now": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"<SEP>proof<SEP>have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\"<SEP>by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])<SEP>thus \"set (dfs g xs []) \\<subseteq> reachable g xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"", "x": "<ISA_PRF> theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\" \\n proof \\n have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\" \\n by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"]) \\n thus \"set (dfs g xs []) \\<subseteq> reachable g xs\" \\n by simp <ISA_OBS> proof (state) this: set (dfs g xs []) \\<subseteq> reachable g xs goal (1 subgoal): 1. reachable g xs \\<subseteq> set (dfs g xs [])", "y": "qed(rule reachable_closed_dfs)", "proof_script_until_now": "theorem dfs_eq_reachable: \"set (dfs g xs []) = reachable g xs\"<SEP>proof<SEP>have \"set (dfs g xs []) \\<subseteq> reachable g xs \\<union> set []\"<SEP>by (rule dfs_subset_reachable_visit_nodes[of g xs \"[]\"])<SEP>thus \"set (dfs g xs []) \\<subseteq> reachable g xs\"<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma nextss_closed_dfs: \"nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])\"", "x": "<ISA_PRF> lemma nextss_closed_dfs: \"nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])", "y": "by (rule nextss_closed_dfs', simp add: nextss_def)", "proof_script_until_now": "lemma nextss_closed_dfs: \"nextss g (dfs g xs []) \\<subseteq> set (dfs g xs [])\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma nextss_closed_dfs'[rule_format]: \n \"nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma nextss_closed_dfs'[rule_format]: \"nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)", "y": "by (induct g xs ys rule:dfs.induct, auto simp add:nextss_Cons List.member_def)", "proof_script_until_now": "lemma nextss_closed_dfs'[rule_format]: \n \"nextss g ys \\<subseteq> set xs \\<union> set ys \\<longrightarrow> nextss g (dfs g xs ys) \\<subseteq> set (dfs g xs ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)", "y": "by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ <ISA_OBS> proof (prove) goal (1 subgoal): 1. All dfs2_dom", "y": "apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"<SEP>by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") <ISA_OBS> proof (prove) goal (4 subgoals): 1. wf (inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))) 2. \\<And>g x xs ys. List.member ys x \\<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 3. \\<And>g x xs ys. \\<not> List.member ys x \\<Longrightarrow> ((g, nexts g x, x # ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 4. \\<And>g x xs ys. \\<lbrakk>\\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\\<rbrakk> \\<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "y": "apply auto[1]", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"<SEP>by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] <ISA_OBS> proof (prove) goal (3 subgoals): 1. \\<And>g x xs ys. List.member ys x \\<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 2. \\<And>g x xs ys. \\<not> List.member ys x \\<Longrightarrow> ((g, nexts g x, x # ys), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 3. \\<And>g x xs ys. \\<lbrakk>\\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\\<rbrakk> \\<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs, ys) \\<in> inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))", "y": "apply (simp_all add: finite_psubset_def)", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"<SEP>by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>g x xs ys. \\<not> List.member ys x \\<Longrightarrow> nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and> length (nexts g x) < Suc (length xs) 2. \\<And>g x ys. \\<lbrakk>\\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\\<rbrakk> \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) \\<subset> nodes_of g - set ys \\<or> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) = nodes_of g - set ys", "y": "apply (case_tac \"x \\<in> nodes_of g\")", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"<SEP>by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]<SEP>apply (simp_all add: finite_psubset_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) \\n apply (case_tac \"x \\<in> nodes_of g\") <ISA_OBS> proof (prove) goal (3 subgoals): 1. \\<And>g x xs ys. \\<lbrakk>\\<not> List.member ys x; x \\<in> nodes_of g\\<rbrakk> \\<Longrightarrow> nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and> length (nexts g x) < Suc (length xs) 2. \\<And>g x xs ys. \\<lbrakk>\\<not> List.member ys x; x \\<notin> nodes_of g\\<rbrakk> \\<Longrightarrow> nodes_of g - insert x (set ys) \\<subset> nodes_of g - set ys \\<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \\<and> length (nexts g x) < Suc (length xs) 3. \\<And>g x ys. \\<lbrakk>\\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\\<rbrakk> \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) \\<subset> nodes_of g - set ys \\<or> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) = nodes_of g - set ys", "y": "apply (auto simp add: List.member_def)[2]", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"<SEP>by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]<SEP>apply (simp_all add: finite_psubset_def)<SEP>apply (case_tac \"x \\<in> nodes_of g\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"", "x": "<ISA_PRF> lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\" \\n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \\n apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\") \\n apply auto[1] \\n apply (simp_all add: finite_psubset_def) \\n apply (case_tac \"x \\<in> nodes_of g\") \\n apply (auto simp add: List.member_def)[2] <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>g x ys. \\<lbrakk>\\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\\<rbrakk> \\<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) \\<subset> nodes_of g - set ys \\<or> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) = nodes_of g - set ys", "y": "by (insert dfs2_invariant) force", "proof_script_until_now": "lemma dfs2_invariant: \"dfs2_dom (g, xs, ys) \\<Longrightarrow> set ys \\<subseteq> set (dfs2 g xs ys)\"<SEP>by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+<SEP>apply (relation \"inv_image (finite_psubset <*lex*> less_than) (\\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))\")<SEP>apply auto[1]<SEP>apply (simp_all add: finite_psubset_def)<SEP>apply (case_tac \"x \\<in> nodes_of g\")<SEP>apply (auto simp add: List.member_def)[2]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set xs \\<subseteq> set (dfs g xs ys)", "y": "proof(induct g xs ys rule:dfs.induct)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys) 2. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys); \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\\<rbrakk> \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "case(2 g x xs ys)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) <ISA_OBS> proof (state) this: List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys) \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) goal (2 subgoals): 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys) 2. \\<And>g x xs ys. \\<lbrakk>List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys); \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\\<rbrakk> \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "show ?case", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "proof(cases \"x \\<in> set ys\")", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") <ISA_OBS> proof (state) goal (2 subgoals): 1. x \\<in> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys) 2. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "case True", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True <ISA_OBS> proof (state) this: x \\<in> set ys goal (2 subgoals): 1. x \\<in> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys) 2. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "have \"set ys \\<subseteq> set (dfs g xs ys)\"", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set ys \\<subseteq> set (dfs g xs ys)", "y": "by (rule visit_subset_dfs)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) <ISA_OBS> proof (state) this: set ys \\<subseteq> set (dfs g xs ys) goal (2 subgoals): 1. x \\<in> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys) 2. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "with 2 and True", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True <ISA_OBS> proof (chain) picking this: List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys) \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \\<in> set ys set ys \\<subseteq> set (dfs g xs ys)", "y": "show ?thesis", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis <ISA_OBS> proof (prove) using this: List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys) \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \\<in> set ys set ys \\<subseteq> set (dfs g xs ys) goal (1 subgoal): 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "by (auto simp add: List.member_def)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) <ISA_OBS> proof (state) this: set (x # xs) \\<subseteq> set (dfs g (x # xs) ys) goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "next", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "case False", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False <ISA_OBS> proof (state) this: x \\<notin> set ys goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))", "y": "by(rule visit_subset_dfs)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False<SEP>have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) <ISA_OBS> proof (state) this: set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) goal (1 subgoal): 1. x \\<notin> set ys \\<Longrightarrow> set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "with 2 and False", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False<SEP>have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"<SEP>by(rule visit_subset_dfs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False <ISA_OBS> proof (chain) picking this: List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys) \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \\<notin> set ys set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys))", "y": "show ?thesis", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False<SEP>have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"<SEP>by(rule visit_subset_dfs)<SEP>with 2 and False"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False \\n show ?thesis <ISA_OBS> proof (prove) using this: List.member ys x \\<Longrightarrow> set xs \\<subseteq> set (dfs g xs ys) \\<not> List.member ys x \\<Longrightarrow> set (nexts g x @ xs) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \\<notin> set ys set (x # ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) goal (1 subgoal): 1. set (x # xs) \\<subseteq> set (dfs g (x # xs) ys)", "y": "by (auto simp add: List.member_def)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False<SEP>have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"<SEP>by(rule visit_subset_dfs)<SEP>with 2 and False<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False \\n show ?thesis \\n by (auto simp add: List.member_def) <ISA_OBS> proof (state) this: set (x # xs) \\<subseteq> set (dfs g (x # xs) ys) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False<SEP>have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"<SEP>by(rule visit_subset_dfs)<SEP>with 2 and False<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Depth-First-Search/DFS.thy", "problem_name": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"", "x": "<ISA_PRF> lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\" \\n proof(induct g xs ys rule:dfs.induct) \\n case(2 g x xs ys) \\n show ?case \\n proof(cases \"x \\<in> set ys\") \\n case True \\n have \"set ys \\<subseteq> set (dfs g xs ys)\" \\n by (rule visit_subset_dfs) \\n with 2 and True \\n show ?thesis \\n by (auto simp add: List.member_def) \\n next \\n case False \\n have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\" \\n by(rule visit_subset_dfs) \\n with 2 and False \\n show ?thesis \\n by (auto simp add: List.member_def) \\n qed <ISA_OBS> proof (state) this: set (x # xs) \\<subseteq> set (dfs g (x # xs) ys) goal (1 subgoal): 1. \\<And>g ys. set [] \\<subseteq> set (dfs g [] ys)", "y": "qed(simp)", "proof_script_until_now": "lemma next_subset_dfs: \"set xs \\<subseteq> set (dfs g xs ys)\"<SEP>proof(induct g xs ys rule:dfs.induct)<SEP>case(2 g x xs ys)<SEP>show ?case<SEP>proof(cases \"x \\<in> set ys\")<SEP>case True<SEP>have \"set ys \\<subseteq> set (dfs g xs ys)\"<SEP>by (rule visit_subset_dfs)<SEP>with 2 and True<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>next<SEP>case False<SEP>have \"set (x#ys) \\<subseteq> set (dfs g (nexts g x @ xs) (x#ys))\"<SEP>by(rule visit_subset_dfs)<SEP>with 2 and False<SEP>show ?thesis<SEP>by (auto simp add: List.member_def)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow> braun (merge l r) \\<and> size (merge l r) = size l + size r", "y": "apply(induction l r rule: merge.induct)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) <ISA_OBS> proof (prove) goal (3 subgoals): 1. \\<And>l. braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle> \\<Longrightarrow> braun (merge l \\<langle>\\<rangle>) \\<and> size (merge l \\<langle>\\<rangle>) = size l + size \\<langle>\\<rangle> 2. \\<And>l1 a1 r1 l2 a2 r2. \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (merge l1 r1) \\<and> size (merge l1 r1) = size l1 + size r1; braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) \\<and> size (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) = size \\<langle>l1, a1, r1\\<rangle> + size \\<langle>l2, a2, r2\\<rangle> 3. \\<And>v va vb. braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle> \\<Longrightarrow> braun (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>) \\<and> size (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>) = size \\<langle>\\<rangle> + size \\<langle>v, va, vb\\<rangle>", "y": "apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done <ISA_OBS> proof (prove) goal (1 subgoal): 1. Priority_Queue \\<langle>\\<rangle> (\\<lambda>h. h = \\<langle>\\<rangle>) insert get_min del_min2 (\\<lambda>h. braun h \\<and> heap h) mset_tree", "y": "proof(standard, goal_cases)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) <ISA_OBS> proof (state) goal (8 subgoals): 1. mset_tree \\<langle>\\<rangle> = {#} 2. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 7. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 8. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 1", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 <ISA_OBS> proof (state) this: goal (8 subgoals): 1. mset_tree \\<langle>\\<rangle> = {#} 2. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 7. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 8. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "show ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree \\<langle>\\<rangle> = {#}", "y": "by simp", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp <ISA_OBS> proof (state) this: mset_tree \\<langle>\\<rangle> = {#} goal (7 subgoals): 1. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 6. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 7. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (7 subgoals): 1. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 6. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 7. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 2", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ goal (7 subgoals): 1. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 6. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 7. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "show ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})", "y": "by simp", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp <ISA_OBS> proof (state) this: (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#}) goal (6 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 5. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 6. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (6 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 5. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 6. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 3", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ goal (6 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 5. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 6. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "show ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}", "y": "by(simp add: mset_insert)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) <ISA_OBS> proof (state) this: mset_tree (insert x_ q_) = mset_tree q_ + {#x_#} goal (5 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 4. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next <ISA_OBS> proof (state) goal (5 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 4. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 4", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (5 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 4. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "thus ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#}", "y": "by(auto simp: mset_tree_merge neq_Leaf_iff)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) <ISA_OBS> proof (state) this: mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#} goal (4 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next <ISA_OBS> proof (state) goal (4 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 5", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (4 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "thus ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)", "y": "using get_min mset_tree.simps(1)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} \\<lbrakk>heap ?t; ?t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t) mset_tree \\<langle>\\<rangle> = {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)", "y": "by blast", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast <ISA_OBS> proof (state) this: get_min q_ = Min_mset (mset_tree q_) goal (3 subgoals): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next <ISA_OBS> proof (state) goal (3 subgoals): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 6", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 <ISA_OBS> proof (state) this: goal (3 subgoals): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "thus ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>", "y": "by(simp)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) <ISA_OBS> proof (state) this: braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> goal (2 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 7", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ goal (2 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "thus ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ goal (1 subgoal): 1. braun (insert x_ q_) \\<and> heap (insert x_ q_)", "y": "by(simp add: heap_insert braun_insert)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) <ISA_OBS> proof (state) this: braun (insert x_ q_) \\<and> heap (insert x_ q_) goal (1 subgoal): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "next", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "case 8", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "y": "thus ?case", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next<SEP>case 8"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. braun (del_min2 q_) \\<and> heap (del_min2 q_)", "y": "by(auto simp: heap_merge braun_size_merge neq_Leaf_iff)", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next<SEP>case 8<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma braun_size_merge: \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\" \\n apply(induction l r rule: merge.induct) \\n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \\n done \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(auto simp: mset_tree_merge neq_Leaf_iff) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case \\n by(auto simp: heap_merge braun_size_merge neq_Leaf_iff) <ISA_OBS> proof (state) this: braun (del_min2 q_) \\<and> heap (del_min2 q_) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\"<SEP>apply(induction l r rule: merge.induct)<SEP>apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)<SEP>done<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(auto simp: mset_tree_merge neq_Leaf_iff)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next<SEP>case 8<SEP>thus ?case<SEP>by(auto simp: heap_merge braun_size_merge neq_Leaf_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>braun \\<langle>l, x, r\\<rangle>; heap l; heap r\\<rbrakk> \\<Longrightarrow> heap (merge l r)", "y": "proof(induction l r rule: merge.induct)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) <ISA_OBS> proof (state) goal (3 subgoals): 1. \\<And>l. \\<lbrakk>braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle>; heap l; heap \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge l \\<langle>\\<rangle>) 2. \\<And>l1 a1 r1 l2 a2 r2. \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1); braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle>; heap \\<langle>l1, a1, r1\\<rangle>; heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 3. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "case 1", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 <ISA_OBS> proof (state) this: braun \\<langle>l_, x, \\<langle>\\<rangle>\\<rangle> heap l_ heap \\<langle>\\<rangle> goal (3 subgoals): 1. \\<And>l. \\<lbrakk>braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle>; heap l; heap \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge l \\<langle>\\<rangle>) 2. \\<And>l1 a1 r1 l2 a2 r2. \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1); braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle>; heap \\<langle>l1, a1, r1\\<rangle>; heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 3. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "thus ?case", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case <ISA_OBS> proof (prove) using this: braun \\<langle>l_, x, \\<langle>\\<rangle>\\<rangle> heap l_ heap \\<langle>\\<rangle> goal (1 subgoal): 1. heap (merge l_ \\<langle>\\<rangle>)", "y": "by simp", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp <ISA_OBS> proof (state) this: heap (merge l_ \\<langle>\\<rangle>) goal (2 subgoals): 1. \\<And>l1 a1 r1 l2 a2 r2. \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1); braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle>; heap \\<langle>l1, a1, r1\\<rangle>; heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 2. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "next", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>l1 a1 r1 l2 a2 r2. \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1); braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle>; heap \\<langle>l1, a1, r1\\<rangle>; heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 2. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "case (2 l1 a1 r1 l2 a2 r2)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) <ISA_OBS> proof (state) this: \\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1) braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle> heap \\<langle>l1, a1, r1\\<rangle> heap \\<langle>l2, a2, r2\\<rangle> goal (2 subgoals): 1. \\<And>l1 a1 r1 l2 a2 r2. \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1); braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle>; heap \\<langle>l1, a1, r1\\<rangle>; heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 2. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "show ?case", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "proof cases", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases <ISA_OBS> proof (state) goal (2 subgoals): 1. ?P \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 2. \\<not> ?P \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "assume \"a1 \\<le> a2\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" <ISA_OBS> proof (state) this: a1 \\<le> a2 goal (2 subgoals): 1. ?P \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) 2. \\<not> ?P \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "thus ?thesis", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis <ISA_OBS> proof (prove) using this: a1 \\<le> a2 goal (1 subgoal): 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "using 2", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 <ISA_OBS> proof (prove) using this: a1 \\<le> a2 \\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1; heap r1\\<rbrakk> \\<Longrightarrow> heap (merge l1 r1) braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle> heap \\<langle>l1, a1, r1\\<rangle> heap \\<langle>l2, a2, r2\\<rangle> goal (1 subgoal): 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) <ISA_OBS> proof (state) this: heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "next", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "assume \"\\<not> a1 \\<le> a2\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" <ISA_OBS> proof (state) this: \\<not> a1 \\<le> a2 goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "let ?l = \"Node l1 a1 r1\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "let ?r = \"Node l2 a2 r2\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "have \"braun ?r\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l2, a2, r2\\<rangle>", "y": "using \"2.prems\"(1)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) <ISA_OBS> proof (prove) using this: braun \\<langle>\\<langle>l1, a1, r1\\<rangle>, x, \\<langle>l2, a2, r2\\<rangle>\\<rangle> goal (1 subgoal): 1. braun \\<langle>l2, a2, r2\\<rangle>", "y": "by auto", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto <ISA_OBS> proof (state) this: braun \\<langle>l2, a2, r2\\<rangle> goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "obtain x l' where dl: \"del_left ?l = (x, l')\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\\<And>x l'. del_left \\<langle>l1, a1, r1\\<rangle> = (x, l') \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "y": "by (metis surj_pair)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) <ISA_OBS> proof (state) this: del_left \\<langle>l1, a1, r1\\<rangle> = (x, l') goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "from del_left_heap[OF this _ \"2.prems\"(2)]", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] <ISA_OBS> proof (chain) picking this: \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> heap l'", "y": "have \"heap l'\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" <ISA_OBS> proof (prove) using this: \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> heap l' goal (1 subgoal): 1. heap l'", "y": "by auto", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto <ISA_OBS> proof (state) this: heap l' goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "have hr: \"heap(replace_min x ?r)\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)", "y": "using \\<open>braun ?r\\<close> \"2.prems\"(3)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) <ISA_OBS> proof (prove) using this: braun \\<langle>l2, a2, r2\\<rangle> heap \\<langle>l2, a2, r2\\<rangle> goal (1 subgoal): 1. heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)", "y": "by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) <ISA_OBS> proof (state) this: heap (replace_min x \\<langle>l2, a2, r2\\<rangle>) goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x", "y": "using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close>", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> <ISA_OBS> proof (prove) using this: heap \\<langle>l1, a1, r1\\<rangle> \\<not> a1 \\<le> a2 goal (1 subgoal): 1. \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x", "y": "by (auto simp: ball_Un)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close>"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) <ISA_OBS> proof (state) this: \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "moreover", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover <ISA_OBS> proof (state) this: \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> &&& x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "y": "using del_left_mset[OF dl]", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] <ISA_OBS> proof (prove) using this: \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> x \\<in># mset_tree \\<langle>l1, a1, r1\\<rangle> \\<and> mset_tree l' = mset_tree \\<langle>l1, a1, r1\\<rangle> - {#x#} goal (1 subgoal): 1. set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> &&& x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "y": "by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) <ISA_OBS> proof (state) this: set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle> goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "ultimately", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately <ISA_OBS> proof (chain) picking this: \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "y": "have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" <ISA_OBS> proof (prove) using this: \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle> goal (1 subgoal): 1. \\<forall>x\\<in>set_tree l'. a2 \\<le> x", "y": "by blast", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast <ISA_OBS> proof (state) this: \\<forall>x\\<in>set_tree l'. a2 \\<le> x goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x", "y": "using \\<open>heap ?r\\<close>", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> <ISA_OBS> proof (prove) using this: heap \\<langle>l2, a2, r2\\<rangle> goal (1 subgoal): 1. \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x", "y": "by auto", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close>"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto <ISA_OBS> proof (state) this: \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x goal (1 subgoal): 1. \\<not> a1 \\<le> a2 \\<Longrightarrow> heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "thus ?thesis", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis <ISA_OBS> proof (prove) using this: \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x goal (1 subgoal): 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close>", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> <ISA_OBS> proof (prove) using this: \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x \\<not> a1 \\<le> a2 del_left \\<langle>l1, a1, r1\\<rangle> = (x, l') heap (replace_min x \\<langle>l2, a2, r2\\<rangle>) heap l' x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle> \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x \\<forall>x\\<in>set_tree l'. a2 \\<le> x braun \\<langle>l2, a2, r2\\<rangle> goal (1 subgoal): 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "y": "by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close>"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) <ISA_OBS> proof (state) this: heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close><SEP>by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \\n qed <ISA_OBS> proof (state) this: heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) goal (1 subgoal): 1. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "next", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close><SEP>by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \\n qed \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "case 3", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close><SEP>by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)<SEP>qed<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \\n qed \\n next \\n case 3 <ISA_OBS> proof (state) this: braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v_, va_, vb_\\<rangle>\\<rangle> heap \\<langle>\\<rangle> heap \\<langle>v_, va_, vb_\\<rangle> goal (1 subgoal): 1. \\<And>v va vb. \\<lbrakk>braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v, va, vb\\<rangle>\\<rangle>; heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>)", "y": "thus ?case", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close><SEP>by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)<SEP>qed<SEP>next<SEP>case 3"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \\n qed \\n next \\n case 3 \\n thus ?case <ISA_OBS> proof (prove) using this: braun \\<langle>\\<langle>\\<rangle>, x, \\<langle>v_, va_, vb_\\<rangle>\\<rangle> heap \\<langle>\\<rangle> heap \\<langle>v_, va_, vb_\\<rangle> goal (1 subgoal): 1. heap (merge \\<langle>\\<rangle> \\<langle>v_, va_, vb_\\<rangle>)", "y": "by simp", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close><SEP>by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)<SEP>qed<SEP>next<SEP>case 3<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "x": "<ISA_PRF> lemma heap_merge: \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\" \\n proof(induction l r rule: merge.induct) \\n case 1 \\n thus ?case \\n by simp \\n next \\n case (2 l1 a1 r1 l2 a2 r2) \\n show ?case \\n proof cases \\n assume \"a1 \\<le> a2\" \\n thus ?thesis \\n using 2 \\n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \\n next \\n assume \"\\<not> a1 \\<le> a2\" \\n let ?l = \"Node l1 a1 r1\" \\n let ?r = \"Node l2 a2 r2\" \\n have \"braun ?r\" \\n using \"2.prems\"(1) \\n by auto \\n obtain x l' where dl: \"del_left ?l = (x, l')\" \\n by (metis surj_pair) \\n from del_left_heap[OF this _ \"2.prems\"(2)] \\n have \"heap l'\" \\n by auto \\n have hr: \"heap(replace_min x ?r)\" \\n using \\<open>braun ?r\\<close> \"2.prems\"(3) \\n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \\n have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\" \\n using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close> \\n by (auto simp: ball_Un) \\n moreover \\n have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\" \\n using del_left_mset[OF dl] \\n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \\n ultimately \\n have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\" \\n by blast \\n have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\" \\n using \\<open>heap ?r\\<close> \\n by auto \\n thus ?thesis \\n using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close> \\n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \\n qed \\n next \\n case 3 \\n thus ?case \\n by simp <ISA_OBS> proof (state) this: heap (merge \\<langle>\\<rangle> \\<langle>v_, va_, vb_\\<rangle>) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"<SEP>proof(induction l r rule: merge.induct)<SEP>case 1<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 l1 a1 r1 l2 a2 r2)<SEP>show ?case<SEP>proof cases<SEP>assume \"a1 \\<le> a2\"<SEP>thus ?thesis<SEP>using 2<SEP>by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)<SEP>next<SEP>assume \"\\<not> a1 \\<le> a2\"<SEP>let ?l = \"Node l1 a1 r1\"<SEP>let ?r = \"Node l2 a2 r2\"<SEP>have \"braun ?r\"<SEP>using \"2.prems\"(1)<SEP>by auto<SEP>obtain x l' where dl: \"del_left ?l = (x, l')\"<SEP>by (metis surj_pair)<SEP>from del_left_heap[OF this _ \"2.prems\"(2)]<SEP>have \"heap l'\"<SEP>by auto<SEP>have hr: \"heap(replace_min x ?r)\"<SEP>using \\<open>braun ?r\\<close> \"2.prems\"(3)<SEP>by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)<SEP>have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\"<SEP>using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close><SEP>by (auto simp: ball_Un)<SEP>moreover<SEP>have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\"<SEP>using del_left_mset[OF dl]<SEP>by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)<SEP>ultimately<SEP>have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\"<SEP>by blast<SEP>have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\"<SEP>using \\<open>heap ?r\\<close><SEP>by auto<SEP>thus ?thesis<SEP>using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close><SEP>by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)<SEP>qed<SEP>next<SEP>case 3<SEP>thus ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma del_left_braun_size:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t' \\<and> size t = size t' + 1\"", "x": "<ISA_PRF> lemma del_left_braun_size: \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t' \\<and> size t = size t' + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (x, t'); braun t; t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun t' \\<and> size t = size t' + 1", "y": "by (simp add: del_left_braun del_left_size)", "proof_script_until_now": "lemma del_left_braun_size:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t' \\<and> size t = size t' + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma replace_min_sift_down: \"braun (Node l a r) \\<Longrightarrow> replace_min x (Node l a r) = sift_down l x r\"", "x": "<ISA_PRF> lemma replace_min_sift_down: \"braun (Node l a r) \\<Longrightarrow> replace_min x (Node l a r) = sift_down l x r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow> replace_min x \\<langle>l, a, r\\<rangle> = sift_down l x r", "y": "by(induction l x r rule: sift_down.induct)(auto)", "proof_script_until_now": "lemma replace_min_sift_down: \"braun (Node l a r) \\<Longrightarrow> replace_min x (Node l a r) = sift_down l x r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "problem_name": "lemma mset_tree_merge:\n  \"braun (Node l x r) \\<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r\"", "x": "<ISA_PRF> lemma mset_tree_merge: \"braun (Node l x r) \\<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow> mset_tree (merge l r) = mset_tree l + mset_tree r", "y": "by(induction l r rule: merge.induct) (auto simp: Let_def tree.set_sel(2) mset_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_mset split!: prod.split)", "proof_script_until_now": "lemma mset_tree_merge:\n  \"braun (Node l x r) \\<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma set_insert[simp]: \"set_tree(insert x t) = {x} \\<union> (set_tree t)\"", "x": "<ISA_PRF> lemma set_insert[simp]: \"set_tree(insert x t) = {x} \\<union> (set_tree t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set_tree (insert x t) = {x} \\<union> set_tree t", "y": "by(simp add: mset_insert flip: set_mset_tree)", "proof_script_until_now": "lemma set_insert[simp]: \"set_tree(insert x t) = {x} \\<union> (set_tree t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma size_insert[simp]: \"size(insert x t) = size t + 1\"", "x": "<ISA_PRF> lemma size_insert[simp]: \"size(insert x t) = size t + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (insert x t) = size t + 1", "y": "by(induction t arbitrary: x) auto", "proof_script_until_now": "lemma size_insert[simp]: \"size(insert x t) = size t + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> 2 ^ height t \\<le> 2 * size t + 1", "y": "proof(induction t)", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) <ISA_OBS> proof (state) goal (2 subgoals): 1. braun \\<langle>\\<rangle> \\<Longrightarrow> 2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1 2. \\<And>t1 x2 t2. \\<lbrakk>braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1; braun t2 \\<Longrightarrow> 2 ^ height t2 \\<le> 2 * size t2 + 1; braun \\<langle>t1, x2, t2\\<rangle>\\<rbrakk> \\<Longrightarrow> 2 ^ height \\<langle>t1, x2, t2\\<rangle> \\<le> 2 * size \\<langle>t1, x2, t2\\<rangle> + 1", "y": "case (Node t1)", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) <ISA_OBS> proof (state) this: braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1 braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1 braun \\<langle>t1, x2_, t2_\\<rangle> goal (2 subgoals): 1. braun \\<langle>\\<rangle> \\<Longrightarrow> 2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1 2. \\<And>t1 x2 t2. \\<lbrakk>braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1; braun t2 \\<Longrightarrow> 2 ^ height t2 \\<le> 2 * size t2 + 1; braun \\<langle>t1, x2, t2\\<rangle>\\<rbrakk> \\<Longrightarrow> 2 ^ height \\<langle>t1, x2, t2\\<rangle> \\<le> 2 * size \\<langle>t1, x2, t2\\<rangle> + 1", "y": "show ?case", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "proof (cases \"height t1\")", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") <ISA_OBS> proof (state) goal (2 subgoals): 1. height t1 = 0 \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1 2. \\<And>nat. height t1 = Suc nat \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "case 0", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 <ISA_OBS> proof (state) this: height t1 = 0 goal (2 subgoals): 1. height t1 = 0 \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1 2. \\<And>nat. height t1 = Suc nat \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "thus ?thesis", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis <ISA_OBS> proof (prove) using this: height t1 = 0 goal (1 subgoal): 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "using Node", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node <ISA_OBS> proof (prove) using this: height t1 = 0 braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1 braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1 braun \\<langle>t1, x2_, t2_\\<rangle> goal (1 subgoal): 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "by simp", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp <ISA_OBS> proof (state) this: 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1 goal (1 subgoal): 1. \\<And>nat. height t1 = Suc nat \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "next", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>nat. height t1 = Suc nat \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "case (Suc n)", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) <ISA_OBS> proof (state) this: height t1 = Suc n goal (1 subgoal): 1. \\<And>nat. height t1 = Suc nat \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "hence \"2 ^ n \\<le> size t1\"", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" <ISA_OBS> proof (prove) using this: height t1 = Suc n goal (1 subgoal): 1. 2 ^ n \\<le> size t1", "y": "using Node", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node <ISA_OBS> proof (prove) using this: height t1 = Suc n braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1 braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1 braun \\<langle>t1, x2_, t2_\\<rangle> goal (1 subgoal): 1. 2 ^ n \\<le> size t1", "y": "by simp", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\"<SEP>using Node"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp <ISA_OBS> proof (state) this: 2 ^ n \\<le> size t1 goal (1 subgoal): 1. \\<And>nat. height t1 = Suc nat \\<Longrightarrow> 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "thus ?thesis", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\"<SEP>using Node<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis <ISA_OBS> proof (prove) using this: 2 ^ n \\<le> size t1 goal (1 subgoal): 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "using Suc Node", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\"<SEP>using Node<SEP>by simp<SEP>thus ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis \\n using Suc Node <ISA_OBS> proof (prove) using this: 2 ^ n \\<le> size t1 height t1 = Suc n braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1 braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1 braun \\<langle>t1, x2_, t2_\\<rangle> goal (1 subgoal): 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "y": "by(auto simp: max_def)", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\"<SEP>using Node<SEP>by simp<SEP>thus ?thesis<SEP>using Suc Node"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis \\n using Suc Node \\n by(auto simp: max_def) <ISA_OBS> proof (state) this: 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1 goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\"<SEP>using Node<SEP>by simp<SEP>thus ?thesis<SEP>using Suc Node<SEP>by(auto simp: max_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "x": "<ISA_PRF> lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\" \\n proof(induction t) \\n case (Node t1) \\n show ?case \\n proof (cases \"height t1\") \\n case 0 \\n thus ?thesis \\n using Node \\n by simp \\n next \\n case (Suc n) \\n hence \"2 ^ n \\<le> size t1\" \\n using Node \\n by simp \\n thus ?thesis \\n using Suc Node \\n by(auto simp: max_def) \\n qed <ISA_OBS> proof (state) this: 2 ^ height \\<langle>t1, x2_, t2_\\<rangle> \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1 goal (1 subgoal): 1. braun \\<langle>\\<rangle> \\<Longrightarrow> 2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1", "y": "qed simp", "proof_script_until_now": "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"<SEP>proof(induction t)<SEP>case (Node t1)<SEP>show ?case<SEP>proof (cases \"height t1\")<SEP>case 0<SEP>thus ?thesis<SEP>using Node<SEP>by simp<SEP>next<SEP>case (Suc n)<SEP>hence \"2 ^ n \\<le> size t1\"<SEP>using Node<SEP>by simp<SEP>thus ?thesis<SEP>using Suc Node<SEP>by(auto simp: max_def)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_set:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'\"", "x": "<ISA_PRF> lemma del_left_set: \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'", "y": "by(simp add: del_left_mset_plus flip: set_mset_tree)", "proof_script_until_now": "lemma del_left_set:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_insert: \"mset_tree(insert x t) = {#x#} + mset_tree t\"", "x": "<ISA_PRF> lemma mset_insert: \"mset_tree(insert x t) = {#x#} + mset_tree t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (insert x t) = {#x#} + mset_tree t", "y": "by(induction t arbitrary: x) (auto simp: ac_simps)", "proof_script_until_now": "lemma mset_insert: \"mset_tree(insert x t) = {#x#} + mset_tree t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_insert: \"heap t \\<Longrightarrow> heap(insert x t)\"", "x": "<ISA_PRF> lemma heap_insert: \"heap t \\<Longrightarrow> heap(insert x t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap t \\<Longrightarrow> heap (insert x t)", "y": "by(induction t arbitrary: x) (auto simp add: ball_Un)", "proof_script_until_now": "lemma heap_insert: \"heap t \\<Longrightarrow> heap(insert x t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "proof(cases t rule: del_min.cases)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) <ISA_OBS> proof (state) goal (3 subgoals): 1. t = \\<langle>\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \\<And>x r. t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 3. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "case 1", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 <ISA_OBS> proof (state) this: t = \\<langle>\\<rangle> goal (3 subgoals): 1. t = \\<langle>\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \\<And>x r. t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 3. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "with assms", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms <ISA_OBS> proof (chain) picking this: braun t t \\<noteq> \\<langle>\\<rangle> t = \\<langle>\\<rangle>", "y": "show ?thesis", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis <ISA_OBS> proof (prove) using this: braun t t \\<noteq> \\<langle>\\<rangle> t = \\<langle>\\<rangle> goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "by simp", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp <ISA_OBS> proof (state) this: mset_tree (del_min t) = mset_tree t - {#get_min t#} goal (2 subgoals): 1. \\<And>x r. t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>x r. t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "case 2", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 <ISA_OBS> proof (state) this: t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle> goal (2 subgoals): 1. \\<And>x r. t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "with assms", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms <ISA_OBS> proof (chain) picking this: braun t t \\<noteq> \\<langle>\\<rangle> t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>", "y": "show ?thesis", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis <ISA_OBS> proof (prove) using this: braun t t \\<noteq> \\<langle>\\<rangle> t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle> goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "by (simp)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) <ISA_OBS> proof (state) this: mset_tree (del_min t) = mset_tree t - {#get_min t#} goal (1 subgoal): 1. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "case [simp]: (3 ll b lr a r)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) <ISA_OBS> proof (state) this: t = \\<langle>\\<langle>ll, b, lr\\<rangle>, a, r\\<rangle> goal (1 subgoal): 1. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}", "y": "using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] <ISA_OBS> proof (prove) using this: braun t t \\<noteq> \\<langle>\\<rangle> \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and> mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#} \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> size \\<langle>ll, b, lr\\<rangle> = size l' + 1 \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun l' \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l' goal (1 subgoal): 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}", "y": "apply (subst mset_sift_down)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<lbrakk>braun t; t \\<noteq> \\<langle>\\<rangle>; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and> mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#}; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> size \\<langle>ll, b, lr\\<rangle> = size l' + 1; \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun l'; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\\<rbrakk> \\<Longrightarrow> braun \\<langle>r, y, l'\\<rangle> 2. \\<lbrakk>braun t; t \\<noteq> \\<langle>\\<rangle>; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and> mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#}; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> size \\<langle>ll, b, lr\\<rangle> = size l' + 1; \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun l'; \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\\<rbrakk> \\<Longrightarrow> {#y#} + (mset_tree r + mset_tree l') = mset_tree t - {#a#}", "y": "apply (auto simp: ac_simps del_left_mset_plus[OF del])", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done <ISA_OBS> proof (state) this: del_left \\<langle>ll, b, lr\\<rangle> = (?y, ?l') \\<Longrightarrow> mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#} goal (1 subgoal): 1. \\<And>v va vb x r. t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "thus ?thesis", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis <ISA_OBS> proof (prove) using this: del_left \\<langle>ll, b, lr\\<rangle> = (?y, ?l') \\<Longrightarrow> mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#} goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "y": "by(auto split: prod.split)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) <ISA_OBS> proof (state) this: mset_tree (del_min t) = mset_tree t - {#get_min t#} goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed <ISA_OBS> proof (prove) goal (1 subgoal): 1. Priority_Queue \\<langle>\\<rangle> (\\<lambda>h. h = \\<langle>\\<rangle>) insert get_min del_min (\\<lambda>h. braun h \\<and> heap h) mset_tree", "y": "proof(standard, goal_cases)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) <ISA_OBS> proof (state) goal (8 subgoals): 1. mset_tree \\<langle>\\<rangle> = {#} 2. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 7. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 8. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 1", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 <ISA_OBS> proof (state) this: goal (8 subgoals): 1. mset_tree \\<langle>\\<rangle> = {#} 2. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 7. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 8. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "show ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree \\<langle>\\<rangle> = {#}", "y": "by simp", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp <ISA_OBS> proof (state) this: mset_tree \\<langle>\\<rangle> = {#} goal (7 subgoals): 1. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 6. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 7. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (7 subgoals): 1. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 6. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 7. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 2", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ goal (7 subgoals): 1. \\<And>q. braun q \\<and> heap q \\<Longrightarrow> (q = \\<langle>\\<rangle>) = (mset_tree q = {#}) 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 6. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 7. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "show ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})", "y": "by simp", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp <ISA_OBS> proof (state) this: (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#}) goal (6 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 5. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 6. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (6 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 5. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 6. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 3", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ goal (6 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 5. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 6. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "show ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}", "y": "by(simp add: mset_insert)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) <ISA_OBS> proof (state) this: mset_tree (insert x_ q_) = mset_tree q_ + {#x_#} goal (5 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 4. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next <ISA_OBS> proof (state) goal (5 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 4. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 4", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (5 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 4. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 5. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "thus ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}", "y": "by(simp add: mset_del_min)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) <ISA_OBS> proof (state) this: mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#} goal (4 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next <ISA_OBS> proof (state) goal (4 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 5", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (4 subgoals): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 3. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 4. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "thus ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)", "y": "using get_min mset_tree.simps(1)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} \\<lbrakk>heap ?t; ?t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t) mset_tree \\<langle>\\<rangle> = {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)", "y": "by blast", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast <ISA_OBS> proof (state) this: get_min q_ = Min_mset (mset_tree q_) goal (3 subgoals): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next <ISA_OBS> proof (state) goal (3 subgoals): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 6", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 <ISA_OBS> proof (state) this: goal (3 subgoals): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> 2. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 3. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "thus ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>", "y": "by(simp)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) <ISA_OBS> proof (state) this: braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle> goal (2 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 7", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ goal (2 subgoals): 1. \\<And>q x. braun q \\<and> heap q \\<Longrightarrow> braun (insert x q) \\<and> heap (insert x q) 2. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "thus ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ goal (1 subgoal): 1. braun (insert x_ q_) \\<and> heap (insert x_ q_)", "y": "by(simp add: heap_insert braun_insert)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) <ISA_OBS> proof (state) this: braun (insert x_ q_) \\<and> heap (insert x_ q_) goal (1 subgoal): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "next", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "case 8", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 <ISA_OBS> proof (state) this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. \\<And>q. \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk> \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "y": "thus ?case", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next<SEP>case 8"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \\<and> heap q_ mset_tree q_ \\<noteq> {#} goal (1 subgoal): 1. braun (del_min q_) \\<and> heap (del_min q_)", "y": "by(simp add: heap_del_min braun_del_min)", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next<SEP>case 8<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"", "x": "<ISA_PRF> lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\" shows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\" \\n proof(cases t rule: del_min.cases) \\n case 1 \\n with assms \\n show ?thesis \\n by simp \\n next \\n case 2 \\n with assms \\n show ?thesis \\n by (simp) \\n next \\n case [simp]: (3 ll b lr a r) \\n have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l' \\n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \\n apply (subst mset_sift_down) \\n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \\n done \\n thus ?thesis \\n by(auto split: prod.split) \\n qed \\n proof(standard, goal_cases) \\n case 1 \\n show ?case \\n by simp \\n next \\n case 2 \\n show ?case \\n by simp \\n next \\n case 3 \\n show ?case \\n by(simp add: mset_insert) \\n next \\n case 4 \\n thus ?case \\n by(simp add: mset_del_min) \\n next \\n case 5 \\n thus ?case \\n using get_min mset_tree.simps(1) \\n by blast \\n next \\n case 6 \\n thus ?case \\n by(simp) \\n next \\n case 7 \\n thus ?case \\n by(simp add: heap_insert braun_insert) \\n next \\n case 8 \\n thus ?case \\n by(simp add: heap_del_min braun_del_min) <ISA_OBS> proof (state) this: braun (del_min q_) \\<and> heap (del_min q_) goal: No subgoals!", "y": "qed", "proof_script_until_now": "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\"<SEP>proof(cases t rule: del_min.cases)<SEP>case 1<SEP>with assms<SEP>show ?thesis<SEP>by simp<SEP>next<SEP>case 2<SEP>with assms<SEP>show ?thesis<SEP>by (simp)<SEP>next<SEP>case [simp]: (3 ll b lr a r)<SEP>have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\" if del: \"del_left (Node ll b lr) = (y,l')\" for y l'<SEP>using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]<SEP>apply (subst mset_sift_down)<SEP>apply (auto simp: ac_simps del_left_mset_plus[OF del])<SEP>done<SEP>thus ?thesis<SEP>by(auto split: prod.split)<SEP>qed<SEP>proof(standard, goal_cases)<SEP>case 1<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 2<SEP>show ?case<SEP>by simp<SEP>next<SEP>case 3<SEP>show ?case<SEP>by(simp add: mset_insert)<SEP>next<SEP>case 4<SEP>thus ?case<SEP>by(simp add: mset_del_min)<SEP>next<SEP>case 5<SEP>thus ?case<SEP>using get_min mset_tree.simps(1)<SEP>by blast<SEP>next<SEP>case 6<SEP>thus ?case<SEP>by(simp)<SEP>next<SEP>case 7<SEP>thus ?case<SEP>by(simp add: heap_insert braun_insert)<SEP>next<SEP>case 8<SEP>thus ?case<SEP>by(simp add: heap_del_min braun_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma get_min: \"\\<lbrakk> heap t;  t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)\"", "x": "<ISA_PRF> lemma get_min: \"\\<lbrakk> heap t; t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heap t; t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)", "y": "by (auto simp add: eq_Min_iff neq_Leaf_iff)", "proof_script_until_now": "lemma get_min: \"\\<lbrakk> heap t;  t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_size:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> size t = size t' + 1\"", "x": "<ISA_PRF> lemma del_left_size: \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> size t = size t' + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> size t = size t' + 1", "y": "by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits)", "proof_script_until_now": "lemma del_left_size:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> size t = size t' + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_heap:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> heap t \\<Longrightarrow> heap t'\"", "x": "<ISA_PRF> lemma del_left_heap: \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> heap t \\<Longrightarrow> heap t'\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>; heap t\\<rbrakk> \\<Longrightarrow> heap t'", "y": "by (induction t arbitrary: x t' rule: del_left.induct; fastforce split: prod.splits dest: del_left_set[THEN equalityD2])", "proof_script_until_now": "lemma del_left_heap:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> heap t \\<Longrightarrow> heap t'\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "x": "<ISA_PRF> lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heap t; braun t\\<rbrakk> \\<Longrightarrow> heap (del_min t)", "y": "apply(cases t rule: del_min.cases)", "proof_script_until_now": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "x": "<ISA_PRF> lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) <ISA_OBS> proof (prove) goal (3 subgoals): 1. \\<lbrakk>heap t; braun t; t = \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (del_min t) 2. \\<And>x r. \\<lbrakk>heap t; braun t; t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (del_min t) 3. \\<And>v va vb x r. \\<lbrakk>heap t; braun t; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (del_min t)", "y": "apply simp", "proof_script_until_now": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"<SEP>apply(cases t rule: del_min.cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "x": "<ISA_PRF> lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>x r. \\<lbrakk>heap t; braun t; t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (del_min t) 2. \\<And>v va vb x r. \\<lbrakk>heap t; braun t; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (del_min t)", "y": "apply simp", "proof_script_until_now": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"<SEP>apply(cases t rule: del_min.cases)<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "x": "<ISA_PRF> lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r. \\<lbrakk>heap t; braun t; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> heap (del_min t)", "y": "apply (fastforce split: prod.split intro!: heap_sift_down dest: del_left_size del_left_braun del_left_heap)", "proof_script_until_now": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"<SEP>apply(cases t rule: del_min.cases)<SEP>apply simp<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "x": "<ISA_PRF> lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp \\n apply (fastforce split: prod.split intro!: heap_sift_down dest: del_left_size del_left_braun del_left_heap) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"<SEP>apply(cases t rule: del_min.cases)<SEP>apply simp<SEP>apply simp<SEP>apply (fastforce split: prod.split intro!: heap_sift_down dest: del_left_size del_left_braun del_left_heap)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> braun(sift_down l a r)\"", "x": "<ISA_PRF> lemma braun_sift_down: \"braun(Node l a r) \\<Longrightarrow> braun(sift_down l a r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow> braun (sift_down l a r)", "y": "by(induction l a r rule: sift_down.induct) (auto simp: size_sift_down Let_def)", "proof_script_until_now": "lemma braun_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> braun(sift_down l a r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma heap_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap(sift_down l a r)\"", "x": "<ISA_PRF> lemma heap_sift_down: \"braun(Node l a r) \\<Longrightarrow> heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap(sift_down l a r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>braun \\<langle>l, a, r\\<rangle>; heap l; heap r\\<rbrakk> \\<Longrightarrow> heap (sift_down l a r)", "y": "by (induction l a r rule: sift_down.induct) (auto simp: set_sift_down ball_Un Let_def)", "proof_script_until_now": "lemma heap_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap(sift_down l a r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"", "x": "<ISA_PRF> lemma del_left_braun: \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (x, t'); braun t; t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun t'", "y": "by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size)", "proof_script_until_now": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"", "x": "<ISA_PRF> lemma del_left_braun: \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\" \\n by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size) <ISA_OBS> proof (prove) goal (11 subgoals): 1. \\<And>P x. \\<lbrakk>\\<And>a uu_. x = (\\<langle>\\<rangle>, a, uu_) \\<Longrightarrow> P; \\<And>xa uv_ a. x = (\\<langle>\\<langle>\\<rangle>, xa, uv_\\<rangle>, a, \\<langle>\\<rangle>) \\<Longrightarrow> P; \\<And>l1 x1 r1 a l2 x2 r2. x = (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow> P; \\<And>vc vd ve va vb b. x = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P 2. \\<And>a uu_ aa uua_. (\\<langle>\\<rangle>, a, uu_) = (\\<langle>\\<rangle>, aa, uua_) \\<Longrightarrow> \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> = \\<langle>\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle> 3. \\<And>a uu_ x uv_ aa. (\\<langle>\\<rangle>, a, uu_) = (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow> \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> = (if aa \\<le> x then \\<langle>\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle> else \\<langle>\\<langle>\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>) 4. \\<And>a uu_ l1 x1 r1 aa l2 x2 r2. (\\<langle>\\<rangle>, a, uu_) = (\\<langle>l1, x1, r1\\<rangle>, aa, \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow> \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> = (let t2 = \\<langle>l2, x2, r2\\<rangle>; t1 = \\<langle>l1, x1, r1\\<rangle> in if aa \\<le> x1 \\<and> aa \\<le> x2 then \\<langle>t1, aa, t2\\<rangle> else if x1 \\<le> x2 then \\<langle>sift_down_sumC (l1, aa, r1), x1, t2\\<rangle> else \\<langle>t1, x2, sift_down_sumC (l2, aa, r2)\\<rangle>) 5. \\<And>a uu_ vc vd ve va vb b. (\\<langle>\\<rangle>, a, uu_) = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> = undefined 6. \\<And>x uv_ a xa uva_ aa. (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<langle>\\<rangle>, xa, uva_\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow> (if a \\<le> x then \\<langle>\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> else \\<langle>\\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>) = (if aa \\<le> xa then \\<langle>\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle> else \\<langle>\\<langle>\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>) 7. \\<And>x uv_ a l1 x1 r1 aa l2 x2 r2. (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>l1, x1, r1\\<rangle>, aa, \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow> (if a \\<le> x then \\<langle>\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> else \\<langle>\\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>) = (let t2 = \\<langle>l2, x2, r2\\<rangle>; t1 = \\<langle>l1, x1, r1\\<rangle> in if aa \\<le> x1 \\<and> aa \\<le> x2 then \\<langle>t1, aa, t2\\<rangle> else if x1 \\<le> x2 then \\<langle>sift_down_sumC (l1, aa, r1), x1, t2\\<rangle> else \\<langle>t1, x2, sift_down_sumC (l2, aa, r2)\\<rangle>) 8. \\<And>x uv_ a vc vd ve va vb b. (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> (if a \\<le> x then \\<langle>\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> else \\<langle>\\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>) = undefined 9. \\<And>l1 x1 r1 a l2 x2 r2 l1a x1a r1a aa l2a x2a r2a. (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) = (\\<langle>l1a, x1a, r1a\\<rangle>, aa, \\<langle>l2a, x2a, r2a\\<rangle>) \\<Longrightarrow> (let t2 = \\<langle>l2, x2, r2\\<rangle>; t1 = \\<langle>l1, x1, r1\\<rangle> in if a \\<le> x1 \\<and> a \\<le> x2 then \\<langle>t1, a, t2\\<rangle> else if x1 \\<le> x2 then \\<langle>sift_down_sumC (l1, a, r1), x1, t2\\<rangle> else \\<langle>t1, x2, sift_down_sumC (l2, a, r2)\\<rangle>) = (let t2 = \\<langle>l2a, x2a, r2a\\<rangle>; t1 = \\<langle>l1a, x1a, r1a\\<rangle> in if aa \\<le> x1a \\<and> aa \\<le> x2a then \\<langle>t1, aa, t2\\<rangle> else if x1a \\<le> x2a then \\<langle>sift_down_sumC (l1a, aa, r1a), x1a, t2\\<rangle> else \\<langle>t1, x2a, sift_down_sumC (l2a, aa, r2a)\\<rangle>) 10. \\<And>l1 x1 r1 a l2 x2 r2 vc vd ve va vb b. (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> (let t2 = \\<langle>l2, x2, r2\\<rangle>; t1 = \\<langle>l1, x1, r1\\<rangle> in if a \\<le> x1 \\<and> a \\<le> x2 then \\<langle>t1, a, t2\\<rangle> else if x1 \\<le> x2 then \\<langle>sift_down_sumC (l1, a, r1), x1, t2\\<rangle> else \\<langle>t1, x2, sift_down_sumC (l2, a, r2)\\<rangle>) = undefined A total of 11 subgoals...", "y": "by pat_completeness auto", "proof_script_until_now": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"<SEP>by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"", "x": "<ISA_PRF> lemma del_left_braun: \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\" \\n by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size) \\n by pat_completeness auto <ISA_OBS> proof (prove) goal (1 subgoal): 1. All sift_down_dom", "y": "by (relation \"measure (%(l,a,r). size l + size r)\") auto", "proof_script_until_now": "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"<SEP>by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size)<SEP>by pat_completeness auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "x": "<ISA_PRF> lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> braun (del_min t)", "y": "apply(cases t rule: del_min.cases)", "proof_script_until_now": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "x": "<ISA_PRF> lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) <ISA_OBS> proof (prove) goal (3 subgoals): 1. \\<lbrakk>braun t; t = \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (del_min t) 2. \\<And>x r. \\<lbrakk>braun t; t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (del_min t) 3. \\<And>v va vb x r. \\<lbrakk>braun t; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (del_min t)", "y": "apply simp", "proof_script_until_now": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"<SEP>apply(cases t rule: del_min.cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "x": "<ISA_PRF> lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>x r. \\<lbrakk>braun t; t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (del_min t) 2. \\<And>v va vb x r. \\<lbrakk>braun t; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (del_min t)", "y": "apply simp", "proof_script_until_now": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"<SEP>apply(cases t rule: del_min.cases)<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "x": "<ISA_PRF> lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r. \\<lbrakk>braun t; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> braun (del_min t)", "y": "apply (fastforce split: prod.split intro!: braun_sift_down dest: del_left_size del_left_braun)", "proof_script_until_now": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"<SEP>apply(cases t rule: del_min.cases)<SEP>apply simp<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "x": "<ISA_PRF> lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\" \\n apply(cases t rule: del_min.cases) \\n apply simp \\n apply simp \\n apply (fastforce split: prod.split intro!: braun_sift_down dest: del_left_size del_left_braun) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"<SEP>apply(cases t rule: del_min.cases)<SEP>apply simp<SEP>apply simp<SEP>apply (fastforce split: prod.split intro!: braun_sift_down dest: del_left_size del_left_braun)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma set_sift_down: \"braun(Node l a r)\n  \\<Longrightarrow> set_tree(sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)\"", "x": "<ISA_PRF> lemma set_sift_down: \"braun(Node l a r) \\<Longrightarrow> set_tree(sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow> set_tree (sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)", "y": "by(drule arg_cong[where f=set_mset, OF mset_sift_down]) (simp)", "proof_script_until_now": "lemma set_sift_down: \"braun(Node l a r)\n  \\<Longrightarrow> set_tree(sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma mset_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)\"", "x": "<ISA_PRF> lemma mset_sift_down: \"braun(Node l a r) \\<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow> mset_tree (sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)", "y": "by(induction l a r rule: sift_down.induct) (auto simp: ac_simps Let_def)", "proof_script_until_now": "lemma mset_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma del_left_mset_plus:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'\"", "x": "<ISA_PRF> lemma del_left_mset_plus: \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'", "y": "by (induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits)", "proof_script_until_now": "lemma del_left_mset_plus:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma braun_insert: \"braun t \\<Longrightarrow> braun(insert x t)\"", "x": "<ISA_PRF> lemma braun_insert: \"braun t \\<Longrightarrow> braun(insert x t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> braun (insert x t)", "y": "by(induction t arbitrary: x) auto", "proof_script_until_now": "lemma braun_insert: \"braun t \\<Longrightarrow> braun(insert x t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "problem_name": "lemma size_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> size(sift_down l a r) = size l + size r + 1\"", "x": "<ISA_PRF> lemma size_sift_down: \"braun(Node l a r) \\<Longrightarrow> size(sift_down l a r) = size l + size r + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow> size (sift_down l a r) = size l + size r + 1", "y": "by(induction l a r rule: sift_down.induct) (auto simp: Let_def)", "proof_script_until_now": "lemma size_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> size(sift_down l a r) = size l + size r + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma size_prod_measure[measure_function]:\n  \"is_measure f \\<Longrightarrow> is_measure g \\<Longrightarrow> is_measure (size_prod f g)\"", "x": "<ISA_PRF> lemma size_prod_measure[measure_function]: \"is_measure f \\<Longrightarrow> is_measure g \\<Longrightarrow> is_measure (size_prod f g)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>is_measure f; is_measure g\\<rbrakk> \\<Longrightarrow> is_measure (size_prod f g)", "y": "by (rule is_measure_trivial)", "proof_script_until_now": "lemma size_prod_measure[measure_function]:\n  \"is_measure f \\<Longrightarrow> is_measure g \\<Longrightarrow> is_measure (size_prod f g)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"", "x": "<ISA_PRF> lemma merge_height: \"height (merge l r) \\<le> Suc (max (height l) (height r))\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height (merge l r) \\<le> Suc (max (height l) (height r))", "y": "by (induct rule: merge.induct, auto)", "proof_script_until_now": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"", "x": "<ISA_PRF> lemma merge_height: \"height (merge l r) \\<le> Suc (max (height l) (height r))\" \\n by (induct rule: merge.induct, auto) <ISA_OBS> proof (prove) goal (1 subgoal): 1. height (merge l r) \\<le> height \\<langle>l, x, r\\<rangle>", "y": "using merge_height", "proof_script_until_now": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"<SEP>by (induct rule: merge.induct, auto)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"", "x": "<ISA_PRF> lemma merge_height: \"height (merge l r) \\<le> Suc (max (height l) (height r))\" \\n by (induct rule: merge.induct, auto) \\n using merge_height <ISA_OBS> proof (prove) using this: height (merge ?l ?r) \\<le> Suc (max (height ?l) (height ?r)) goal (1 subgoal): 1. height (merge l r) \\<le> height \\<langle>l, x, r\\<rangle>", "y": "by simp", "proof_script_until_now": "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"<SEP>by (induct rule: merge.induct, auto)<SEP>using merge_height"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"", "x": "<ISA_PRF> lemma height_insert_ge: \"height t \\<le> height (insert x t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height t \\<le> height (insert x t)", "y": "apply (induct t arbitrary: x; simp add: le_max_iff_disj)", "proof_script_until_now": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"", "x": "<ISA_PRF> lemma height_insert_ge: \"height t \\<le> height (insert x t)\" \\n apply (induct t arbitrary: x; simp add: le_max_iff_disj) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>t1 x2 t2 x. \\<lbrakk>\\<And>x. height t1 \\<le> height (insert x t1); \\<And>x. height t2 \\<le> height (insert x t2)\\<rbrakk> \\<Longrightarrow> (x < x2 \\<longrightarrow> height t1 \\<le> height (insert x2 t2) \\<or> height t2 \\<le> height t1) \\<and> (\\<not> x < x2 \\<longrightarrow> height t1 \\<le> height (insert x t2) \\<or> height t2 \\<le> height t1)", "y": "apply (metis less_imp_le_nat less_le_trans not_le_imp_less)", "proof_script_until_now": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"<SEP>apply (induct t arbitrary: x; simp add: le_max_iff_disj)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"", "x": "<ISA_PRF> lemma height_insert_ge: \"height t \\<le> height (insert x t)\" \\n apply (induct t arbitrary: x; simp add: le_max_iff_disj) \\n apply (metis less_imp_le_nat less_le_trans not_le_imp_less) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"<SEP>apply (induct t arbitrary: x; simp add: le_max_iff_disj)<SEP>apply (metis less_imp_le_nat less_le_trans not_le_imp_less)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_log_bound: \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "using t_heap_of_A_bound[of xs] acomplete_if_braun[OF braun_heap_of_A, of xs]", "proof_script_until_now": "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_log_bound: \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\" \\n using t_heap_of_A_bound[of xs] acomplete_if_braun[OF braun_heap_of_A, of xs] <ISA_OBS> proof (prove) using this: t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) acomplete (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "by (simp add: height_acomplete size1_size size_heap_of_A)", "proof_script_until_now": "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\"<SEP>using t_heap_of_A_bound[of xs] acomplete_if_braun[OF braun_heap_of_A, of xs]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "x": "<ISA_PRF> lemma sorted_list_of_B: \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>braun t; heap t\\<rbrakk> \\<Longrightarrow> sorted (list_of_B t)", "y": "apply (induct t rule: measure_induct[where f=size])", "proof_script_until_now": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "x": "<ISA_PRF> lemma sorted_list_of_B: \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> heap y \\<longrightarrow> sorted (list_of_B y); braun x; heap x\\<rbrakk> \\<Longrightarrow> sorted (list_of_B x)", "y": "apply (case_tac x; simp add: list_of_B_braun_simps)", "proof_script_until_now": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"<SEP>apply (induct t rule: measure_induct[where f=size])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "x": "<ISA_PRF> lemma sorted_list_of_B: \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x x21 x22 x23. \\<lbrakk>\\<forall>y. size y < Suc (size x21 + size x23) \\<longrightarrow> braun y \\<longrightarrow> heap y \\<longrightarrow> sorted (list_of_B y); (size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and> braun x21 \\<and> braun x23; (\\<forall>x\\<in>set_tree x21 \\<union> set_tree x23. x22 \\<le> x) \\<and> heap x21 \\<and> heap x23; x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk> \\<Longrightarrow> (\\<forall>x\\<in>set (list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>)). x22 \\<le> x) \\<and> sorted (list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>))", "y": "apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)", "proof_script_until_now": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (case_tac x; simp add: list_of_B_braun_simps)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "x": "<ISA_PRF> lemma sorted_list_of_B: \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) \\n apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x21 x22 x23 xa. \\<lbrakk>\\<forall>y. size y < Suc (size x21 + size x23) \\<longrightarrow> braun y \\<longrightarrow> heap y \\<longrightarrow> sorted (list_of_B y); xa \\<in> set_tree (del_min \\<langle>x21, x22, x23\\<rangle>); size x21 = size x23 \\<or> size x21 = Suc (size x23); \\<forall>x\\<in>set_tree x21 \\<union> set_tree x23. x22 \\<le> x; braun x21; braun x23; heap x21; heap x23\\<rbrakk> \\<Longrightarrow> x22 \\<le> xa", "y": "apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree)", "proof_script_until_now": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (case_tac x; simp add: list_of_B_braun_simps)<SEP>apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "x": "<ISA_PRF> lemma sorted_list_of_B: \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) \\n apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min) \\n apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (case_tac x; simp add: list_of_B_braun_simps)<SEP>apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)<SEP>apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"", "x": "<ISA_PRF> lemma del_left_height: \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>del_left t = (v, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk> \\<Longrightarrow> height t' \\<le> height t", "y": "apply (induct t arbitrary: v t' rule: del_left.induct; simp)", "proof_script_until_now": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"", "x": "<ISA_PRF> lemma del_left_height: \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" \\n apply (induct t arbitrary: v t' rule: del_left.induct; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r vc t'. \\<lbrakk>\\<And>vaa t'. del_left \\<langle>v, va, vb\\<rangle> = (vaa, t') \\<Longrightarrow> height t' \\<le> Suc (max (height v) (height vb)); (case del_left \\<langle>v, va, vb\\<rangle> of (y, l') \\<Rightarrow> (y, \\<langle>r, x, l'\\<rangle>)) = (vc, t')\\<rbrakk> \\<Longrightarrow> height t' \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply (atomize(full), clarsimp split: prod.splits)", "proof_script_until_now": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"<SEP>apply (induct t arbitrary: v t' rule: del_left.induct; simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"", "x": "<ISA_PRF> lemma del_left_height: \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" \\n apply (induct t arbitrary: v t' rule: del_left.induct; simp) \\n apply (atomize(full), clarsimp split: prod.splits) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb r x1 x2. \\<lbrakk>height x2 \\<le> Suc (max (height v) (height vb)); del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk> \\<Longrightarrow> height x2 \\<le> max (Suc (max (height v) (height vb))) (height r)", "y": "apply simp", "proof_script_until_now": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"<SEP>apply (induct t arbitrary: v t' rule: del_left.induct; simp)<SEP>apply (atomize(full), clarsimp split: prod.splits)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"", "x": "<ISA_PRF> lemma del_left_height: \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\" \\n apply (induct t arbitrary: v t' rule: del_left.induct; simp) \\n apply (atomize(full), clarsimp split: prod.splits) \\n apply simp <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"<SEP>apply (induct t arbitrary: v t' rule: del_left.induct; simp)<SEP>apply (atomize(full), clarsimp split: prod.splits)<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd_tup:\n  \"heapify n xs = (t, ys) \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow> ys = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd_tup: \"heapify n xs = (t, ys) \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow> ys = drop n xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heapify n xs = (t, ys); n \\<le> length xs\\<rbrakk> \\<Longrightarrow> ys = drop n xs", "y": "by (drule heapify_snd, simp)", "proof_script_until_now": "lemma heapify_snd_tup:\n  \"heapify n xs = (t, ys) \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow> ys = drop n xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_tree_merge[simp]:\n  \"mset_tree (merge l r) = mset_tree l + mset_tree r\"", "x": "<ISA_PRF> lemma mset_tree_merge[simp]: \"mset_tree (merge l r) = mset_tree l + mset_tree r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (merge l r) = mset_tree l + mset_tree r", "y": "by (induct l r rule: merge.induct; simp)", "proof_script_until_now": "lemma mset_tree_merge[simp]:\n  \"mset_tree (merge l r) = mset_tree l + mset_tree r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_height_r_le:\n  \"braun (Node l x r) \\<Longrightarrow> height r \\<le> height l\"", "x": "<ISA_PRF> lemma braun_height_r_le: \"braun (Node l x r) \\<Longrightarrow> height r \\<le> height l\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow> height r \\<le> height l", "y": "by (rule acomplete_optimal, auto intro: acomplete_if_braun)", "proof_script_until_now": "lemma braun_height_r_le:\n  \"braun (Node l x r) \\<Longrightarrow> height r \\<le> height l\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))\"", "x": "<ISA_PRF> lemma braun_heapify: \"n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))", "y": "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "proof_script_until_now": "lemma braun_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sorted_list_of_A:\n  \"heap t \\<Longrightarrow> sorted (list_of_A t)\"", "x": "<ISA_PRF> lemma sorted_list_of_A: \"heap t \\<Longrightarrow> sorted (list_of_A t)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap t \\<Longrightarrow> sorted (list_of_A t)", "y": "by (induct t rule: list_of_A.induct; simp add: merge_heap)", "proof_script_until_now": "lemma sorted_list_of_A:\n  \"heap t \\<Longrightarrow> sorted (list_of_A t)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\"", "x": "<ISA_PRF> lemma braun_height_node_eq: assumes b: \"braun (Node l x r)\" shows \"height (Node l x r) = Suc (height l)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height \\<langle>l, x, r\\<rangle> = Suc (height l)", "y": "using b braun_height_r_le[OF b]", "proof_script_until_now": "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\"", "x": "<ISA_PRF> lemma braun_height_node_eq: assumes b: \"braun (Node l x r)\" shows \"height (Node l x r) = Suc (height l)\" \\n using b braun_height_r_le[OF b] <ISA_OBS> proof (prove) using this: braun \\<langle>l, x, r\\<rangle> height r \\<le> height l goal (1 subgoal): 1. height \\<langle>l, x, r\\<rangle> = Suc (height l)", "y": "by (auto simp add: max_def)", "proof_script_until_now": "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\"<SEP>using b braun_height_r_le[OF b]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_tree_heap_of_A: \"mset_tree (heap_of_A xs) = mset xs\"", "x": "<ISA_PRF> lemma mset_tree_heap_of_A: \"mset_tree (heap_of_A xs) = mset xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (heap_of_A xs) = mset xs", "y": "by(induction xs)(simp_all add: mset_insert)", "proof_script_until_now": "lemma mset_tree_heap_of_A: \"mset_tree (heap_of_A xs) = mset xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sortedA: \"sorted (list_of_A (heap_of_A xs))\"", "x": "<ISA_PRF> lemma sortedA: \"sorted (list_of_A (heap_of_A xs))\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. sorted (list_of_A (heap_of_A xs))", "y": "by (simp add: heap_heap_of_A sorted_list_of_A)", "proof_script_until_now": "lemma sortedA: \"sorted (list_of_A (heap_of_A xs))\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_log_bound: \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nat \\<lceil>log 2 (real (size t + 1))\\<rceil> * size t", "y": "using t_list_of_A_bound[of t]", "proof_script_until_now": "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_log_bound: \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\" \\n using t_list_of_A_bound[of t] <ISA_OBS> proof (prove) using this: t_list_of_A t \\<le> 2 * height t * size t goal (1 subgoal): 1. braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nat \\<lceil>log 2 (real (size t + 1))\\<rceil> * size t", "y": "by (simp add: height_acomplete acomplete_if_braun size1_size)", "proof_script_until_now": "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\"<SEP>using t_list_of_A_bound[of t]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"", "x": "<ISA_PRF> lemma mset_list_of_B: \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t", "y": "apply (induct t rule: measure_induct[where f=size])", "proof_script_until_now": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"", "x": "<ISA_PRF> lemma mset_list_of_B: \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" \\n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> mset (list_of_B y) = mset_tree y; braun x\\<rbrakk> \\<Longrightarrow> mset (list_of_B x) = mset_tree x", "y": "apply (case_tac x; simp add: list_of_B_braun_simps)", "proof_script_until_now": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"<SEP>apply (induct t rule: measure_induct[where f=size])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"", "x": "<ISA_PRF> lemma mset_list_of_B: \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x x21 x22 x23. \\<lbrakk>\\<forall>y. size y < Suc (size x21 + size x23) \\<longrightarrow> braun y \\<longrightarrow> mset (list_of_B y) = mset_tree y; (size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and> braun x21 \\<and> braun x23; x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk> \\<Longrightarrow> mset (list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>)) = mset_tree x21 + mset_tree x23", "y": "apply (simp add: size_del_min braun_del_min mset_del_min)", "proof_script_until_now": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (case_tac x; simp add: list_of_B_braun_simps)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"", "x": "<ISA_PRF> lemma mset_list_of_B: \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (case_tac x; simp add: list_of_B_braun_simps) \\n apply (simp add: size_del_min braun_del_min mset_del_min) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (case_tac x; simp add: list_of_B_braun_simps)<SEP>apply (simp add: size_del_min braun_del_min mset_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"", "x": "<ISA_PRF> lemma t_del_left_bound: \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> t_del_left t \\<le> 2 * height t", "y": "apply (induct rule: t_del_left.induct; clarsimp)", "proof_script_until_now": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"", "x": "<ISA_PRF> lemma t_del_left_bound: \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" \\n apply (induct rule: t_del_left.induct; clarsimp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb r. (\\<And>a b xb y. \\<lbrakk>(a, b) = del_left \\<langle>v, va, vb\\<rangle>; (xb, y) = del_left \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> \\<le> Suc (Suc (2 * max (height v) (height vb)))) \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> \\<le> 2 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (atomize(full); clarsimp simp: prod_eq_iff)", "proof_script_until_now": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"<SEP>apply (induct rule: t_del_left.induct; clarsimp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"", "x": "<ISA_PRF> lemma t_del_left_bound: \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" \\n apply (induct rule: t_del_left.induct; clarsimp) \\n apply (atomize(full); clarsimp simp: prod_eq_iff) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb r. t_del_left \\<langle>v, va, vb\\<rangle> \\<le> Suc (Suc (2 * max (height v) (height vb))) \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> \\<le> 2 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (simp add: nat_mult_max_right le_max_iff_disj)", "proof_script_until_now": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"<SEP>apply (induct rule: t_del_left.induct; clarsimp)<SEP>apply (atomize(full); clarsimp simp: prod_eq_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"", "x": "<ISA_PRF> lemma t_del_left_bound: \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\" \\n apply (induct rule: t_del_left.induct; clarsimp) \\n apply (atomize(full); clarsimp simp: prod_eq_iff) \\n apply (simp add: nat_mult_max_right le_max_iff_disj) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"<SEP>apply (induct rule: t_del_left.induct; clarsimp)<SEP>apply (atomize(full); clarsimp simp: prod_eq_iff)<SEP>apply (simp add: nat_mult_max_right le_max_iff_disj)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>n \\<le> length xs; heapify n xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)", "y": "proof (induct n xs arbitrary: t ys rule: heapify.induct)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) <ISA_OBS> proof (state) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "case (2 n x xs)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) <ISA_OBS> proof (state) this: \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (?t, ?ys)\\<rbrakk> \\<Longrightarrow> size ?t = Suc n div 2 \\<and> heap ?t \\<and> braun ?t \\<and> mset_tree ?t = mset (take (Suc n div 2) xs) \\<lbrakk>?xa = heapify (Suc n div 2) xs; (?xb, ?y) = ?xa; n div 2 \\<le> length ?y; heapify (n div 2) ?y = (?t, ?ys)\\<rbrakk> \\<Longrightarrow> size ?t = n div 2 \\<and> heap ?t \\<and> braun ?t \\<and> mset_tree ?t = mset (take (n div 2) ?y) Suc n \\<le> length (x # xs) heapify (Suc n) (x # xs) = (t, ys) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "note len = \"2.prems\"(1)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) <ISA_OBS> proof (state) this: Suc n \\<le> length (x # xs) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\\<And>t1 ys1. heapify (Suc n div 2) xs = (t1, ys1) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "y": "by (simp add: prod_eq_iff)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (Suc n div 2) xs = (t1, ys1) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\\<And>t2 ys2. heapify (n div 2) ys1 = (t2, ys2) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "y": "by (simp add: prod_eq_iff)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (n div 2) ys1 = (t2, ys2) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "from len", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len <ISA_OBS> proof (chain) picking this: Suc n \\<le> length (x # xs)", "y": "have le1: \"Suc n div 2 \\<le> length xs\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" <ISA_OBS> proof (prove) using this: Suc n \\<le> length (x # xs) goal (1 subgoal): 1. Suc n div 2 \\<le> length xs", "y": "by simp", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp <ISA_OBS> proof (state) this: Suc n div 2 \\<le> length xs goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "note ys1 = heapify_snd_tup[OF h1 le1]", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] <ISA_OBS> proof (state) this: ys1 = drop (Suc n div 2) xs goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "from len", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len <ISA_OBS> proof (chain) picking this: Suc n \\<le> length (x # xs)", "y": "have le2: \"n div 2 \\<le> length ys1\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" <ISA_OBS> proof (prove) using this: Suc n \\<le> length (x # xs) goal (1 subgoal): 1. n div 2 \\<le> length ys1", "y": "by (simp add: ys1)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) <ISA_OBS> proof (state) this: n div 2 \\<le> length ys1 goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] <ISA_OBS> proof (state) this: size t1 = Suc n div 2 \\<and> heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \\<and> heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "hence braun: \"braun (Node t1 x t2)\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" <ISA_OBS> proof (prove) using this: size t1 = Suc n div 2 \\<and> heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \\<and> heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1) goal (1 subgoal): 1. braun \\<langle>t1, x, t2\\<rangle>", "y": "by (simp, linarith)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) <ISA_OBS> proof (state) this: braun \\<langle>t1, x, t2\\<rangle> goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "have eq: \"n div 2 + Suc n div 2 = n\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n div 2 + Suc n div 2 = n", "y": "by simp", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp <ISA_OBS> proof (state) this: n div 2 + Suc n div 2 = n goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)", "y": "apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take (Suc n div 2) (take n xs)) + mset (drop (Suc n div 2) (take n xs))", "y": "apply (simp add: take_drop min_absorb1 le1 eq ys1)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done <ISA_OBS> proof (state) this: mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs) goal (3 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>n x xs t ys. \\<lbrakk>\\<And>t ys. \\<lbrakk>Suc n div 2 \\<le> length xs; heapify (Suc n div 2) xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n div 2) xs); \\<And>xa xb y t ys. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = n div 2 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (n div 2) y); Suc n \\<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "from \"2.prems\" app_hyps msets", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets <ISA_OBS> proof (chain) picking this: Suc n \\<le> length (x # xs) heapify (Suc n) (x # xs) = (t, ys) size t1 = Suc n div 2 \\<and> heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \\<and> heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1) mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)", "y": "show ?case", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done<SEP>from \"2.prems\" app_hyps msets"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case <ISA_OBS> proof (prove) using this: Suc n \\<le> length (x # xs) heapify (Suc n) (x # xs) = (t, ys) size t1 = Suc n div 2 \\<and> heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \\<and> heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1) mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs) goal (1 subgoal): 1. size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs))", "y": "apply (clarsimp simp: h1 h2 le2)", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done<SEP>from \"2.prems\" app_hyps msets<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>n \\<le> length xs; mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs); ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2; size t2 = n div 2; heap t1; heap t2; braun t1; mset_tree t1 = mset (take (Suc n div 2) xs); braun t2; mset_tree t2 = mset (take (n div 2) ys1)\\<rbrakk> \\<Longrightarrow> size (sift_down t1 x t2) = Suc n \\<and> heap (sift_down t1 x t2) \\<and> braun (sift_down t1 x t2) \\<and> mset_tree (sift_down t1 x t2) = add_mset x (mset (take n xs))", "y": "apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun])", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done<SEP>from \"2.prems\" app_hyps msets<SEP>show ?case<SEP>apply (clarsimp simp: h1 h2 le2)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) \\n apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>n \\<le> length xs; mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs); ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2; size t2 = n div 2; heap t1; heap t2; braun t1; mset_tree t1 = mset (take (Suc n div 2) xs); braun t2; mset_tree t2 = mset (take (n div 2) ys1)\\<rbrakk> \\<Longrightarrow> Suc n div 2 + n div 2 = n \\<and> heap (sift_down t1 x t2)", "y": "apply (simp add: heap_sift_down[OF braun])", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done<SEP>from \"2.prems\" app_hyps msets<SEP>show ?case<SEP>apply (clarsimp simp: h1 h2 le2)<SEP>apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) \\n apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun]) \\n apply (simp add: heap_sift_down[OF braun]) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done<SEP>from \"2.prems\" app_hyps msets<SEP>show ?case<SEP>apply (clarsimp simp: h1 h2 le2)<SEP>apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun])<SEP>apply (simp add: heap_sift_down[OF braun])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "x": "<ISA_PRF> lemma heapify_correct: \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow> size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\" \\n proof (induct n xs arbitrary: t ys rule: heapify.induct) \\n case (2 n x xs) \\n note len = \"2.prems\"(1) \\n obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\" \\n by (simp add: prod_eq_iff) \\n obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\" \\n by (simp add: prod_eq_iff) \\n from len \\n have le1: \"Suc n div 2 \\<le> length xs\" \\n by simp \\n note ys1 = heapify_snd_tup[OF h1 le1] \\n from len \\n have le2: \"n div 2 \\<le> length ys1\" \\n by (simp add: ys1) \\n note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \\n hence braun: \"braun (Node t1 x t2)\" \\n by (simp, linarith) \\n have eq: \"n div 2 + Suc n div 2 = n\" \\n by simp \\n have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\" \\n apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append) \\n apply (simp add: take_drop min_absorb1 le1 eq ys1) \\n done \\n from \"2.prems\" app_hyps msets \\n show ?case \\n apply (clarsimp simp: h1 h2 le2) \\n apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun]) \\n apply (simp add: heap_sift_down[OF braun]) \\n done <ISA_OBS> proof (state) this: size t = Suc n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs)) goal (2 subgoals): 1. \\<And>xs t ys. \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = 0 \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take 0 xs) 2. \\<And>v t ys. \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk> \\<Longrightarrow> size t = Suc v \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc v) [])", "y": "qed simp_all", "proof_script_until_now": "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"<SEP>proof (induct n xs arbitrary: t ys rule: heapify.induct)<SEP>case (2 n x xs)<SEP>note len = \"2.prems\"(1)<SEP>obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\"<SEP>by (simp add: prod_eq_iff)<SEP>obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\"<SEP>by (simp add: prod_eq_iff)<SEP>from len<SEP>have le1: \"Suc n div 2 \\<le> length xs\"<SEP>by simp<SEP>note ys1 = heapify_snd_tup[OF h1 le1]<SEP>from len<SEP>have le2: \"n div 2 \\<le> length ys1\"<SEP>by (simp add: ys1)<SEP>note app_hyps = \"2.hyps\"(1)[OF le1 h1] \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]<SEP>hence braun: \"braun (Node t1 x t2)\"<SEP>by (simp, linarith)<SEP>have eq: \"n div 2 + Suc n div 2 = n\"<SEP>by simp<SEP>have msets: \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\"<SEP>apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"], subst mset_append)<SEP>apply (simp add: take_drop min_absorb1 le1 eq ys1)<SEP>done<SEP>from \"2.prems\" app_hyps msets<SEP>show ?case<SEP>apply (clarsimp simp: h1 h2 le2)<SEP>apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun])<SEP>apply (simp add: heap_sift_down[OF braun])<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>braun t; height t \\<le> n\\<rbrakk> \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t", "y": "apply (induct t rule: measure_induct[where f=size])", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> height y \\<le> n \\<longrightarrow> t_list_of_B y \\<le> 3 * (n + 1) * size y; braun x; height x \\<le> n\\<rbrakk> \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "y": "apply (drule_tac x=\"del_min x\" in spec)", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>braun x; height x \\<le> n; size (del_min x) < size x \\<longrightarrow> braun (del_min x) \\<longrightarrow> height (del_min x) \\<le> n \\<longrightarrow> t_list_of_B (del_min x) \\<le> 3 * (n + 1) * size (del_min x)\\<rbrakk> \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "y": "apply (frule del_min_height)", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>braun x; height x \\<le> n; size (del_min x) < size x \\<longrightarrow> braun (del_min x) \\<longrightarrow> height (del_min x) \\<le> n \\<longrightarrow> t_list_of_B (del_min x) \\<le> 3 * (n + 1) * size (del_min x); height (del_min x) \\<le> height x\\<rbrakk> \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "y": "apply (case_tac x; simp add: t_list_of_B_braun_simps)", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x x21 x22 x23. \\<lbrakk>(size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and> braun x21 \\<and> braun x23; Suc (max (height x21) (height x23)) \\<le> n; size (del_min \\<langle>x21, x22, x23\\<rangle>) < Suc (size x21 + size x23) \\<longrightarrow> braun (del_min \\<langle>x21, x22, x23\\<rangle>) \\<longrightarrow> t_list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>) \\<le> (3 + 3 * n) * size (del_min \\<langle>x21, x22, x23\\<rangle>); height (del_min \\<langle>x21, x22, x23\\<rangle>) \\<le> Suc (max (height x21) (height x23)); x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk> \\<Longrightarrow> t_del_min \\<langle>x21, x22, x23\\<rangle> + t_list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>) \\<le> Suc (Suc (3 * n + (3 + 3 * n) * (size x21 + size x23)))", "y": "apply (rename_tac l x' r)", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)<SEP>apply (case_tac x; simp add: t_list_of_B_braun_simps)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x l x' r. \\<lbrakk>(size l = size r \\<or> size l = Suc (size r)) \\<and> braun l \\<and> braun r; Suc (max (height l) (height r)) \\<le> n; size (del_min \\<langle>l, x', r\\<rangle>) < Suc (size l + size r) \\<longrightarrow> braun (del_min \\<langle>l, x', r\\<rangle>) \\<longrightarrow> t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> (3 + 3 * n) * size (del_min \\<langle>l, x', r\\<rangle>); height (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (max (height l) (height r)); x = \\<langle>l, x', r\\<rangle>\\<rbrakk> \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> + t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))", "y": "apply (clarsimp simp: braun_del_min size_del_min)", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)<SEP>apply (case_tac x; simp add: t_list_of_B_braun_simps)<SEP>apply (rename_tac l x' r)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l x' r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> (3 + 3 * n) * (size l + size r); height (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (max (height l) (height r)); size l = size r \\<or> size l = Suc (size r); braun l; braun r\\<rbrakk> \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> + t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))", "y": "apply (rule order_trans)", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)<SEP>apply (case_tac x; simp add: t_list_of_B_braun_simps)<SEP>apply (rename_tac l x' r)<SEP>apply (clarsimp simp: braun_del_min size_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) \\n apply (rule order_trans) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>l x' r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> (3 + 3 * n) * (size l + size r); height (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (max (height l) (height r)); size l = size r \\<or> size l = Suc (size r); braun l; braun r\\<rbrakk> \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> + t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> ?y21 l x' r 2. \\<And>l x' r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> (3 + 3 * n) * (size l + size r); height (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (max (height l) (height r)); size l = size r \\<or> size l = Suc (size r); braun l; braun r\\<rbrakk> \\<Longrightarrow> ?y21 l x' r \\<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))", "y": "apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)<SEP>apply (case_tac x; simp add: t_list_of_B_braun_simps)<SEP>apply (rename_tac l x' r)<SEP>apply (clarsimp simp: braun_del_min size_del_min)<SEP>apply (rule order_trans)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1] <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l x' r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_B (del_min \\<langle>l, x', r\\<rangle>) \\<le> (3 + 3 * n) * (size l + size r); height (del_min \\<langle>l, x', r\\<rangle>) \\<le> Suc (max (height l) (height r)); size l = size r \\<or> size l = Suc (size r); braun l; braun r\\<rbrakk> \\<Longrightarrow> 3 * height \\<langle>l, x', r\\<rangle> + (3 + 3 * n) * (size l + size r) \\<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))", "y": "apply simp", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)<SEP>apply (case_tac x; simp add: t_list_of_B_braun_simps)<SEP>apply (rename_tac l x' r)<SEP>apply (clarsimp simp: braun_del_min size_del_min)<SEP>apply (rule order_trans)<SEP>apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_induct: \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (drule_tac x=\"del_min x\" in spec) \\n apply (frule del_min_height) \\n apply (case_tac x; simp add: t_list_of_B_braun_simps) \\n apply (rename_tac l x' r) \\n apply (clarsimp simp: braun_del_min size_del_min) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1] \\n apply simp <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (drule_tac x=\"del_min x\" in spec)<SEP>apply (frule del_min_height)<SEP>apply (case_tac x; simp add: t_list_of_B_braun_simps)<SEP>apply (rename_tac l x' r)<SEP>apply (clarsimp simp: braun_del_min size_del_min)<SEP>apply (rule order_trans)<SEP>apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma msetA: \"mset (list_of_A (heap_of_A xs)) = mset xs\"", "x": "<ISA_PRF> lemma msetA: \"mset (list_of_A (heap_of_A xs)) = mset xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (list_of_A (heap_of_A xs)) = mset xs", "y": "by (simp add: mset_tree_heap_of_A)", "proof_script_until_now": "lemma msetA: \"mset (list_of_A (heap_of_A xs)) = mset xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_merge_height:\n  \"t_merge l r \\<le> max (height l) (height r)\"", "x": "<ISA_PRF> lemma t_merge_height: \"t_merge l r \\<le> max (height l) (height r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_merge l r \\<le> max (height l) (height r)", "y": "by (induct rule: t_merge.induct, auto)", "proof_script_until_now": "lemma t_merge_height:\n  \"t_merge l r \\<le> max (height l) (height r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t", "y": "apply (induct rule: t_list_of_A.induct)", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) <ISA_OBS> proof (prove) goal (2 subgoals): 1. height \\<langle>\\<rangle> \\<le> n \\<Longrightarrow> t_list_of_A \\<langle>\\<rangle> \\<le> 2 * n * size \\<langle>\\<rangle> 2. \\<And>l a r. \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow> t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r); height \\<langle>l, a, r\\<rangle> \\<le> n\\<rbrakk> \\<Longrightarrow> t_list_of_A \\<langle>l, a, r\\<rangle> \\<le> 2 * n * size \\<langle>l, a, r\\<rangle>", "y": "apply simp", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l a r. \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow> t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r); height \\<langle>l, a, r\\<rangle> \\<le> n\\<rbrakk> \\<Longrightarrow> t_list_of_A \\<langle>l, a, r\\<rangle> \\<le> 2 * n * size \\<langle>l, a, r\\<rangle>", "y": "apply simp", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l r. \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow> t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r); Suc (max (height l) (height r)) \\<le> n\\<rbrakk> \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \\<le> 2 * n + 2 * n * (size l + size r)", "y": "apply (drule meta_mp)", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>l r. Suc (max (height l) (height r)) \\<le> n \\<Longrightarrow> height (merge l r) \\<le> n 2. \\<And>l r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk> \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \\<le> 2 * n + 2 * n * (size l + size r)", "y": "apply (rule order_trans, rule merge_height)", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp<SEP>apply (drule meta_mp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>l r. Suc (max (height l) (height r)) \\<le> n \\<Longrightarrow> Suc (max (height l) (height r)) \\<le> n 2. \\<And>l r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk> \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \\<le> 2 * n + 2 * n * (size l + size r)", "y": "apply simp", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp<SEP>apply (drule meta_mp)<SEP>apply (rule order_trans, rule merge_height)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk> \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \\<le> 2 * n + 2 * n * (size l + size r)", "y": "apply (simp add: merge_size)", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp<SEP>apply (drule meta_mp)<SEP>apply (rule order_trans, rule merge_height)<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp \\n apply (simp add: merge_size) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_A (merge l r) \\<le> 2 * n * (size l + size r)\\<rbrakk> \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \\<le> 2 * n + 2 * n * (size l + size r)", "y": "apply (cut_tac l=l and r=r in t_merge_height)", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp<SEP>apply (drule meta_mp)<SEP>apply (rule order_trans, rule merge_height)<SEP>apply simp<SEP>apply (simp add: merge_size)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp \\n apply (simp add: merge_size) \\n apply (cut_tac l=l and r=r in t_merge_height) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>l r. \\<lbrakk>Suc (max (height l) (height r)) \\<le> n; t_list_of_A (merge l r) \\<le> 2 * n * (size l + size r); t_merge l r \\<le> max (height l) (height r)\\<rbrakk> \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \\<le> 2 * n + 2 * n * (size l + size r)", "y": "apply linarith", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp<SEP>apply (drule meta_mp)<SEP>apply (rule order_trans, rule merge_height)<SEP>apply simp<SEP>apply (simp add: merge_size)<SEP>apply (cut_tac l=l and r=r in t_merge_height)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_induct: \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\" \\n apply (induct rule: t_list_of_A.induct) \\n apply simp \\n apply simp \\n apply (drule meta_mp) \\n apply (rule order_trans, rule merge_height) \\n apply simp \\n apply (simp add: merge_size) \\n apply (cut_tac l=l and r=r in t_merge_height) \\n apply linarith <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"<SEP>apply (induct rule: t_list_of_A.induct)<SEP>apply simp<SEP>apply simp<SEP>apply (drule meta_mp)<SEP>apply (rule order_trans, rule merge_height)<SEP>apply simp<SEP>apply (simp add: merge_size)<SEP>apply (cut_tac l=l and r=r in t_merge_height)<SEP>apply linarith"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)", "y": "proof (induct xs)", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) <ISA_OBS> proof (state) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "case (Cons x xs)", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) <ISA_OBS> proof (state) this: t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" <ISA_OBS> proof (state) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "have \"?lhs \\<le> ?lhs\"", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs", "y": "by simp", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp <ISA_OBS> proof (state) this: t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "also", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also <ISA_OBS> proof (state) this: t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "note Cons", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons <ISA_OBS> proof (state) this: t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "also", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also <ISA_OBS> proof (state) this: t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "note height_insert_ge[of \"heap_of_A xs\" x]", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] <ISA_OBS> proof (state) this: height (heap_of_A xs) \\<le> height (insert x (heap_of_A xs)) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "also", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also <ISA_OBS> proof (state) this: height (heap_of_A xs) \\<le> height (insert x (heap_of_A xs)) goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "note t_insert_height[of x \"heap_of_A xs\"]", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] <ISA_OBS> proof (state) this: t_insert x (heap_of_A xs) \\<le> height (heap_of_A xs) + 1 goal (2 subgoals): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1) 2. \\<And>a xs. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow> t_heap_of_A (a # xs) \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "y": "finally", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally <ISA_OBS> proof (chain) picking this: \\<lbrakk>\\<And>xa y. xa \\<le> y \\<Longrightarrow> t_insert x (heap_of_A xs) + xa \\<le> t_insert x (heap_of_A xs) + y; \\<And>xa y. xa \\<le> y \\<Longrightarrow> t_insert x (heap_of_A xs) + length xs * (xa + 1) \\<le> t_insert x (heap_of_A xs) + length xs * (y + 1); \\<And>xa y. xa \\<le> y \\<Longrightarrow> xa + length xs * (height (insert x (heap_of_A xs)) + 1) \\<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\\<rbrakk> \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> height (heap_of_A xs) + 1 + length xs * (height (insert x (heap_of_A xs)) + 1)", "y": "show ?case", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]<SEP>finally"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case <ISA_OBS> proof (prove) using this: \\<lbrakk>\\<And>xa y. xa \\<le> y \\<Longrightarrow> t_insert x (heap_of_A xs) + xa \\<le> t_insert x (heap_of_A xs) + y; \\<And>xa y. xa \\<le> y \\<Longrightarrow> t_insert x (heap_of_A xs) + length xs * (xa + 1) \\<le> t_insert x (heap_of_A xs) + length xs * (y + 1); \\<And>xa y. xa \\<le> y \\<Longrightarrow> xa + length xs * (height (insert x (heap_of_A xs)) + 1) \\<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\\<rbrakk> \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> height (heap_of_A xs) + 1 + length xs * (height (insert x (heap_of_A xs)) + 1) goal (1 subgoal): 1. t_heap_of_A (x # xs) \\<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1)", "y": "apply simp", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]<SEP>finally<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> Suc (height (heap_of_A xs) + (length xs + length xs * height (insert x (heap_of_A xs)))) \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs \\<le> Suc (length xs + (height (insert x (heap_of_A xs)) + length xs * height (insert x (heap_of_A xs))))", "y": "apply (erule order_trans)", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]<SEP>finally<SEP>show ?case<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp \\n apply (erule order_trans) <ISA_OBS> proof (prove) goal (1 subgoal): 1. Suc (height (heap_of_A xs) + (length xs + length xs * height (insert x (heap_of_A xs)))) \\<le> Suc (length xs + (height (insert x (heap_of_A xs)) + length xs * height (insert x (heap_of_A xs))))", "y": "apply (simp add: height_insert_ge)", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]<SEP>finally<SEP>show ?case<SEP>apply simp<SEP>apply (erule order_trans)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp \\n apply (erule order_trans) \\n apply (simp add: height_insert_ge) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]<SEP>finally<SEP>show ?case<SEP>apply simp<SEP>apply (erule order_trans)<SEP>apply (simp add: height_insert_ge)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "x": "<ISA_PRF> lemma t_heap_of_A_bound: \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\" \\n proof (induct xs) \\n case (Cons x xs) \\n let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\" \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note Cons \\n also \\n note height_insert_ge[of \"heap_of_A xs\" x] \\n also \\n note t_insert_height[of x \"heap_of_A xs\"] \\n finally \\n show ?case \\n apply simp \\n apply (erule order_trans) \\n apply (simp add: height_insert_ge) \\n done <ISA_OBS> proof (state) this: t_heap_of_A (x # xs) \\<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1) goal (1 subgoal): 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)", "y": "qed simp_all", "proof_script_until_now": "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"<SEP>proof (induct xs)<SEP>case (Cons x xs)<SEP>let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\"<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note Cons<SEP>also<SEP>note height_insert_ge[of \"heap_of_A xs\" x]<SEP>also<SEP>note t_insert_height[of x \"heap_of_A xs\"]<SEP>finally<SEP>show ?case<SEP>apply simp<SEP>apply (erule order_trans)<SEP>apply (simp add: height_insert_ge)<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"", "x": "<ISA_PRF> lemma list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> list_of_B_dom t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> list_of_B_dom t", "y": "apply (induct t rule: measure_induct[where f=size])", "proof_script_until_now": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"", "x": "<ISA_PRF> lemma list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> list_of_B_dom y; braun x\\<rbrakk> \\<Longrightarrow> list_of_B_dom x", "y": "apply (rule accpI, erule list_of_B_rel.cases)", "proof_script_until_now": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"<SEP>apply (induct t rule: measure_induct[where f=size])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"", "x": "<ISA_PRF> lemma list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule list_of_B_rel.cases) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x y l a r. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> list_of_B_dom y; braun x; y = del_min \\<langle>l, a, r\\<rangle>; x = \\<langle>l, a, r\\<rangle>\\<rbrakk> \\<Longrightarrow> list_of_B_dom y", "y": "apply (clarsimp simp: size_del_min braun_del_min)", "proof_script_until_now": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (rule accpI, erule list_of_B_rel.cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"", "x": "<ISA_PRF> lemma list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule list_of_B_rel.cases) \\n apply (clarsimp simp: size_del_min braun_del_min) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (rule accpI, erule list_of_B_rel.cases)<SEP>apply (clarsimp simp: size_del_min braun_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heap_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))\"", "x": "<ISA_PRF> lemma heap_heapify: \"n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))", "y": "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "proof_script_until_now": "lemma heap_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_list_of_A[simp]:\n  \"mset (list_of_A t) = mset_tree t\"", "x": "<ISA_PRF> lemma mset_list_of_A[simp]: \"mset (list_of_A t) = mset_tree t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (list_of_A t) = mset_tree t", "y": "by (induct t rule: list_of_A.induct; simp)", "proof_script_until_now": "lemma mset_list_of_A[simp]:\n  \"mset (list_of_A t) = mset_tree t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> height (del_min t) \\<le> height t", "y": "apply (cases t rule: del_min.cases; simp)", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r. \\<lbrakk>(Suc (size v + size vb) = size r \\<or> size v + size vb = size r) \\<and> (size v = size vb \\<or> size v = Suc (size vb)) \\<and> braun v \\<and> braun vb \\<and> braun r; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> height (case del_left \\<langle>v, va, vb\\<rangle> of (x, xa) \\<Rightarrow> sift_down r x xa) \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply (clarsimp split: prod.split)", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size v + size vb) = size r \\<or> size v + size vb = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk> \\<Longrightarrow> height (sift_down r x1 x2) \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply (frule del_left_braun, simp+)", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size v + size vb) = size r \\<or> size v + size vb = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2\\<rbrakk> \\<Longrightarrow> height (sift_down r x1 x2) \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply (frule del_left_size, simp+)", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2\\<rbrakk> \\<Longrightarrow> height (sift_down r x1 x2) \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply (drule del_left_height)", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (drule del_left_height) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; braun x2; size v + size vb = size x2\\<rbrakk> \\<Longrightarrow> \\<langle>v, va, vb\\<rangle> \\<noteq> \\<langle>\\<rangle> 2. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> height (sift_down r x1 x2) \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply simp", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (drule del_left_height)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (drule del_left_height) \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> height (sift_down r x1 x2) \\<le> Suc (max (Suc (max (height v) (height vb))) (height r))", "y": "apply (rule order_trans, rule sift_down_height, auto)", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (drule del_left_height)<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "x": "<ISA_PRF> lemma del_min_height: \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\" \\n apply (cases t rule: del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (drule del_left_height) \\n apply simp \\n apply (rule order_trans, rule sift_down_height, auto) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"<SEP>apply (cases t rule: del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (drule del_left_height)<SEP>apply simp<SEP>apply (rule order_trans, rule sift_down_height, auto)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_heap_of_A: \"braun (heap_of_A xs)\"", "x": "<ISA_PRF> lemma braun_heap_of_A: \"braun (heap_of_A xs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun (heap_of_A xs)", "y": "by(induction xs)(simp_all add: braun_insert)", "proof_script_until_now": "lemma braun_heap_of_A: \"braun (heap_of_A xs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma set_list_of_B:\n  \"braun t \\<Longrightarrow> set (list_of_B t) = set_tree t\"", "x": "<ISA_PRF> lemma set_list_of_B: \"braun t \\<Longrightarrow> set (list_of_B t) = set_tree t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> set (list_of_B t) = set_tree t", "y": "by (simp only: set_mset_mset[symmetric] mset_list_of_B, simp)", "proof_script_until_now": "lemma set_list_of_B:\n  \"braun t \\<Longrightarrow> set (list_of_B t) = set_tree t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\"", "x": "<ISA_PRF> lemma braun_height_l_le: assumes b: \"braun (Node l x r)\" shows \"height l \\<le> Suc (height r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height l \\<le> Suc (height r)", "y": "using b acomplete_if_braun[OF b] min_height_le_height[of r]", "proof_script_until_now": "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\"", "x": "<ISA_PRF> lemma braun_height_l_le: assumes b: \"braun (Node l x r)\" shows \"height l \\<le> Suc (height r)\" \\n using b acomplete_if_braun[OF b] min_height_le_height[of r] <ISA_OBS> proof (prove) using this: braun \\<langle>l, x, r\\<rangle> acomplete \\<langle>l, x, r\\<rangle> min_height r \\<le> height r goal (1 subgoal): 1. height l \\<le> Suc (height r)", "y": "by (simp add: acomplete_def)", "proof_script_until_now": "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\"<SEP>using b acomplete_if_braun[OF b] min_height_le_height[of r]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\"", "x": "<ISA_PRF> lemma size_heap_of_A: \"size (heap_of_A xs) = length xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (heap_of_A xs) = length xs", "y": "using arg_cong[OF mset_tree_heap_of_A, of size xs]", "proof_script_until_now": "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\"", "x": "<ISA_PRF> lemma size_heap_of_A: \"size (heap_of_A xs) = length xs\" \\n using arg_cong[OF mset_tree_heap_of_A, of size xs] <ISA_OBS> proof (prove) using this: size (mset_tree (heap_of_A xs)) = size (mset xs) goal (1 subgoal): 1. size (heap_of_A xs) = length xs", "y": "by simp", "proof_script_until_now": "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\"<SEP>using arg_cong[OF mset_tree_heap_of_A, of size xs]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t", "y": "apply (cases t rule: t_del_min.cases; simp)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r. \\<lbrakk>(Suc (size v + size vb) = size r \\<or> size v + size vb = size r) \\<and> (size v = size vb \\<or> size v = Suc (size vb)) \\<and> braun v \\<and> braun vb \\<and> braun r; t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk> \\<Longrightarrow> (case del_left \\<langle>v, va, vb\\<rangle> of (y, l') \\<Rightarrow> t_del_left \\<langle>v, va, vb\\<rangle> + t_sift_down r y l') \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (clarsimp split: prod.split)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size v + size vb) = size r \\<or> size v + size vb = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk> \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> + t_sift_down r x1 x2 \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (frule del_left_braun, simp+)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size v + size vb) = size r \\<or> size v + size vb = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2\\<rbrakk> \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> + t_sift_down r x1 x2 \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (frule del_left_size, simp+)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2\\<rbrakk> \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> + t_sift_down r x1 x2 \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (frule del_left_height, simp)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> + t_sift_down r x1 x2 \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (rule order_trans)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (frule del_left_height, simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> + t_sift_down r x1 x2 \\<le> ?y30 v va vb x r x1 x2 2. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> ?y30 v va vb x r x1 x2 \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (frule del_left_height, simp)<SEP>apply (rule order_trans)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \\<le> Suc (max (height v) (height vb))\\<rbrakk> \\<Longrightarrow> size r = size x2 \\<or> size r = Suc (size x2) 2. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> 2 * height \\<langle>v, va, vb\\<rangle> + height \\<langle>r, x1, x2\\<rangle> \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply auto[1]", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (frule del_left_height, simp)<SEP>apply (rule order_trans)<SEP>apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] \\n apply auto[1] <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>v va vb x r x1 x2. \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>; Suc (size x2) = size r \\<or> size x2 = size r; size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk> \\<Longrightarrow> 2 * height \\<langle>v, va, vb\\<rangle> + height \\<langle>r, x1, x2\\<rangle> \\<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)", "y": "apply (simp add: max_def)", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (frule del_left_height, simp)<SEP>apply (rule order_trans)<SEP>apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]<SEP>apply auto[1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "x": "<ISA_PRF> lemma t_del_min_bound: \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\" \\n apply (cases t rule: t_del_min.cases; simp) \\n apply (clarsimp split: prod.split) \\n apply (frule del_left_braun, simp+) \\n apply (frule del_left_size, simp+) \\n apply (frule del_left_height, simp) \\n apply (rule order_trans) \\n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] \\n apply auto[1] \\n apply (simp add: max_def) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"<SEP>apply (cases t rule: t_del_min.cases; simp)<SEP>apply (clarsimp split: prod.split)<SEP>apply (frule del_left_braun, simp+)<SEP>apply (frule del_left_size, simp+)<SEP>apply (frule del_left_height, simp)<SEP>apply (rule order_trans)<SEP>apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]<SEP>apply auto[1]<SEP>apply (simp add: max_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"", "x": "<ISA_PRF> lemma t_list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> t_list_of_B_dom t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> t_list_of_B_dom t", "y": "apply (induct t rule: measure_induct[where f=size])", "proof_script_until_now": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"", "x": "<ISA_PRF> lemma t_list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> t_list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> t_list_of_B_dom y; braun x\\<rbrakk> \\<Longrightarrow> t_list_of_B_dom x", "y": "apply (rule accpI, erule t_list_of_B_rel.cases)", "proof_script_until_now": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"<SEP>apply (induct t rule: measure_induct[where f=size])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"", "x": "<ISA_PRF> lemma t_list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> t_list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule t_list_of_B_rel.cases) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x y l a r. \\<lbrakk>\\<forall>y. size y < size x \\<longrightarrow> braun y \\<longrightarrow> t_list_of_B_dom y; braun x; y = del_min \\<langle>l, a, r\\<rangle>; x = \\<langle>l, a, r\\<rangle>\\<rbrakk> \\<Longrightarrow> t_list_of_B_dom y", "y": "apply (clarsimp simp: size_del_min braun_del_min)", "proof_script_until_now": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (rule accpI, erule t_list_of_B_rel.cases)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"", "x": "<ISA_PRF> lemma t_list_of_B_braun_ptermination: \"braun t \\<Longrightarrow> t_list_of_B_dom t\" \\n apply (induct t rule: measure_induct[where f=size]) \\n apply (rule accpI, erule t_list_of_B_rel.cases) \\n apply (clarsimp simp: size_del_min braun_del_min) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"<SEP>apply (induct t rule: measure_induct[where f=size])<SEP>apply (rule accpI, erule t_list_of_B_rel.cases)<SEP>apply (clarsimp simp: size_del_min braun_del_min)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_A_bound:\n  \"t_list_of_A t \\<le> 2 * height t * size t\"", "x": "<ISA_PRF> lemma t_list_of_A_bound: \"t_list_of_A t \\<le> 2 * height t * size t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_list_of_A t \\<le> 2 * height t * size t", "y": "by (rule t_list_of_A_induct, simp)", "proof_script_until_now": "lemma t_list_of_A_bound:\n  \"t_list_of_A t \\<le> 2 * height t * size t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma set_tree_merge[simp]:\n  \"set_tree (merge l r) = set_tree l \\<union> set_tree r\"", "x": "<ISA_PRF> lemma set_tree_merge[simp]: \"set_tree (merge l r) = set_tree l \\<union> set_tree r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set_tree (merge l r) = set_tree l \\<union> set_tree r", "y": "by (induct l r rule: merge.induct; simp)", "proof_script_until_now": "lemma set_tree_merge[simp]:\n  \"set_tree (merge l r) = set_tree l \\<union> set_tree r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\"", "x": "<ISA_PRF> lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (list_of_B (heap_of_B xs)) = mset xs", "y": "by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B)", "proof_script_until_now": "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\"", "x": "<ISA_PRF> lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\" \\n by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B) <ISA_OBS> proof (prove) goal (4 subgoals): 1. \\<And>P x. \\<lbrakk>x = \\<langle>\\<rangle> \\<Longrightarrow> P; \\<And>l a r. x = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P 2. \\<langle>\\<rangle> = \\<langle>\\<rangle> \\<Longrightarrow> 0 = 0 3. \\<And>l a r. \\<langle>\\<rangle> = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> 0 = 1 + t_del_min \\<langle>l, a, r\\<rangle> + t_list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) 4. \\<And>l a r la aa ra. \\<langle>l, a, r\\<rangle> = \\<langle>la, aa, ra\\<rangle> \\<Longrightarrow> 1 + t_del_min \\<langle>l, a, r\\<rangle> + t_list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) = 1 + t_del_min \\<langle>la, aa, ra\\<rangle> + t_list_of_B_sumC (del_min \\<langle>la, aa, ra\\<rangle>)", "y": "by pat_completeness auto", "proof_script_until_now": "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\"<SEP>by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"", "x": "<ISA_PRF> lemma mset_heapify: \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)", "y": "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)", "proof_script_until_now": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"", "x": "<ISA_PRF> lemma mset_heapify: \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\" \\n by (cases \"heapify n xs\", drule(1) heapify_correct, simp) <ISA_OBS> proof (prove) goal (22 subgoals): 1. \\<And>P x. \\<lbrakk>\\<And>a. x = (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) \\<Longrightarrow> P; \\<And>xa a. x = (\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>) \\<Longrightarrow> P; \\<And>l1 x1 r1 a l2 x2 r2. x = (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow> P; \\<And>vc vd ve va vb b. x = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> P; \\<And>v va vc vd ve b. x = (\\<langle>v, va, \\<langle>vc, vd, ve\\<rangle>\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> P; \\<And>b v va vb. x = (\\<langle>\\<rangle>, b, \\<langle>v, va, vb\\<rangle>) \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P 2. \\<And>a aa. (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow> 1 = 1 3. \\<And>a x aa. (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow> 1 = 2 4. \\<And>a l1 x1 r1 aa l2 x2 r2. (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>l1, x1, r1\\<rangle>, aa, \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow> 1 = (let t2 = \\<langle>l2, x2, r2\\<rangle>; t1 = \\<langle>l1, x1, r1\\<rangle> in if aa \\<le> x1 \\<and> aa \\<le> x2 then 1 else if x1 \\<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1) else 1 + t_sift_down_sumC (l2, aa, r2)) 5. \\<And>a vc vd ve va vb b. (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> 1 = undefined 6. \\<And>a v va vc vd ve b. (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>v, va, \\<langle>vc, vd, ve\\<rangle>\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> 1 = undefined 7. \\<And>a b v va vb. (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<rangle>, b, \\<langle>v, va, vb\\<rangle>) \\<Longrightarrow> 1 = undefined 8. \\<And>x a xa aa. (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow> 2 = 2 9. \\<And>x a l1 x1 r1 aa l2 x2 r2. (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>l1, x1, r1\\<rangle>, aa, \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow> 2 = (let t2 = \\<langle>l2, x2, r2\\<rangle>; t1 = \\<langle>l1, x1, r1\\<rangle> in if aa \\<le> x1 \\<and> aa \\<le> x2 then 1 else if x1 \\<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1) else 1 + t_sift_down_sumC (l2, aa, r2)) 10. \\<And>x a vc vd ve va vb b. (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a, \\<langle>\\<rangle>) = (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b, \\<langle>\\<rangle>) \\<Longrightarrow> 2 = undefined A total of 22 subgoals...", "y": "by pat_completeness auto", "proof_script_until_now": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"<SEP>by (cases \"heapify n xs\", drule(1) heapify_correct, simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"", "x": "<ISA_PRF> lemma mset_heapify: \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\" \\n by (cases \"heapify n xs\", drule(1) heapify_correct, simp) \\n by pat_completeness auto <ISA_OBS> proof (prove) goal (1 subgoal): 1. All t_sift_down_dom", "y": "by (relation \"measure (%(l,a,r). size l + size r)\") auto", "proof_script_until_now": "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"<SEP>by (cases \"heapify n xs\", drule(1) heapify_correct, simp)<SEP>by pat_completeness auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd: \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs", "y": "apply (induct xs arbitrary: n rule: measure_induct[where f=length])", "proof_script_until_now": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd: \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x n. \\<lbrakk>\\<forall>y. length y < length x \\<longrightarrow> (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y); n \\<le> length x\\<rbrakk> \\<Longrightarrow> snd (heapify n x) = drop n x", "y": "apply (case_tac n; simp)", "proof_script_until_now": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"<SEP>apply (induct xs arbitrary: n rule: measure_induct[where f=length])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd: \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>x n nat. \\<lbrakk>\\<forall>y. length y < length x \\<longrightarrow> (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y); Suc nat \\<le> length x; n = Suc nat\\<rbrakk> \\<Longrightarrow> snd (heapify (Suc nat) x) = drop (Suc nat) x", "y": "apply (clarsimp simp: Suc_le_length_iff case_prod_beta)", "proof_script_until_now": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"<SEP>apply (induct xs arbitrary: n rule: measure_induct[where f=length])<SEP>apply (case_tac n; simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd: \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) \\n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>nat ys. \\<lbrakk>\\<forall>y. length y < Suc (length ys) \\<longrightarrow> (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y); nat \\<le> length ys\\<rbrakk> \\<Longrightarrow> drop (nat div 2 + Suc nat div 2) ys = drop nat ys", "y": "apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs])", "proof_script_until_now": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"<SEP>apply (induct xs arbitrary: n rule: measure_induct[where f=length])<SEP>apply (case_tac n; simp)<SEP>apply (clarsimp simp: Suc_le_length_iff case_prod_beta)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd: \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) \\n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) \\n apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>nat ys. \\<lbrakk>\\<forall>y. length y < Suc (length ys) \\<longrightarrow> (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y); nat \\<le> length ys\\<rbrakk> \\<Longrightarrow> nat div 2 + Suc nat div 2 = nat", "y": "apply simp", "proof_script_until_now": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"<SEP>apply (induct xs arbitrary: n rule: measure_induct[where f=length])<SEP>apply (case_tac n; simp)<SEP>apply (clarsimp simp: Suc_le_length_iff case_prod_beta)<SEP>apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "x": "<ISA_PRF> lemma heapify_snd: \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\" \\n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \\n apply (case_tac n; simp) \\n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) \\n apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs]) \\n apply simp <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"<SEP>apply (induct xs arbitrary: n rule: measure_induct[where f=length])<SEP>apply (case_tac n; simp)<SEP>apply (clarsimp simp: Suc_le_length_iff case_prod_beta)<SEP>apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs])<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "proof -", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "have \"?lhs \\<le> ?lhs\"", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)", "y": "by simp", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp <ISA_OBS> proof (state) this: t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "also", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also <ISA_OBS> proof (state) this: t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "note t_heap_of_A_log_bound[of xs]", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] <ISA_OBS> proof (state) this: t_heap_of_A xs \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "also", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also <ISA_OBS> proof (state) this: t_heap_of_A xs \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] <ISA_OBS> proof (state) this: t_list_of_A (heap_of_A xs) \\<le> 2 * nat \\<lceil>log 2 (real (size (heap_of_A xs) + 1))\\<rceil> * size (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "finally", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]<SEP>also<SEP>note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally <ISA_OBS> proof (chain) picking this: \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + t_list_of_A (heap_of_A xs) \\<le> y + t_list_of_A (heap_of_A xs); \\<And>x y. x \\<le> y \\<Longrightarrow> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + x \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + y\\<rbrakk> \\<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + 2 * nat \\<lceil>log 2 (real (size (heap_of_A xs) + 1))\\<rceil> * size (heap_of_A xs)", "y": "show ?thesis", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]<SEP>also<SEP>note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]<SEP>finally"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally \\n show ?thesis <ISA_OBS> proof (prove) using this: \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + t_list_of_A (heap_of_A xs) \\<le> y + t_list_of_A (heap_of_A xs); \\<And>x y. x \\<le> y \\<Longrightarrow> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + x \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + y\\<rbrakk> \\<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + 2 * nat \\<lceil>log 2 (real (size (heap_of_A xs) + 1))\\<rceil> * size (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "y": "by (simp add: size_heap_of_A)", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]<SEP>also<SEP>note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]<SEP>finally<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally \\n show ?thesis \\n by (simp add: size_heap_of_A) <ISA_OBS> proof (state) this: t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) goal: No subgoals!", "y": "qed", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]<SEP>also<SEP>note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]<SEP>finally<SEP>show ?thesis<SEP>by (simp add: size_heap_of_A)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortA: \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_A_log_bound[of xs] \\n also \\n note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A] \\n finally \\n show ?thesis \\n by (simp add: size_heap_of_A) \\n qed <ISA_OBS> proof (prove) goal (4 subgoals): 1. \\<And>P x. \\<lbrakk>x = \\<langle>\\<rangle> \\<Longrightarrow> P; \\<And>l a r. x = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P 2. \\<langle>\\<rangle> = \\<langle>\\<rangle> \\<Longrightarrow> [] = [] 3. \\<And>l a r. \\<langle>\\<rangle> = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> [] = a # list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) 4. \\<And>l a r la aa ra. \\<langle>l, a, r\\<rangle> = \\<langle>la, aa, ra\\<rangle> \\<Longrightarrow> a # list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) = aa # list_of_B_sumC (del_min \\<langle>la, aa, ra\\<rangle>)", "y": "by pat_completeness auto", "proof_script_until_now": "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_A_log_bound[of xs]<SEP>also<SEP>note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]<SEP>finally<SEP>show ?thesis<SEP>by (simp add: size_heap_of_A)<SEP>qed"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> height (sift_down l x r) \\<le> height (Node l x r)\"", "x": "<ISA_PRF> lemma sift_down_height: \"braun (Node l x r) \\<Longrightarrow> height (sift_down l x r) \\<le> height (Node l x r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow> height (sift_down l x r) \\<le> height \\<langle>l, x, r\\<rangle>", "y": "by (induct l x r rule: sift_down.induct; auto simp: Let_def)", "proof_script_until_now": "lemma sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> height (sift_down l x r) \\<le> height (Node l x r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_list_of_B_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t\"", "x": "<ISA_PRF> lemma t_list_of_B_bound: \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t", "y": "by (erule t_list_of_B_induct, simp)", "proof_script_until_now": "lemma t_list_of_B_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1", "y": "proof (induct i xs rule: t_heapify.induct)", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) <ISA_OBS> proof (state) goal (3 subgoals): 1. \\<And>xs. 0 \\<le> length xs \\<Longrightarrow> t_heapify 0 xs + height (fst (heapify 0 xs)) \\<le> 5 * 0 + 1 2. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 3. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "case (1 vs)", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) <ISA_OBS> proof (state) this: 0 \\<le> length vs goal (3 subgoals): 1. \\<And>xs. 0 \\<le> length xs \\<Longrightarrow> t_heapify 0 xs + height (fst (heapify 0 xs)) \\<le> 5 * 0 + 1 2. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 3. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "thus ?case", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case <ISA_OBS> proof (prove) using this: 0 \\<le> length vs goal (1 subgoal): 1. t_heapify 0 vs + height (fst (heapify 0 vs)) \\<le> 5 * 0 + 1", "y": "by simp", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp <ISA_OBS> proof (state) this: t_heapify 0 vs + height (fst (heapify 0 vs)) \\<le> 5 * 0 + 1 goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "next", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "case (2 i x xs)", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) <ISA_OBS> proof (state) this: \\<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa; Suc i div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) \\<le> 5 * (Suc i div 2) + 1 \\<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa; ?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ?y; (?xac, ?ya) = ?xab; i div 2 \\<le> length ?y\\<rbrakk> \\<Longrightarrow> t_heapify (i div 2) ?y + height (fst (heapify (i div 2) ?y)) \\<le> 5 * (i div 2) + 1 Suc i \\<le> length (x # xs) goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\\<And>l ys. heapify (Suc i div 2) xs = (l, ys) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "y": "by (simp add: prod_eq_iff)", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (Suc i div 2) xs = (l, ys) goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] <ISA_OBS> proof (state) this: Suc i div 2 \\<le> length xs \\<Longrightarrow> t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) \\<le> Suc (5 * (Suc i div 2)) \\<lbrakk>?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ys; (?xac, ?ya) = ?xab; i div 2 \\<le> length ys\\<rbrakk> \\<Longrightarrow> t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys)) \\<le> Suc (5 * (i div 2)) goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\\<And>r zs. heapify (i div 2) ys = (r, zs) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "y": "by (simp add: prod_eq_iff)", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (i div 2) ys = (r, zs) goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "from \"2.prems\" heapify_snd_tup[OF h1]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] <ISA_OBS> proof (chain) picking this: Suc i \\<le> length (x # xs) Suc i div 2 \\<le> length xs \\<Longrightarrow> ys = drop (Suc i div 2) xs", "y": "have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" <ISA_OBS> proof (prove) using this: Suc i \\<le> length (x # xs) Suc i div 2 \\<le> length xs \\<Longrightarrow> ys = drop (Suc i div 2) xs goal (1 subgoal): 1. Suc i div 2 \\<le> length xs &&& i div 2 \\<le> length xs &&& i div 2 \\<le> length ys", "y": "by simp_all", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all <ISA_OBS> proof (state) this: Suc i div 2 \\<le> length xs i div 2 \\<le> length xs i div 2 \\<le> length ys goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] <ISA_OBS> proof (state) this: t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) \\<le> Suc (5 * (Suc i div 2)) t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys)) \\<le> Suc (5 * (i div 2)) goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] <ISA_OBS> proof (state) this: t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) + (t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))) + 3 \\<le> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3 goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] <ISA_OBS> proof (chain) picking this: size l = Suc i div 2 \\<and> heap l \\<and> braun l \\<and> mset_tree l = mset (take (Suc i div 2) xs) size r = i div 2 \\<and> heap r \\<and> braun r \\<and> mset_tree r = mset (take (i div 2) ys)", "y": "have braun: \"braun \\<langle>l, x, r\\<rangle>\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" <ISA_OBS> proof (prove) using this: size l = Suc i div 2 \\<and> heap l \\<and> braun l \\<and> mset_tree l = mset (take (Suc i div 2) xs) size r = i div 2 \\<and> heap r \\<and> braun r \\<and> mset_tree r = mset (take (i div 2) ys) goal (1 subgoal): 1. braun \\<langle>l, x, r\\<rangle>", "y": "by auto", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto <ISA_OBS> proof (state) this: braun \\<langle>l, x, r\\<rangle> goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_sift_down l x r \\<le> height l + 1", "y": "using t_sift_down_height[OF braun] braun_height_r_le[OF braun]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] <ISA_OBS> proof (prove) using this: t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle> height r \\<le> height l goal (1 subgoal): 1. t_sift_down l x r \\<le> height l + 1", "y": "by simp", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp <ISA_OBS> proof (state) this: t_sift_down l x r \\<le> height l + 1 goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "from t_sift_down_height[OF braun]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] <ISA_OBS> proof (chain) picking this: t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>", "y": "have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" <ISA_OBS> proof (prove) using this: t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle> goal (1 subgoal): 1. height (sift_down l x r) \\<le> height r + 2", "y": "using sift_down_height[OF braun] braun_height_l_le[OF braun]", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] <ISA_OBS> proof (prove) using this: t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle> height (sift_down l x r) \\<le> height \\<langle>l, x, r\\<rangle> height l \\<le> Suc (height r) goal (1 subgoal): 1. height (sift_down l x r) \\<le> height r + 2", "y": "by simp", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp <ISA_OBS> proof (state) this: height (sift_down l x r) \\<le> height r + 2 goal (2 subgoals): 1. \\<And>n x xs. \\<lbrakk>\\<And>xa xb y. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \\<le> 5 * (Suc n div 2) + 1; \\<And>xa xb y xaa xab xac ya. \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk> \\<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \\<le> 5 * (n div 2) + 1; Suc n \\<le> length (x # xs)\\<rbrakk> \\<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \\<le> 5 * Suc n + 1 2. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "from h1 h2 t_sift_l height_sift_r \"2.prems\"", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" <ISA_OBS> proof (chain) picking this: heapify (Suc i div 2) xs = (l, ys) heapify (i div 2) ys = (r, zs) t_sift_down l x r \\<le> height l + 1 height (sift_down l x r) \\<le> height r + 2 Suc i \\<le> length (x # xs)", "y": "show ?case", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case <ISA_OBS> proof (prove) using this: heapify (Suc i div 2) xs = (l, ys) heapify (i div 2) ys = (r, zs) t_sift_down l x r \\<le> height l + 1 height (sift_down l x r) \\<le> height r + 2 Suc i \\<le> length (x # xs) goal (1 subgoal): 1. t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs))) \\<le> 5 * Suc i + 1", "y": "apply simp", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l); height (sift_down l x r) \\<le> Suc (Suc (height r)); i \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc i div 2) xs + (t_heapify (i div 2) ys + (t_sift_down l x r + height (sift_down l x r))) \\<le> 5 + 5 * i", "y": "apply (rule order_trans, rule order_trans[rotated], rule prem)", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l); height (sift_down l x r) \\<le> Suc (Suc (height r)); i \\<le> length xs\\<rbrakk> \\<Longrightarrow> t_heapify (Suc i div 2) xs + (t_heapify (i div 2) ys + (t_sift_down l x r + height (sift_down l x r))) \\<le> t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) + (t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))) + 3 2. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l); height (sift_down l x r) \\<le> Suc (Suc (height r)); i \\<le> length xs\\<rbrakk> \\<Longrightarrow> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3 \\<le> 5 + 5 * i", "y": "apply simp_all", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case<SEP>apply simp<SEP>apply (rule order_trans, rule order_trans[rotated], rule prem)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l); height (sift_down l x r) \\<le> Suc (Suc (height r)); i \\<le> length xs\\<rbrakk> \\<Longrightarrow> 5 * (Suc i div 2) + 5 * (i div 2) \\<le> 5 * i", "y": "apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case<SEP>apply simp<SEP>apply (rule order_trans, rule order_trans[rotated], rule prem)<SEP>apply simp_all"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all \\n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l); height (sift_down l x r) \\<le> Suc (Suc (height r)); i \\<le> length xs\\<rbrakk> \\<Longrightarrow> 0 < 5 \\<longrightarrow> Suc i div 2 + i div 2 \\<le> i", "y": "apply simp", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case<SEP>apply simp<SEP>apply (rule order_trans, rule order_trans[rotated], rule prem)<SEP>apply simp_all<SEP>apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all \\n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) \\n apply simp <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case<SEP>apply simp<SEP>apply (rule order_trans, rule order_trans[rotated], rule prem)<SEP>apply simp_all<SEP>apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])<SEP>apply simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_induct: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\" \\n proof (induct i xs rule: t_heapify.induct) \\n case (1 vs) \\n thus ?case \\n by simp \\n next \\n case (2 i x xs) \\n obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\" \\n by (simp add: prod_eq_iff) \\n note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified] \\n obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\" \\n by (simp add: prod_eq_iff) \\n from \"2.prems\" heapify_snd_tup[OF h1] \\n have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\" \\n by simp_all \\n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \\n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \\n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \\n have braun: \"braun \\<langle>l, x, r\\<rangle>\" \\n by auto \\n have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\" \\n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \\n by simp \\n from t_sift_down_height[OF braun] \\n have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\" \\n using sift_down_height[OF braun] braun_height_l_le[OF braun] \\n by simp \\n from h1 h2 t_sift_l height_sift_r \"2.prems\" \\n show ?case \\n apply simp \\n apply (rule order_trans, rule order_trans[rotated], rule prem) \\n apply simp_all \\n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) \\n apply simp \\n done <ISA_OBS> proof (state) this: t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs))) \\<le> 5 * Suc i + 1 goal (1 subgoal): 1. \\<And>v. Suc v \\<le> length [] \\<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \\<le> 5 * Suc v + 1", "y": "qed simp_all", "proof_script_until_now": "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"<SEP>proof (induct i xs rule: t_heapify.induct)<SEP>case (1 vs)<SEP>thus ?case<SEP>by simp<SEP>next<SEP>case (2 i x xs)<SEP>obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\"<SEP>by (simp add: prod_eq_iff)<SEP>note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]<SEP>obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\"<SEP>by (simp add: prod_eq_iff)<SEP>from \"2.prems\" heapify_snd_tup[OF h1]<SEP>have le1: \"Suc i div 2 \\<le> length xs\" and le2: \"i div 2 \\<le> length xs\" and le4: \"i div 2 \\<le> length ys\"<SEP>by simp_all<SEP>note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]<SEP>note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]<SEP>from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]<SEP>have braun: \"braun \\<langle>l, x, r\\<rangle>\"<SEP>by auto<SEP>have t_sift_l: \"t_sift_down l x r \\<le> height l + 1\"<SEP>using t_sift_down_height[OF braun] braun_height_r_le[OF braun]<SEP>by simp<SEP>from t_sift_down_height[OF braun]<SEP>have height_sift_r: \"height (sift_down l x r) \\<le> height r + 2\"<SEP>using sift_down_height[OF braun] braun_height_l_le[OF braun]<SEP>by simp<SEP>from h1 h2 t_sift_l height_sift_r \"2.prems\"<SEP>show ?case<SEP>apply simp<SEP>apply (rule order_trans, rule order_trans[rotated], rule prem)<SEP>apply simp_all<SEP>apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])<SEP>apply simp<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma heap_heap_of_A: \"heap (heap_of_A xs)\"", "x": "<ISA_PRF> lemma heap_heap_of_A: \"heap (heap_of_A xs)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap (heap_of_A xs)", "y": "by(induction xs)(simp_all add: heap_insert)", "proof_script_until_now": "lemma heap_heap_of_A: \"heap (heap_of_A xs)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heap_of_B_bound:\n  \"t_heap_of_B xs \\<le> 6 * length xs + 1\"", "x": "<ISA_PRF> lemma t_heap_of_B_bound: \"t_heap_of_B xs \\<le> 6 * length xs + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs \\<le> 6 * length xs + 1", "y": "by (simp add: t_heap_of_B_def order_trans[OF t_heapify_bound])", "proof_script_until_now": "lemma t_heap_of_B_bound:\n  \"t_heap_of_B xs \\<le> 6 * length xs + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"", "x": "<ISA_PRF> lemma t_insert_height: \"t_insert x t \\<le> height t + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_insert x t \\<le> height t + 1", "y": "apply (induct t arbitrary: x; simp)", "proof_script_until_now": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"", "x": "<ISA_PRF> lemma t_insert_height: \"t_insert x t \\<le> height t + 1\" \\n apply (induct t arbitrary: x; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<And>t1 x2 t2 x. \\<lbrakk>\\<And>x. t_insert x t1 \\<le> Suc (height t1); \\<And>x. t_insert x t2 \\<le> Suc (height t2)\\<rbrakk> \\<Longrightarrow> (x < x2 \\<longrightarrow> t_insert x2 t2 \\<le> Suc (max (height t1) (height t2))) \\<and> (\\<not> x < x2 \\<longrightarrow> t_insert x t2 \\<le> Suc (max (height t1) (height t2)))", "y": "apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp)", "proof_script_until_now": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"<SEP>apply (induct t arbitrary: x; simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"", "x": "<ISA_PRF> lemma t_insert_height: \"t_insert x t \\<le> height t + 1\" \\n apply (induct t arbitrary: x; simp) \\n apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"<SEP>apply (induct t arbitrary: x; simp)<SEP>apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma merge_heap:\n  \"heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap (merge l r)\"", "x": "<ISA_PRF> lemma merge_heap: \"heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap (merge l r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \\<lbrakk>heap l; heap r\\<rbrakk> \\<Longrightarrow> heap (merge l r)", "y": "by (induct l r rule: merge.induct; auto simp: ball_Un)", "proof_script_until_now": "lemma merge_heap:\n  \"heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap (merge l r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma sortedB: \"sorted (list_of_B (heap_of_B xs))\"", "x": "<ISA_PRF> lemma sortedB: \"sorted (list_of_B (heap_of_B xs))\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. sorted (list_of_B (heap_of_B xs))", "y": "by (simp add: heap_of_B_def braun_heapify heap_heapify sorted_list_of_B)", "proof_script_until_now": "lemma sortedB: \"sorted (list_of_B (heap_of_B xs))\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "proof -", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "have \"?lhs \\<le> ?lhs\"", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)", "y": "by simp", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp <ISA_OBS> proof (state) this: t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "also", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also <ISA_OBS> proof (state) this: t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "note t_heap_of_B_bound[of xs]", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] <ISA_OBS> proof (state) this: t_heap_of_B xs \\<le> 6 * length xs + 1 goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "also", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also <ISA_OBS> proof (state) this: t_heap_of_B xs \\<le> 6 * length xs + 1 goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "note t_list_of_B_log_bound[of \"heap_of_B xs\"]", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] <ISA_OBS> proof (state) this: braun (heap_of_B xs) \\<Longrightarrow> t_list_of_B (heap_of_B xs) \\<le> 3 * (nat \\<lceil>log 2 (real (size (heap_of_B xs) + 1))\\<rceil> + 1) * size (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "finally", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also<SEP>note t_list_of_B_log_bound[of \"heap_of_B xs\"]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally <ISA_OBS> proof (chain) picking this: \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + t_list_of_B (heap_of_B xs) \\<le> y + t_list_of_B (heap_of_B xs); braun (heap_of_B xs); \\<And>x y. x \\<le> y \\<Longrightarrow> 6 * length xs + 1 + x \\<le> 6 * length xs + 1 + y\\<rbrakk> \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 6 * length xs + 1 + 3 * (nat \\<lceil>log 2 (real (size (heap_of_B xs) + 1))\\<rceil> + 1) * size (heap_of_B xs)", "y": "show ?thesis", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also<SEP>note t_list_of_B_log_bound[of \"heap_of_B xs\"]<SEP>finally"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis <ISA_OBS> proof (prove) using this: \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + t_list_of_B (heap_of_B xs) \\<le> y + t_list_of_B (heap_of_B xs); braun (heap_of_B xs); \\<And>x y. x \\<le> y \\<Longrightarrow> 6 * length xs + 1 + x \\<le> 6 * length xs + 1 + y\\<rbrakk> \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 6 * length xs + 1 + 3 * (nat \\<lceil>log 2 (real (size (heap_of_B xs) + 1))\\<rceil> + 1) * size (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1", "y": "apply (simp add: size_heapify braun_heapify heap_of_B_def)", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also<SEP>note t_list_of_B_log_bound[of \"heap_of_B xs\"]<SEP>finally<SEP>show ?thesis"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis \\n apply (simp add: size_heapify braun_heapify heap_of_B_def) <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs)) \\<le> Suc (6 * length xs + (3 + 3 * nat \\<lceil>log 2 (1 + real (length xs))\\<rceil>) * length xs) \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs)) \\<le> Suc (3 * length xs * (nat \\<lceil>log 2 (1 + real (length xs))\\<rceil> + 3))", "y": "apply (simp add: field_simps)", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also<SEP>note t_list_of_B_log_bound[of \"heap_of_B xs\"]<SEP>finally<SEP>show ?thesis<SEP>apply (simp add: size_heapify braun_heapify heap_of_B_def)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis \\n apply (simp add: size_heapify braun_heapify heap_of_B_def) \\n apply (simp add: field_simps) <ISA_OBS> proof (prove) goal: No subgoals!", "y": "done", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also<SEP>note t_list_of_B_log_bound[of \"heap_of_B xs\"]<SEP>finally<SEP>show ?thesis<SEP>apply (simp add: size_heapify braun_heapify heap_of_B_def)<SEP>apply (simp add: field_simps)"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")", "x": "<ISA_PRF> theorem t_sortB: \"t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\" (is \"?lhs \\<le> _\") \\n proof - \\n have \"?lhs \\<le> ?lhs\" \\n by simp \\n also \\n note t_heap_of_B_bound[of xs] \\n also \\n note t_list_of_B_log_bound[of \"heap_of_B xs\"] \\n finally \\n show ?thesis \\n apply (simp add: size_heapify braun_heapify heap_of_B_def) \\n apply (simp add: field_simps) \\n done <ISA_OBS> proof (state) this: t_heap_of_B xs + t_list_of_B (heap_of_B xs) \\<le> 3 * length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) + 1 goal: No subgoals!", "y": "qed", "proof_script_until_now": "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")<SEP>proof -<SEP>have \"?lhs \\<le> ?lhs\"<SEP>by simp<SEP>also<SEP>note t_heap_of_B_bound[of xs]<SEP>also<SEP>note t_list_of_B_log_bound[of \"heap_of_B xs\"]<SEP>finally<SEP>show ?thesis<SEP>apply (simp add: size_heapify braun_heapify heap_of_B_def)<SEP>apply (simp add: field_simps)<SEP>done"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_bound: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1", "y": "using t_heapify_induct[of i xs]", "proof_script_until_now": "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\"", "x": "<ISA_PRF> lemma t_heapify_bound: \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\" \\n using t_heapify_induct[of i xs] <ISA_OBS> proof (prove) using this: i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1 goal (1 subgoal): 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1", "y": "by simp", "proof_script_until_now": "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\"<SEP>using t_heapify_induct[of i xs]"}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma merge_size[termination_simp]:\n  \"size (merge l r) = size l + size r\"", "x": "<ISA_PRF> lemma merge_size[termination_simp]: \"size (merge l r) = size l + size r\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (merge l r) = size l + size r", "y": "by (induct rule: merge.induct; simp)", "proof_script_until_now": "lemma merge_size[termination_simp]:\n  \"size (merge l r) = size l + size r\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma t_sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> t_sift_down l x r \\<le> height (Node l x r)\"", "x": "<ISA_PRF> lemma t_sift_down_height: \"braun (Node l x r) \\<Longrightarrow> t_sift_down l x r \\<le> height (Node l x r)\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow> t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>", "y": "by (induct l x r rule: t_sift_down.induct; auto)", "proof_script_until_now": "lemma t_sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> t_sift_down l x r \\<le> height (Node l x r)\""}
{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "problem_name": "lemma set_list_of_A[simp]:\n  \"set (list_of_A t) = set_tree t\"", "x": "<ISA_PRF> lemma set_list_of_A[simp]: \"set (list_of_A t) = set_tree t\" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (list_of_A t) = set_tree t", "y": "by (induct t rule: list_of_A.induct; simp)", "proof_script_until_now": "lemma set_list_of_A[simp]:\n  \"set (list_of_A t) = set_tree t\""}
