<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" <ISA_OBS> proof (prove) goal (1 subgoal): 1. r\<^sup>* `` X = X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof <ISA_OBS> proof (state) goal (2 subgoals): 1. r\<^sup>* `` X \<subseteq> X 2. X \<subseteq> r\<^sup>* `` X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" <ISA_OBS> proof (prove) goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { <ISA_OBS> proof (state) goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y <ISA_OBS> proof (state) goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" <ISA_OBS> proof (state) this: y \<in> X goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" <ISA_OBS> proof (state) this: (y, x) \<in> r\<^sup>* goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then <ISA_OBS> proof (chain) picking this: (y, x) \<in> r\<^sup>*
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" <ISA_OBS> proof (prove) using this: (y, x) \<in> r\<^sup>* goal (1 subgoal): 1. x \<in> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) <ISA_OBS> proof (state) this: x \<in> X goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) \n } <ISA_OBS> proof (state) this: \<lbrakk>?y2 \<in> X; (?y2, ?x2) \<in> r\<^sup>*\<rbrakk> \<Longrightarrow> ?x2 \<in> X goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) \n } \n then <ISA_OBS> proof (chain) picking this: \<lbrakk>?y2 \<in> X; (?y2, ?x2) \<in> r\<^sup>*\<rbrakk> \<Longrightarrow> ?x2 \<in> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) \n } \n then \n show ?thesis <ISA_OBS> proof (prove) using this: \<lbrakk>?y2 \<in> X; (?y2, ?x2) \<in> r\<^sup>*\<rbrakk> \<Longrightarrow> ?x2 \<in> X goal (1 subgoal): 1. r\<^sup>* `` X \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) \n } \n then \n show ?thesis \n unfolding Image_def <ISA_OBS> proof (prove) using this: \<lbrakk>?y2 \<in> X; (?y2, ?x2) \<in> r\<^sup>*\<rbrakk> \<Longrightarrow> ?x2 \<in> X goal (1 subgoal): 1. {y. \<exists>x\<in>X. (x, y) \<in> r\<^sup>*} \<subseteq> X
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) \n } \n then \n show ?thesis \n unfolding Image_def \n by auto <ISA_OBS> proof (state) this: r\<^sup>* `` X \<subseteq> X goal: No subgoals!
<ISA_PRF> lemma Image_closed_trancl: assumes "r `` X \<subseteq> X" shows "r\<^sup>* `` X = X" \n proof \n show "r\<^sup>* `` X \<subseteq> X" \n proof - \n { \n fix x y \n assume y: "y \<in> X" \n assume "(y,x) \<in> r\<^sup>*" \n then \n have "x \<in> X" \n by (induct) (insert assms y, auto simp add: Image_def) \n } \n then \n show ?thesis \n unfolding Image_def \n by auto \n qed <ISA_OBS> proof (state) this: r\<^sup>* `` X \<subseteq> X goal (1 subgoal): 1. X \<subseteq> r\<^sup>* `` X
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. finite (nodes_of g - set ys)
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) <ISA_OBS> proof (state) goal (2 subgoals): 1. nodes_of g - set ys \<subseteq> ?B 2. finite ?B
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. finite (nodes_of g)
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) <ISA_OBS> proof (state) this: finite (nodes_of g) goal (1 subgoal): 1. nodes_of g - set ys \<subseteq> nodes_of g
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) \n qed (auto) <ISA_OBS> proof (prove) goal (4 subgoals): 1. \<And>P x. \<lbrakk>\<And>g ys. x = (g, [], ys) \<Longrightarrow> P; \<And>g xa xs ys. x = (g, xa # xs, ys) \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P 2. \<And>g ys ga ysa. (g, [], ys) = (ga, [], ysa) \<Longrightarrow> ys = ysa 3. \<And>g ys ga x xs ysa. (g, [], ys) = (ga, x # xs, ysa) \<Longrightarrow> ys = (if List.member ysa x then dfs_sumC (ga, xs, ysa) else dfs_sumC (ga, nexts ga x @ xs, x # ysa)) 4. \<And>g x xs ys ga xa xsa ysa. (g, x # xs, ys) = (ga, xa # xsa, ysa) \<Longrightarrow> (if List.member ys x then dfs_sumC (g, xs, ys) else dfs_sumC (g, nexts g x @ xs, x # ys)) = (if List.member ysa xa then dfs_sumC (ga, xsa, ysa) else dfs_sumC (ga, nexts ga xa @ xsa, xa # ysa))
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) \n qed (auto) \n by pat_completeness auto <ISA_OBS> proof (prove) goal (1 subgoal): 1. All dfs_dom
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) \n qed (auto) \n by pat_completeness auto \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") <ISA_OBS> proof (prove) goal (3 subgoals): 1. wf (inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))) 2. \<And>g x xs ys. List.member ys x \<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 3. \<And>g x xs ys. \<not> List.member ys x \<Longrightarrow> ((g, nexts g x @ xs, x # ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) \n qed (auto) \n by pat_completeness auto \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>g x xs ys. List.member ys x \<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 2. \<And>g x xs ys. \<not> List.member ys x \<Longrightarrow> ((g, nexts g x @ xs, x # ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) \n qed (auto) \n by pat_completeness auto \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] \n apply (simp_all add: finite_psubset_def) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>g x ys. \<not> List.member ys x \<Longrightarrow> nodes_of g - insert x (set ys) \<subset> nodes_of g - set ys \<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \<and> nexts g x = []
<ISA_PRF> lemma [simp]: "finite (nodes_of g - set ys)" \n proof(rule finite_subset) \n show "finite (nodes_of g)" \n by (auto simp add: nodes_of_def) \n qed (auto) \n by pat_completeness auto \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] \n apply (simp_all add: finite_psubset_def) \n by (case_tac "x \<in> nodes_of g") (auto simp add: List.member_def) <ISA_OBS> proof (prove) goal (4 subgoals): 1. \<And>P x. \<lbrakk>\<And>g ys. x = (g, [], ys) \<Longrightarrow> P; \<And>g xa xs ys. x = (g, xa # xs, ys) \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P 2. \<And>g ys ga ysa. (g, [], ys) = (ga, [], ysa) \<Longrightarrow> ys = ysa 3. \<And>g ys ga x xs ysa. (g, [], ys) = (ga, x # xs, ysa) \<Longrightarrow> ys = (if List.member ysa x then dfs2_sumC (ga, xs, ysa) else dfs2_sumC (ga, xs, dfs2_sumC (ga, nexts ga x, x # ysa))) 4. \<And>g x xs ys ga xa xsa ysa. (g, x # xs, ys) = (ga, xa # xsa, ysa) \<Longrightarrow> (if List.member ys x then dfs2_sumC (g, xs, ys) else dfs2_sumC (g, xs, dfs2_sumC (g, nexts g x, x # ys))) = (if List.member ysa xa then dfs2_sumC (ga, xsa, ysa) else dfs2_sumC (ga, xsa, dfs2_sumC (ga, nexts ga xa, xa # ysa)))
<ISA_PRF> lemma [simp]: "x \<notin> nodes_of g \<Longrightarrow> nexts g x = []" <ISA_OBS> proof (prove) goal (1 subgoal): 1. x \<notin> nodes_of g \<Longrightarrow> nexts g x = []
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>g ys. set (dfs g [] ys) \<subseteq> reachable g [] \<union> set ys 2. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys; \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys)\<rbrakk> \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 <ISA_OBS> proof (state) this: goal (2 subgoals): 1. \<And>g ys. set (dfs g [] ys) \<subseteq> reachable g [] \<union> set ys 2. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys; \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys)\<rbrakk> \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then <ISA_OBS> proof (chain) picking this:
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g_ [] ys_) \<subseteq> reachable g_ [] \<union> set ys_
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp <ISA_OBS> proof (state) this: set (dfs g_ [] ys_) \<subseteq> reachable g_ [] \<union> set ys_ goal (1 subgoal): 1. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys; \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys)\<rbrakk> \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys; \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys)\<rbrakk> \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) <ISA_OBS> proof (state) this: List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys) goal (1 subgoal): 1. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys; \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys)\<rbrakk> \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") <ISA_OBS> proof (state) goal (2 subgoals): 1. x \<in> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys 2. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True <ISA_OBS> proof (state) this: x \<in> set ys goal (2 subgoals): 1. x \<in> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys 2. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 <ISA_OBS> proof (chain) picking this: List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys) x \<in> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" <ISA_OBS> proof (prove) using this: List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys) x \<in> set ys goal (1 subgoal): 1. set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) <ISA_OBS> proof (state) this: set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False <ISA_OBS> proof (state) this: x \<notin> set ys goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (nexts g x) \<subseteq> reachable g [x]
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) <ISA_OBS> proof (state) this: reachable g (nexts g x) \<subseteq> reachable g [x] goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) \n hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)" <ISA_OBS> proof (prove) using this: reachable g (nexts g x) \<subseteq> reachable g [x] goal (1 subgoal): 1. reachable g (nexts g x @ xs) \<subseteq> reachable g (x # xs)
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) \n hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)" \n by(simp add: reachable_append, auto simp add: reachable_def) <ISA_OBS> proof (state) this: reachable g (nexts g x @ xs) \<subseteq> reachable g (x # xs) goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) \n hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)" \n by(simp add: reachable_append, auto simp add: reachable_def) \n with False 2 <ISA_OBS> proof (chain) picking this: x \<notin> set ys List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys) reachable g (nexts g x @ xs) \<subseteq> reachable g (x # xs)
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) \n hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)" \n by(simp add: reachable_append, auto simp add: reachable_def) \n with False 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" <ISA_OBS> proof (prove) using this: x \<notin> set ys List.member ys x \<Longrightarrow> set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys \<not> List.member ys x \<Longrightarrow> set (dfs g (nexts g x @ xs) (x # ys)) \<subseteq> reachable g (nexts g x @ xs) \<union> set (x # ys) reachable g (nexts g x @ xs) \<subseteq> reachable g (x # xs) goal (1 subgoal): 1. set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) \n hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)" \n by(simp add: reachable_append, auto simp add: reachable_def) \n with False 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) <ISA_OBS> proof (state) this: set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys goal: No subgoals!
<ISA_PRF> lemma dfs_subset_reachable_visit_nodes: "set (dfs g xs ys) \<subseteq> reachable g xs \<union> set ys" \n proof(induct g xs ys rule: dfs.induct) \n case 1 \n then \n show ?case \n by simp \n next \n case (2 g x xs ys) \n show ?case \n proof (cases "x \<in> set ys") \n case True \n with 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n next \n case False \n have "reachable g (nexts g x) \<subseteq> reachable g [x]" \n by (rule reachable_nexts) \n hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)" \n by(simp add: reachable_append, auto simp add: reachable_def) \n with False 2 \n show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys" \n by (auto simp add: reachable_def List.member_def) \n qed <ISA_OBS> proof (state) this: set (dfs g (x # xs) ys) \<subseteq> reachable g (x # xs) \<union> set ys goal: No subgoals!
<ISA_PRF> lemma dfs_app: "dfs g (xs@ys) zs = dfs g ys (dfs g xs zs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. dfs g (xs @ ys) zs = dfs g ys (dfs g xs zs)
<ISA_PRF> lemma nextss_Cons: "nextss g (x#xs) = set (nexts g x) \<union> nextss g xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. nextss g (x # xs) = set (nexts g x) \<union> nextss g xs
<ISA_PRF> lemma nextss_Cons: "nextss g (x#xs) = set (nexts g x) \<union> nextss g xs" \n unfolding nextss_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. set g `` set (x # xs) = set (nexts g x) \<union> set g `` set xs
<ISA_PRF> lemma reachable_append: "reachable g (xs @ ys) = reachable g xs \<union> reachable g ys" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (xs @ ys) = reachable g xs \<union> reachable g ys
<ISA_PRF> lemma reachable_append: "reachable g (xs @ ys) = reachable g xs \<union> reachable g ys" \n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\<^sup>* `` set (xs @ ys) = (set g)\<^sup>* `` set xs \<union> (set g)\<^sup>* `` set ys
<ISA_PRF> lemma reachable_nexts: "reachable g (nexts g x) \<subseteq> reachable g [x]" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (nexts g x) \<subseteq> reachable g [x]
<ISA_PRF> lemma reachable_nexts: "reachable g (nexts g x) \<subseteq> reachable g [x]" \n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\<^sup>* `` set (nexts g x) \<subseteq> (set g)\<^sup>* `` set [x]
<ISA_PRF> lemma visit_subset_dfs: "set ys \<subseteq> set (dfs g xs ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set ys \<subseteq> set (dfs g xs ys)
<ISA_PRF> theorem "y \<in> set (dfs g [x] []) = ((x,y) \<in> (set g)\<^sup>*)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (y \<in> set (dfs g [x] [])) = ((x, y) \<in> (set g)\<^sup>*)
<ISA_PRF> theorem "y \<in> set (dfs g [x] []) = ((x,y) \<in> (set g)\<^sup>*)" \n by(simp only:dfs_eq_reachable reachable_def, auto) <ISA_OBS> proof (prove) goal (1 subgoal): 1. OFCLASS(node, equal_class)
<ISA_PRF> theorem "y \<in> set (dfs g [x] []) = ((x,y) \<in> (set g)\<^sup>*)" \n by(simp only:dfs_eq_reachable reachable_def, auto) \n proof <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>x y. equal_class.equal x y = (x = y)
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g xs \<subseteq> reachable g (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\<^sup>* `` set xs \<subseteq> (set g)\<^sup>* `` set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) <ISA_OBS> proof (state) this: reachable g xs \<subseteq> reachable g (dfs g xs []) goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also <ISA_OBS> proof (state) this: reachable g xs \<subseteq> reachable g (dfs g xs []) goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" <ISA_OBS> proof (prove) goal (1 subgoal): 1. reachable g (dfs g xs []) = set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def <ISA_OBS> proof (prove) goal (1 subgoal): 1. (set g)\<^sup>* `` set (dfs g xs []) = set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) <ISA_OBS> proof (state) goal (1 subgoal): 1. set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs <ISA_OBS> proof (chain) picking this: nextss ?g (dfs ?g ?xs []) \<subseteq> set (dfs ?g ?xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs \n show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])" <ISA_OBS> proof (prove) using this: nextss ?g (dfs ?g ?xs []) \<subseteq> set (dfs ?g ?xs []) goal (1 subgoal): 1. set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs \n show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])" \n by (simp add: nextss_def) <ISA_OBS> proof (state) this: set g `` set (dfs g xs []) \<subseteq> set (dfs g xs []) goal: No subgoals!
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs \n show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])" \n by (simp add: nextss_def) \n qed <ISA_OBS> proof (state) this: reachable g (dfs g xs []) = set (dfs g xs []) goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs \n show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])" \n by (simp add: nextss_def) \n qed \n finally <ISA_OBS> proof (chain) picking this: reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs \n show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])" \n by (simp add: nextss_def) \n qed \n finally \n show ?thesis <ISA_OBS> proof (prove) using this: reachable g xs \<subseteq> set (dfs g xs []) goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma reachable_closed_dfs: "reachable g xs \<subseteq> set(dfs g xs [])" \n proof - \n have "reachable g xs \<subseteq> reachable g (dfs g xs [])" \n unfolding reachable_def \n by (rule Image_mono) (auto simp add: next_subset_dfs) \n also \n have "\<dots> = set(dfs g xs [])" \n unfolding reachable_def \n proof (rule Image_closed_trancl) \n from nextss_closed_dfs \n show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])" \n by (simp add: nextss_def) \n qed \n finally \n show ?thesis \n . <ISA_OBS> proof (state) this: reachable g xs \<subseteq> set (dfs g xs []) goal: No subgoals!
<ISA_PRF> theorem dfs_eq_reachable: "set (dfs g xs []) = reachable g xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g xs []) = reachable g xs
<ISA_PRF> theorem dfs_eq_reachable: "set (dfs g xs []) = reachable g xs" \n proof <ISA_OBS> proof (state) goal (2 subgoals): 1. set (dfs g xs []) \<subseteq> reachable g xs 2. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> theorem dfs_eq_reachable: "set (dfs g xs []) = reachable g xs" \n proof \n have "set (dfs g xs []) \<subseteq> reachable g xs \<union> set []" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (dfs g xs []) \<subseteq> reachable g xs \<union> set []
<ISA_PRF> theorem dfs_eq_reachable: "set (dfs g xs []) = reachable g xs" \n proof \n have "set (dfs g xs []) \<subseteq> reachable g xs \<union> set []" \n by (rule dfs_subset_reachable_visit_nodes[of g xs "[]"]) <ISA_OBS> proof (state) this: set (dfs g xs []) \<subseteq> reachable g xs \<union> set [] goal (2 subgoals): 1. set (dfs g xs []) \<subseteq> reachable g xs 2. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> theorem dfs_eq_reachable: "set (dfs g xs []) = reachable g xs" \n proof \n have "set (dfs g xs []) \<subseteq> reachable g xs \<union> set []" \n by (rule dfs_subset_reachable_visit_nodes[of g xs "[]"]) \n thus "set (dfs g xs []) \<subseteq> reachable g xs" <ISA_OBS> proof (prove) using this: set (dfs g xs []) \<subseteq> reachable g xs \<union> set [] goal (1 subgoal): 1. set (dfs g xs []) \<subseteq> reachable g xs
<ISA_PRF> theorem dfs_eq_reachable: "set (dfs g xs []) = reachable g xs" \n proof \n have "set (dfs g xs []) \<subseteq> reachable g xs \<union> set []" \n by (rule dfs_subset_reachable_visit_nodes[of g xs "[]"]) \n thus "set (dfs g xs []) \<subseteq> reachable g xs" \n by simp <ISA_OBS> proof (state) this: set (dfs g xs []) \<subseteq> reachable g xs goal (1 subgoal): 1. reachable g xs \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma nextss_closed_dfs: "nextss g (dfs g xs []) \<subseteq> set (dfs g xs [])" <ISA_OBS> proof (prove) goal (1 subgoal): 1. nextss g (dfs g xs []) \<subseteq> set (dfs g xs [])
<ISA_PRF> lemma nextss_closed_dfs'[rule_format]: "nextss g ys \<subseteq> set xs \<union> set ys \<longrightarrow> nextss g (dfs g xs ys) \<subseteq> set (dfs g xs ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. nextss g ys \<subseteq> set xs \<union> set ys \<longrightarrow> nextss g (dfs g xs ys) \<subseteq> set (dfs g xs ys)
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" \n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ <ISA_OBS> proof (prove) goal (1 subgoal): 1. All dfs2_dom
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" \n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") <ISA_OBS> proof (prove) goal (4 subgoals): 1. wf (inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))) 2. \<And>g x xs ys. List.member ys x \<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 3. \<And>g x xs ys. \<not> List.member ys x \<Longrightarrow> ((g, nexts g x, x # ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 4. \<And>g x xs ys. \<lbrakk>\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\<rbrakk> \<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" \n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] <ISA_OBS> proof (prove) goal (3 subgoals): 1. \<And>g x xs ys. List.member ys x \<Longrightarrow> ((g, xs, ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 2. \<And>g x xs ys. \<not> List.member ys x \<Longrightarrow> ((g, nexts g x, x # ys), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs)) 3. \<And>g x xs ys. \<lbrakk>\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\<rbrakk> \<Longrightarrow> ((g, xs, dfs2 g (nexts g x) (x # ys)), g, x # xs, ys) \<in> inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g, xs, ys). (nodes_of g - set ys, length xs))
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" \n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] \n apply (simp_all add: finite_psubset_def) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>g x xs ys. \<not> List.member ys x \<Longrightarrow> nodes_of g - insert x (set ys) \<subset> nodes_of g - set ys \<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \<and> length (nexts g x) < Suc (length xs) 2. \<And>g x ys. \<lbrakk>\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\<rbrakk> \<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) \<subset> nodes_of g - set ys \<or> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) = nodes_of g - set ys
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" \n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] \n apply (simp_all add: finite_psubset_def) \n apply (case_tac "x \<in> nodes_of g") <ISA_OBS> proof (prove) goal (3 subgoals): 1. \<And>g x xs ys. \<lbrakk>\<not> List.member ys x; x \<in> nodes_of g\<rbrakk> \<Longrightarrow> nodes_of g - insert x (set ys) \<subset> nodes_of g - set ys \<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \<and> length (nexts g x) < Suc (length xs) 2. \<And>g x xs ys. \<lbrakk>\<not> List.member ys x; x \<notin> nodes_of g\<rbrakk> \<Longrightarrow> nodes_of g - insert x (set ys) \<subset> nodes_of g - set ys \<or> nodes_of g - insert x (set ys) = nodes_of g - set ys \<and> length (nexts g x) < Suc (length xs) 3. \<And>g x ys. \<lbrakk>\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\<rbrakk> \<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) \<subset> nodes_of g - set ys \<or> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) = nodes_of g - set ys
<ISA_PRF> lemma dfs2_invariant: "dfs2_dom (g, xs, ys) \<Longrightarrow> set ys \<subseteq> set (dfs2 g xs ys)" \n by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+ \n apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))") \n apply auto[1] \n apply (simp_all add: finite_psubset_def) \n apply (case_tac "x \<in> nodes_of g") \n apply (auto simp add: List.member_def)[2] <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>g x ys. \<lbrakk>\<not> List.member ys x; dfs2_dom (g, nexts g x, x # ys)\<rbrakk> \<Longrightarrow> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) \<subset> nodes_of g - set ys \<or> nodes_of g - set (dfs2 g (nexts g x) (x # ys)) = nodes_of g - set ys
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set xs \<subseteq> set (dfs g xs ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>g ys. set [] \<subseteq> set (dfs g [] ys) 2. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys); \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\<rbrakk> \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) <ISA_OBS> proof (state) this: List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys) \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) goal (2 subgoals): 1. \<And>g ys. set [] \<subseteq> set (dfs g [] ys) 2. \<And>g x xs ys. \<lbrakk>List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys); \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys))\<rbrakk> \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") <ISA_OBS> proof (state) goal (2 subgoals): 1. x \<in> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys) 2. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True <ISA_OBS> proof (state) this: x \<in> set ys goal (2 subgoals): 1. x \<in> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys) 2. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set ys \<subseteq> set (dfs g xs ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) <ISA_OBS> proof (state) this: set ys \<subseteq> set (dfs g xs ys) goal (2 subgoals): 1. x \<in> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys) 2. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True <ISA_OBS> proof (chain) picking this: List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys) \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \<in> set ys set ys \<subseteq> set (dfs g xs ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis <ISA_OBS> proof (prove) using this: List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys) \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \<in> set ys set ys \<subseteq> set (dfs g xs ys) goal (1 subgoal): 1. set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) <ISA_OBS> proof (state) this: set (x # xs) \<subseteq> set (dfs g (x # xs) ys) goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False <ISA_OBS> proof (state) this: x \<notin> set ys goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False \n have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (x # ys) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys))
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False \n have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))" \n by(rule visit_subset_dfs) <ISA_OBS> proof (state) this: set (x # ys) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) goal (1 subgoal): 1. x \<notin> set ys \<Longrightarrow> set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False \n have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))" \n by(rule visit_subset_dfs) \n with 2 and False <ISA_OBS> proof (chain) picking this: List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys) \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \<notin> set ys set (x # ys) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys))
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False \n have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))" \n by(rule visit_subset_dfs) \n with 2 and False \n show ?thesis <ISA_OBS> proof (prove) using this: List.member ys x \<Longrightarrow> set xs \<subseteq> set (dfs g xs ys) \<not> List.member ys x \<Longrightarrow> set (nexts g x @ xs) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) x \<notin> set ys set (x # ys) \<subseteq> set (dfs g (nexts g x @ xs) (x # ys)) goal (1 subgoal): 1. set (x # xs) \<subseteq> set (dfs g (x # xs) ys)
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False \n have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))" \n by(rule visit_subset_dfs) \n with 2 and False \n show ?thesis \n by (auto simp add: List.member_def) <ISA_OBS> proof (state) this: set (x # xs) \<subseteq> set (dfs g (x # xs) ys) goal: No subgoals!
<ISA_PRF> lemma next_subset_dfs: "set xs \<subseteq> set (dfs g xs ys)" \n proof(induct g xs ys rule:dfs.induct) \n case(2 g x xs ys) \n show ?case \n proof(cases "x \<in> set ys") \n case True \n have "set ys \<subseteq> set (dfs g xs ys)" \n by (rule visit_subset_dfs) \n with 2 and True \n show ?thesis \n by (auto simp add: List.member_def) \n next \n case False \n have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))" \n by(rule visit_subset_dfs) \n with 2 and False \n show ?thesis \n by (auto simp add: List.member_def) \n qed <ISA_OBS> proof (state) this: set (x # xs) \<subseteq> set (dfs g (x # xs) ys) goal (1 subgoal): 1. \<And>g ys. set [] \<subseteq> set (dfs g [] ys)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, x, r\<rangle> \<Longrightarrow> braun (merge l r) \<and> size (merge l r) = size l + size r
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) <ISA_OBS> proof (prove) goal (3 subgoals): 1. \<And>l. braun \<langle>l, x, \<langle>\<rangle>\<rangle> \<Longrightarrow> braun (merge l \<langle>\<rangle>) \<and> size (merge l \<langle>\<rangle>) = size l + size \<langle>\<rangle> 2. \<And>l1 a1 r1 l2 a2 r2. \<lbrakk>\<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>\<rbrakk> \<Longrightarrow> braun (merge l1 r1) \<and> size (merge l1 r1) = size l1 + size r1; braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle>\<rbrakk> \<Longrightarrow> braun (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) \<and> size (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) = size \<langle>l1, a1, r1\<rangle> + size \<langle>l2, a2, r2\<rangle> 3. \<And>v va vb. braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle> \<Longrightarrow> braun (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>) \<and> size (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>) = size \<langle>\<rangle> + size \<langle>v, va, vb\<rangle>
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done <ISA_OBS> proof (prove) goal (1 subgoal): 1. Priority_Queue \<langle>\<rangle> (\<lambda>h. h = \<langle>\<rangle>) insert get_min del_min2 (\<lambda>h. braun h \<and> heap h) mset_tree
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) <ISA_OBS> proof (state) goal (8 subgoals): 1. mset_tree \<langle>\<rangle> = {#} 2. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 7. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 8. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 <ISA_OBS> proof (state) this: goal (8 subgoals): 1. mset_tree \<langle>\<rangle> = {#} 2. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 7. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 8. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree \<langle>\<rangle> = {#}
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp <ISA_OBS> proof (state) this: mset_tree \<langle>\<rangle> = {#} goal (7 subgoals): 1. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 6. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 7. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next <ISA_OBS> proof (state) goal (7 subgoals): 1. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 6. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 7. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ goal (7 subgoals): 1. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 6. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 7. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. (q_ = \<langle>\<rangle>) = (mset_tree q_ = {#})
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp <ISA_OBS> proof (state) this: (q_ = \<langle>\<rangle>) = (mset_tree q_ = {#}) goal (6 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 5. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 6. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next <ISA_OBS> proof (state) goal (6 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 5. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 6. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ goal (6 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 5. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 6. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) <ISA_OBS> proof (state) this: mset_tree (insert x_ q_) = mset_tree q_ + {#x_#} goal (5 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 4. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next <ISA_OBS> proof (state) goal (5 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 4. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (5 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min2 q) = mset_tree q - {#get_min q#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 4. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#}
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) <ISA_OBS> proof (state) this: mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#} goal (4 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next <ISA_OBS> proof (state) goal (4 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (4 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} \<lbrakk>heap ?t; ?t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t) mset_tree \<langle>\<rangle> = {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast <ISA_OBS> proof (state) this: get_min q_ = Min_mset (mset_tree q_) goal (3 subgoals): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next <ISA_OBS> proof (state) goal (3 subgoals): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 <ISA_OBS> proof (state) this: goal (3 subgoals): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle>
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) <ISA_OBS> proof (state) this: braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> goal (2 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ goal (2 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ goal (1 subgoal): 1. braun (insert x_ q_) \<and> heap (insert x_ q_)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) <ISA_OBS> proof (state) this: braun (insert x_ q_) \<and> heap (insert x_ q_) goal (1 subgoal): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next \n case 8 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min2 q) \<and> heap (del_min2 q)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next \n case 8 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. braun (del_min2 q_) \<and> heap (del_min2 q_)
<ISA_PRF> lemma braun_size_merge: "braun (Node l x r) \<Longrightarrow> braun(merge l r) \<and> size(merge l r) = size l + size r" \n apply(induction l r rule: merge.induct) \n apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split) \n done \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(auto simp: mset_tree_merge neq_Leaf_iff) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next \n case 8 \n thus ?case \n by(auto simp: heap_merge braun_size_merge neq_Leaf_iff) <ISA_OBS> proof (state) this: braun (del_min2 q_) \<and> heap (del_min2 q_) goal: No subgoals!
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>braun \<langle>l, x, r\<rangle>; heap l; heap r\<rbrakk> \<Longrightarrow> heap (merge l r)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) <ISA_OBS> proof (state) goal (3 subgoals): 1. \<And>l. \<lbrakk>braun \<langle>l, x, \<langle>\<rangle>\<rangle>; heap l; heap \<langle>\<rangle>\<rbrakk> \<Longrightarrow> heap (merge l \<langle>\<rangle>) 2. \<And>l1 a1 r1 l2 a2 r2. \<lbrakk>\<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1); braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle>; heap \<langle>l1, a1, r1\<rangle>; heap \<langle>l2, a2, r2\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 3. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 <ISA_OBS> proof (state) this: braun \<langle>l_, x, \<langle>\<rangle>\<rangle> heap l_ heap \<langle>\<rangle> goal (3 subgoals): 1. \<And>l. \<lbrakk>braun \<langle>l, x, \<langle>\<rangle>\<rangle>; heap l; heap \<langle>\<rangle>\<rbrakk> \<Longrightarrow> heap (merge l \<langle>\<rangle>) 2. \<And>l1 a1 r1 l2 a2 r2. \<lbrakk>\<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1); braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle>; heap \<langle>l1, a1, r1\<rangle>; heap \<langle>l2, a2, r2\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 3. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case <ISA_OBS> proof (prove) using this: braun \<langle>l_, x, \<langle>\<rangle>\<rangle> heap l_ heap \<langle>\<rangle> goal (1 subgoal): 1. heap (merge l_ \<langle>\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp <ISA_OBS> proof (state) this: heap (merge l_ \<langle>\<rangle>) goal (2 subgoals): 1. \<And>l1 a1 r1 l2 a2 r2. \<lbrakk>\<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1); braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle>; heap \<langle>l1, a1, r1\<rangle>; heap \<langle>l2, a2, r2\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 2. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>l1 a1 r1 l2 a2 r2. \<lbrakk>\<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1); braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle>; heap \<langle>l1, a1, r1\<rangle>; heap \<langle>l2, a2, r2\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 2. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) <ISA_OBS> proof (state) this: \<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1) braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle> heap \<langle>l1, a1, r1\<rangle> heap \<langle>l2, a2, r2\<rangle> goal (2 subgoals): 1. \<And>l1 a1 r1 l2 a2 r2. \<lbrakk>\<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1); braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle>; heap \<langle>l1, a1, r1\<rangle>; heap \<langle>l2, a2, r2\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 2. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases <ISA_OBS> proof (state) goal (2 subgoals): 1. ?P \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 2. \<not> ?P \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" <ISA_OBS> proof (state) this: a1 \<le> a2 goal (2 subgoals): 1. ?P \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) 2. \<not> ?P \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis <ISA_OBS> proof (prove) using this: a1 \<le> a2 goal (1 subgoal): 1. heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 <ISA_OBS> proof (prove) using this: a1 \<le> a2 \<lbrakk>a1 \<le> a2; braun \<langle>l1, x, r1\<rangle>; heap l1; heap r1\<rbrakk> \<Longrightarrow> heap (merge l1 r1) braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle> heap \<langle>l1, a1, r1\<rangle> heap \<langle>l2, a2, r2\<rangle> goal (1 subgoal): 1. heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) <ISA_OBS> proof (state) this: heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" <ISA_OBS> proof (state) this: \<not> a1 \<le> a2 goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" <ISA_OBS> proof (state) goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" <ISA_OBS> proof (state) goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l2, a2, r2\<rangle>
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) <ISA_OBS> proof (prove) using this: braun \<langle>\<langle>l1, a1, r1\<rangle>, x, \<langle>l2, a2, r2\<rangle>\<rangle> goal (1 subgoal): 1. braun \<langle>l2, a2, r2\<rangle>
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto <ISA_OBS> proof (state) this: braun \<langle>l2, a2, r2\<rangle> goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\<And>x l'. del_left \<langle>l1, a1, r1\<rangle> = (x, l') \<Longrightarrow> thesis) \<Longrightarrow> thesis
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) <ISA_OBS> proof (state) this: del_left \<langle>l1, a1, r1\<rangle> = (x, l') goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] <ISA_OBS> proof (chain) picking this: \<langle>l1, a1, r1\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> heap l'
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" <ISA_OBS> proof (prove) using this: \<langle>l1, a1, r1\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> heap l' goal (1 subgoal): 1. heap l'
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto <ISA_OBS> proof (state) this: heap l' goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap (replace_min x \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) <ISA_OBS> proof (prove) using this: braun \<langle>l2, a2, r2\<rangle> heap \<langle>l2, a2, r2\<rangle> goal (1 subgoal): 1. heap (replace_min x \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) <ISA_OBS> proof (state) this: heap (replace_min x \<langle>l2, a2, r2\<rangle>) goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> <ISA_OBS> proof (prove) using this: heap \<langle>l1, a1, r1\<rangle> \<not> a1 \<le> a2 goal (1 subgoal): 1. \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) <ISA_OBS> proof (state) this: \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover <ISA_OBS> proof (state) this: \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set_tree l' \<subseteq> set_tree \<langle>l1, a1, r1\<rangle> &&& x \<in> set_tree \<langle>l1, a1, r1\<rangle>
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] <ISA_OBS> proof (prove) using this: \<langle>l1, a1, r1\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> x \<in># mset_tree \<langle>l1, a1, r1\<rangle> \<and> mset_tree l' = mset_tree \<langle>l1, a1, r1\<rangle> - {#x#} goal (1 subgoal): 1. set_tree l' \<subseteq> set_tree \<langle>l1, a1, r1\<rangle> &&& x \<in> set_tree \<langle>l1, a1, r1\<rangle>
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) <ISA_OBS> proof (state) this: set_tree l' \<subseteq> set_tree \<langle>l1, a1, r1\<rangle> x \<in> set_tree \<langle>l1, a1, r1\<rangle> goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately <ISA_OBS> proof (chain) picking this: \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x set_tree l' \<subseteq> set_tree \<langle>l1, a1, r1\<rangle> x \<in> set_tree \<langle>l1, a1, r1\<rangle>
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" <ISA_OBS> proof (prove) using this: \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x set_tree l' \<subseteq> set_tree \<langle>l1, a1, r1\<rangle> x \<in> set_tree \<langle>l1, a1, r1\<rangle> goal (1 subgoal): 1. \<forall>x\<in>set_tree l'. a2 \<le> x
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast <ISA_OBS> proof (state) this: \<forall>x\<in>set_tree l'. a2 \<le> x goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<forall>x\<in>set_tree \<langle>l2, a2, r2\<rangle>. a2 \<le> x
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> <ISA_OBS> proof (prove) using this: heap \<langle>l2, a2, r2\<rangle> goal (1 subgoal): 1. \<forall>x\<in>set_tree \<langle>l2, a2, r2\<rangle>. a2 \<le> x
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto <ISA_OBS> proof (state) this: \<forall>x\<in>set_tree \<langle>l2, a2, r2\<rangle>. a2 \<le> x goal (1 subgoal): 1. \<not> a1 \<le> a2 \<Longrightarrow> heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis <ISA_OBS> proof (prove) using this: \<forall>x\<in>set_tree \<langle>l2, a2, r2\<rangle>. a2 \<le> x goal (1 subgoal): 1. heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> <ISA_OBS> proof (prove) using this: \<forall>x\<in>set_tree \<langle>l2, a2, r2\<rangle>. a2 \<le> x \<not> a1 \<le> a2 del_left \<langle>l1, a1, r1\<rangle> = (x, l') heap (replace_min x \<langle>l2, a2, r2\<rangle>) heap l' x \<in> set_tree \<langle>l1, a1, r1\<rangle> \<forall>x\<in>set_tree \<langle>l1, a1, r1\<rangle>. a2 \<le> x \<forall>x\<in>set_tree l'. a2 \<le> x braun \<langle>l2, a2, r2\<rangle> goal (1 subgoal): 1. heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> \n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) <ISA_OBS> proof (state) this: heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) goal: No subgoals!
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> \n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \n qed <ISA_OBS> proof (state) this: heap (merge \<langle>l1, a1, r1\<rangle> \<langle>l2, a2, r2\<rangle>) goal (1 subgoal): 1. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> \n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \n qed \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> \n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \n qed \n next \n case 3 <ISA_OBS> proof (state) this: braun \<langle>\<langle>\<rangle>, x, \<langle>v_, va_, vb_\<rangle>\<rangle> heap \<langle>\<rangle> heap \<langle>v_, va_, vb_\<rangle> goal (1 subgoal): 1. \<And>v va vb. \<lbrakk>braun \<langle>\<langle>\<rangle>, x, \<langle>v, va, vb\<rangle>\<rangle>; heap \<langle>\<rangle>; heap \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> heap (merge \<langle>\<rangle> \<langle>v, va, vb\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> \n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \n qed \n next \n case 3 \n thus ?case <ISA_OBS> proof (prove) using this: braun \<langle>\<langle>\<rangle>, x, \<langle>v_, va_, vb_\<rangle>\<rangle> heap \<langle>\<rangle> heap \<langle>v_, va_, vb_\<rangle> goal (1 subgoal): 1. heap (merge \<langle>\<rangle> \<langle>v_, va_, vb_\<rangle>)
<ISA_PRF> lemma heap_merge: "\<lbrakk> braun (Node l x r); heap l; heap r \<rbrakk> \<Longrightarrow> heap(merge l r)" \n proof(induction l r rule: merge.induct) \n case 1 \n thus ?case \n by simp \n next \n case (2 l1 a1 r1 l2 a2 r2) \n show ?case \n proof cases \n assume "a1 \<le> a2" \n thus ?thesis \n using 2 \n by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree) \n next \n assume "\<not> a1 \<le> a2" \n let ?l = "Node l1 a1 r1" \n let ?r = "Node l2 a2 r2" \n have "braun ?r" \n using "2.prems"(1) \n by auto \n obtain x l' where dl: "del_left ?l = (x, l')" \n by (metis surj_pair) \n from del_left_heap[OF this _ "2.prems"(2)] \n have "heap l'" \n by auto \n have hr: "heap(replace_min x ?r)" \n using \<open>braun ?r\<close> "2.prems"(3) \n by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps) \n have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x" \n using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close> \n by (auto simp: ball_Un) \n moreover \n have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l" \n using del_left_mset[OF dl] \n by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff) \n ultimately \n have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x" \n by blast \n have "\<forall>x \<in> set_tree ?r. a2 \<le> x" \n using \<open>heap ?r\<close> \n by auto \n thus ?thesis \n using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close> \n by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps) \n qed \n next \n case 3 \n thus ?case \n by simp <ISA_OBS> proof (state) this: heap (merge \<langle>\<rangle> \<langle>v_, va_, vb_\<rangle>) goal: No subgoals!
<ISA_PRF> lemma del_left_braun_size: "del_left t = (x,t') \<Longrightarrow> braun t \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> braun t' \<and> size t = size t' + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); braun t; t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> braun t' \<and> size t = size t' + 1
<ISA_PRF> lemma replace_min_sift_down: "braun (Node l a r) \<Longrightarrow> replace_min x (Node l a r) = sift_down l x r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, a, r\<rangle> \<Longrightarrow> replace_min x \<langle>l, a, r\<rangle> = sift_down l x r
<ISA_PRF> lemma mset_tree_merge: "braun (Node l x r) \<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, x, r\<rangle> \<Longrightarrow> mset_tree (merge l r) = mset_tree l + mset_tree r
<ISA_PRF> lemma set_insert[simp]: "set_tree(insert x t) = {x} \<union> (set_tree t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set_tree (insert x t) = {x} \<union> set_tree t
<ISA_PRF> lemma size_insert[simp]: "size(insert x t) = size t + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (insert x t) = size t + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> 2 ^ height t \<le> 2 * size t + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) <ISA_OBS> proof (state) goal (2 subgoals): 1. braun \<langle>\<rangle> \<Longrightarrow> 2 ^ height \<langle>\<rangle> \<le> 2 * size \<langle>\<rangle> + 1 2. \<And>t1 x2 t2. \<lbrakk>braun t1 \<Longrightarrow> 2 ^ height t1 \<le> 2 * size t1 + 1; braun t2 \<Longrightarrow> 2 ^ height t2 \<le> 2 * size t2 + 1; braun \<langle>t1, x2, t2\<rangle>\<rbrakk> \<Longrightarrow> 2 ^ height \<langle>t1, x2, t2\<rangle> \<le> 2 * size \<langle>t1, x2, t2\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) <ISA_OBS> proof (state) this: braun t1 \<Longrightarrow> 2 ^ height t1 \<le> 2 * size t1 + 1 braun t2_ \<Longrightarrow> 2 ^ height t2_ \<le> 2 * size t2_ + 1 braun \<langle>t1, x2_, t2_\<rangle> goal (2 subgoals): 1. braun \<langle>\<rangle> \<Longrightarrow> 2 ^ height \<langle>\<rangle> \<le> 2 * size \<langle>\<rangle> + 1 2. \<And>t1 x2 t2. \<lbrakk>braun t1 \<Longrightarrow> 2 ^ height t1 \<le> 2 * size t1 + 1; braun t2 \<Longrightarrow> 2 ^ height t2 \<le> 2 * size t2 + 1; braun \<langle>t1, x2, t2\<rangle>\<rbrakk> \<Longrightarrow> 2 ^ height \<langle>t1, x2, t2\<rangle> \<le> 2 * size \<langle>t1, x2, t2\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") <ISA_OBS> proof (state) goal (2 subgoals): 1. height t1 = 0 \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1 2. \<And>nat. height t1 = Suc nat \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 <ISA_OBS> proof (state) this: height t1 = 0 goal (2 subgoals): 1. height t1 = 0 \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1 2. \<And>nat. height t1 = Suc nat \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis <ISA_OBS> proof (prove) using this: height t1 = 0 goal (1 subgoal): 1. 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node <ISA_OBS> proof (prove) using this: height t1 = 0 braun t1 \<Longrightarrow> 2 ^ height t1 \<le> 2 * size t1 + 1 braun t2_ \<Longrightarrow> 2 ^ height t2_ \<le> 2 * size t2_ + 1 braun \<langle>t1, x2_, t2_\<rangle> goal (1 subgoal): 1. 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp <ISA_OBS> proof (state) this: 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1 goal (1 subgoal): 1. \<And>nat. height t1 = Suc nat \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>nat. height t1 = Suc nat \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) <ISA_OBS> proof (state) this: height t1 = Suc n goal (1 subgoal): 1. \<And>nat. height t1 = Suc nat \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" <ISA_OBS> proof (prove) using this: height t1 = Suc n goal (1 subgoal): 1. 2 ^ n \<le> size t1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" \n using Node <ISA_OBS> proof (prove) using this: height t1 = Suc n braun t1 \<Longrightarrow> 2 ^ height t1 \<le> 2 * size t1 + 1 braun t2_ \<Longrightarrow> 2 ^ height t2_ \<le> 2 * size t2_ + 1 braun \<langle>t1, x2_, t2_\<rangle> goal (1 subgoal): 1. 2 ^ n \<le> size t1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" \n using Node \n by simp <ISA_OBS> proof (state) this: 2 ^ n \<le> size t1 goal (1 subgoal): 1. \<And>nat. height t1 = Suc nat \<Longrightarrow> 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" \n using Node \n by simp \n thus ?thesis <ISA_OBS> proof (prove) using this: 2 ^ n \<le> size t1 goal (1 subgoal): 1. 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" \n using Node \n by simp \n thus ?thesis \n using Suc Node <ISA_OBS> proof (prove) using this: 2 ^ n \<le> size t1 height t1 = Suc n braun t1 \<Longrightarrow> 2 ^ height t1 \<le> 2 * size t1 + 1 braun t2_ \<Longrightarrow> 2 ^ height t2_ \<le> 2 * size t2_ + 1 braun \<langle>t1, x2_, t2_\<rangle> goal (1 subgoal): 1. 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" \n using Node \n by simp \n thus ?thesis \n using Suc Node \n by(auto simp: max_def) <ISA_OBS> proof (state) this: 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1 goal: No subgoals!
<ISA_PRF> lemma height_size_braun: "braun t \<Longrightarrow> 2 ^ (height t) \<le> 2 * size t + 1" \n proof(induction t) \n case (Node t1) \n show ?case \n proof (cases "height t1") \n case 0 \n thus ?thesis \n using Node \n by simp \n next \n case (Suc n) \n hence "2 ^ n \<le> size t1" \n using Node \n by simp \n thus ?thesis \n using Suc Node \n by(auto simp: max_def) \n qed <ISA_OBS> proof (state) this: 2 ^ height \<langle>t1, x2_, t2_\<rangle> \<le> 2 * size \<langle>t1, x2_, t2_\<rangle> + 1 goal (1 subgoal): 1. braun \<langle>\<rangle> \<Longrightarrow> 2 ^ height \<langle>\<rangle> \<le> 2 * size \<langle>\<rangle> + 1
<ISA_PRF> lemma del_left_set: "del_left t = (x,t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> set_tree t = {x} \<union> set_tree t'" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> set_tree t = {x} \<union> set_tree t'
<ISA_PRF> lemma mset_insert: "mset_tree(insert x t) = {#x#} + mset_tree t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (insert x t) = {#x#} + mset_tree t
<ISA_PRF> lemma heap_insert: "heap t \<Longrightarrow> heap(insert x t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap t \<Longrightarrow> heap (insert x t)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) <ISA_OBS> proof (state) goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 <ISA_OBS> proof (state) this: t = \<langle>\<rangle> goal (3 subgoals): 1. t = \<langle>\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 3. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms <ISA_OBS> proof (chain) picking this: braun t t \<noteq> \<langle>\<rangle> t = \<langle>\<rangle>
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis <ISA_OBS> proof (prove) using this: braun t t \<noteq> \<langle>\<rangle> t = \<langle>\<rangle> goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp <ISA_OBS> proof (state) this: mset_tree (del_min t) = mset_tree t - {#get_min t#} goal (2 subgoals): 1. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 <ISA_OBS> proof (state) this: t = \<langle>\<langle>\<rangle>, x_, r_\<rangle> goal (2 subgoals): 1. \<And>x r. t = \<langle>\<langle>\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#} 2. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms <ISA_OBS> proof (chain) picking this: braun t t \<noteq> \<langle>\<rangle> t = \<langle>\<langle>\<rangle>, x_, r_\<rangle>
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis <ISA_OBS> proof (prove) using this: braun t t \<noteq> \<langle>\<rangle> t = \<langle>\<langle>\<rangle>, x_, r_\<rangle> goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) <ISA_OBS> proof (state) this: mset_tree (del_min t) = mset_tree t - {#get_min t#} goal (1 subgoal): 1. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) <ISA_OBS> proof (state) this: t = \<langle>\<langle>ll, b, lr\<rangle>, a, r\<rangle> goal (1 subgoal): 1. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] <ISA_OBS> proof (prove) using this: braun t t \<noteq> \<langle>\<rangle> \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> y \<in># mset_tree \<langle>ll, b, lr\<rangle> \<and> mset_tree l' = mset_tree \<langle>ll, b, lr\<rangle> - {#y#} \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> size \<langle>ll, b, lr\<rangle> = size l' + 1 \<lbrakk>braun \<langle>ll, b, lr\<rangle>; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> braun l' \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> mset_tree \<langle>ll, b, lr\<rangle> = {#y#} + mset_tree l' goal (1 subgoal): 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<lbrakk>braun t; t \<noteq> \<langle>\<rangle>; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> y \<in># mset_tree \<langle>ll, b, lr\<rangle> \<and> mset_tree l' = mset_tree \<langle>ll, b, lr\<rangle> - {#y#}; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> size \<langle>ll, b, lr\<rangle> = size l' + 1; \<lbrakk>braun \<langle>ll, b, lr\<rangle>; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> braun l'; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> mset_tree \<langle>ll, b, lr\<rangle> = {#y#} + mset_tree l'\<rbrakk> \<Longrightarrow> braun \<langle>r, y, l'\<rangle> 2. \<lbrakk>braun t; t \<noteq> \<langle>\<rangle>; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> y \<in># mset_tree \<langle>ll, b, lr\<rangle> \<and> mset_tree l' = mset_tree \<langle>ll, b, lr\<rangle> - {#y#}; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> size \<langle>ll, b, lr\<rangle> = size l' + 1; \<lbrakk>braun \<langle>ll, b, lr\<rangle>; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> braun l'; \<langle>ll, b, lr\<rangle> \<noteq> \<langle>\<rangle> \<Longrightarrow> mset_tree \<langle>ll, b, lr\<rangle> = {#y#} + mset_tree l'\<rbrakk> \<Longrightarrow> {#y#} + (mset_tree r + mset_tree l') = mset_tree t - {#a#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done <ISA_OBS> proof (state) this: del_left \<langle>ll, b, lr\<rangle> = (?y, ?l') \<Longrightarrow> mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#} goal (1 subgoal): 1. \<And>v va vb x r. t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle> \<Longrightarrow> mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis <ISA_OBS> proof (prove) using this: del_left \<langle>ll, b, lr\<rangle> = (?y, ?l') \<Longrightarrow> mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#} goal (1 subgoal): 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) <ISA_OBS> proof (state) this: mset_tree (del_min t) = mset_tree t - {#get_min t#} goal: No subgoals!
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed <ISA_OBS> proof (prove) goal (1 subgoal): 1. Priority_Queue \<langle>\<rangle> (\<lambda>h. h = \<langle>\<rangle>) insert get_min del_min (\<lambda>h. braun h \<and> heap h) mset_tree
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) <ISA_OBS> proof (state) goal (8 subgoals): 1. mset_tree \<langle>\<rangle> = {#} 2. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 7. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 8. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 <ISA_OBS> proof (state) this: goal (8 subgoals): 1. mset_tree \<langle>\<rangle> = {#} 2. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 6. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 7. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 8. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree \<langle>\<rangle> = {#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp <ISA_OBS> proof (state) this: mset_tree \<langle>\<rangle> = {#} goal (7 subgoals): 1. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 6. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 7. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next <ISA_OBS> proof (state) goal (7 subgoals): 1. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 6. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 7. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ goal (7 subgoals): 1. \<And>q. braun q \<and> heap q \<Longrightarrow> (q = \<langle>\<rangle>) = (mset_tree q = {#}) 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 5. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 6. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 7. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. (q_ = \<langle>\<rangle>) = (mset_tree q_ = {#})
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp <ISA_OBS> proof (state) this: (q_ = \<langle>\<rangle>) = (mset_tree q_ = {#}) goal (6 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 5. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 6. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next <ISA_OBS> proof (state) goal (6 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 5. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 6. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ goal (6 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> mset_tree (insert x q) = mset_tree q + {#x#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 4. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 5. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 6. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) <ISA_OBS> proof (state) this: mset_tree (insert x_ q_) = mset_tree q_ + {#x_#} goal (5 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 4. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next <ISA_OBS> proof (state) goal (5 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 4. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (5 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#} 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 3. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 4. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 5. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) <ISA_OBS> proof (state) this: mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#} goal (4 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next <ISA_OBS> proof (state) goal (4 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (4 subgoals): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> get_min q = Min_mset (mset_tree q) 2. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 3. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 4. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} \<lbrakk>heap ?t; ?t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t) mset_tree \<langle>\<rangle> = {#} goal (1 subgoal): 1. get_min q_ = Min_mset (mset_tree q_)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast <ISA_OBS> proof (state) this: get_min q_ = Min_mset (mset_tree q_) goal (3 subgoals): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next <ISA_OBS> proof (state) goal (3 subgoals): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 <ISA_OBS> proof (state) this: goal (3 subgoals): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> 2. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 3. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>\<rangle> \<and> heap \<langle>\<rangle>
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) <ISA_OBS> proof (state) this: braun \<langle>\<rangle> \<and> heap \<langle>\<rangle> goal (2 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ goal (2 subgoals): 1. \<And>q x. braun q \<and> heap q \<Longrightarrow> braun (insert x q) \<and> heap (insert x q) 2. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ goal (1 subgoal): 1. braun (insert x_ q_) \<and> heap (insert x_ q_)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) <ISA_OBS> proof (state) this: braun (insert x_ q_) \<and> heap (insert x_ q_) goal (1 subgoal): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next <ISA_OBS> proof (state) goal (1 subgoal): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next \n case 8 <ISA_OBS> proof (state) this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. \<And>q. \<lbrakk>braun q \<and> heap q; mset_tree q \<noteq> {#}\<rbrakk> \<Longrightarrow> braun (del_min q) \<and> heap (del_min q)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next \n case 8 \n thus ?case <ISA_OBS> proof (prove) using this: braun q_ \<and> heap q_ mset_tree q_ \<noteq> {#} goal (1 subgoal): 1. braun (del_min q_) \<and> heap (del_min q_)
<ISA_PRF> lemma mset_del_min: assumes "braun t" "t \<noteq> Leaf" shows "mset_tree(del_min t) = mset_tree t - {#get_min t#}" \n proof(cases t rule: del_min.cases) \n case 1 \n with assms \n show ?thesis \n by simp \n next \n case 2 \n with assms \n show ?thesis \n by (simp) \n next \n case [simp]: (3 ll b lr a r) \n have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l' \n using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del] \n apply (subst mset_sift_down) \n apply (auto simp: ac_simps del_left_mset_plus[OF del]) \n done \n thus ?thesis \n by(auto split: prod.split) \n qed \n proof(standard, goal_cases) \n case 1 \n show ?case \n by simp \n next \n case 2 \n show ?case \n by simp \n next \n case 3 \n show ?case \n by(simp add: mset_insert) \n next \n case 4 \n thus ?case \n by(simp add: mset_del_min) \n next \n case 5 \n thus ?case \n using get_min mset_tree.simps(1) \n by blast \n next \n case 6 \n thus ?case \n by(simp) \n next \n case 7 \n thus ?case \n by(simp add: heap_insert braun_insert) \n next \n case 8 \n thus ?case \n by(simp add: heap_del_min braun_del_min) <ISA_OBS> proof (state) this: braun (del_min q_) \<and> heap (del_min q_) goal: No subgoals!
<ISA_PRF> lemma get_min: "\<lbrakk> heap t; t \<noteq> Leaf \<rbrakk> \<Longrightarrow> get_min t = Min_mset (mset_tree t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heap t; t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> get_min t = Min_mset (mset_tree t)
<ISA_PRF> lemma del_left_size: "del_left t = (x,t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> size t = size t' + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> size t = size t' + 1
<ISA_PRF> lemma del_left_heap: "del_left t = (x,t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> heap t \<Longrightarrow> heap t'" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); t \<noteq> \<langle>\<rangle>; heap t\<rbrakk> \<Longrightarrow> heap t'
<ISA_PRF> lemma heap_del_min: "heap t \<Longrightarrow> braun t \<Longrightarrow> heap(del_min t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heap t; braun t\<rbrakk> \<Longrightarrow> heap (del_min t)
<ISA_PRF> lemma heap_del_min: "heap t \<Longrightarrow> braun t \<Longrightarrow> heap(del_min t)" \n apply(cases t rule: del_min.cases) <ISA_OBS> proof (prove) goal (3 subgoals): 1. \<lbrakk>heap t; braun t; t = \<langle>\<rangle>\<rbrakk> \<Longrightarrow> heap (del_min t) 2. \<And>x r. \<lbrakk>heap t; braun t; t = \<langle>\<langle>\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> heap (del_min t) 3. \<And>v va vb x r. \<lbrakk>heap t; braun t; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> heap (del_min t)
<ISA_PRF> lemma heap_del_min: "heap t \<Longrightarrow> braun t \<Longrightarrow> heap(del_min t)" \n apply(cases t rule: del_min.cases) \n apply simp <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>x r. \<lbrakk>heap t; braun t; t = \<langle>\<langle>\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> heap (del_min t) 2. \<And>v va vb x r. \<lbrakk>heap t; braun t; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> heap (del_min t)
<ISA_PRF> lemma heap_del_min: "heap t \<Longrightarrow> braun t \<Longrightarrow> heap(del_min t)" \n apply(cases t rule: del_min.cases) \n apply simp \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r. \<lbrakk>heap t; braun t; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> heap (del_min t)
<ISA_PRF> lemma heap_del_min: "heap t \<Longrightarrow> braun t \<Longrightarrow> heap(del_min t)" \n apply(cases t rule: del_min.cases) \n apply simp \n apply simp \n apply (fastforce split: prod.split intro!: heap_sift_down dest: del_left_size del_left_braun del_left_heap) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma braun_sift_down: "braun(Node l a r) \<Longrightarrow> braun(sift_down l a r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, a, r\<rangle> \<Longrightarrow> braun (sift_down l a r)
<ISA_PRF> lemma heap_sift_down: "braun(Node l a r) \<Longrightarrow> heap l \<Longrightarrow> heap r \<Longrightarrow> heap(sift_down l a r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>braun \<langle>l, a, r\<rangle>; heap l; heap r\<rbrakk> \<Longrightarrow> heap (sift_down l a r)
<ISA_PRF> lemma del_left_braun: "del_left t = (x,t') \<Longrightarrow> braun t \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> braun t'" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); braun t; t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> braun t'
<ISA_PRF> lemma del_left_braun: "del_left t = (x,t') \<Longrightarrow> braun t \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> braun t'" \n by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size) <ISA_OBS> proof (prove) goal (11 subgoals): 1. \<And>P x. \<lbrakk>\<And>a uu_. x = (\<langle>\<rangle>, a, uu_) \<Longrightarrow> P; \<And>xa uv_ a. x = (\<langle>\<langle>\<rangle>, xa, uv_\<rangle>, a, \<langle>\<rangle>) \<Longrightarrow> P; \<And>l1 x1 r1 a l2 x2 r2. x = (\<langle>l1, x1, r1\<rangle>, a, \<langle>l2, x2, r2\<rangle>) \<Longrightarrow> P; \<And>vc vd ve va vb b. x = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P 2. \<And>a uu_ aa uua_. (\<langle>\<rangle>, a, uu_) = (\<langle>\<rangle>, aa, uua_) \<Longrightarrow> \<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle> = \<langle>\<langle>\<rangle>, aa, \<langle>\<rangle>\<rangle> 3. \<And>a uu_ x uv_ aa. (\<langle>\<rangle>, a, uu_) = (\<langle>\<langle>\<rangle>, x, uv_\<rangle>, aa, \<langle>\<rangle>) \<Longrightarrow> \<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle> = (if aa \<le> x then \<langle>\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, aa, \<langle>\<rangle>\<rangle> else \<langle>\<langle>\<langle>\<rangle>, aa, \<langle>\<rangle>\<rangle>, x, \<langle>\<rangle>\<rangle>) 4. \<And>a uu_ l1 x1 r1 aa l2 x2 r2. (\<langle>\<rangle>, a, uu_) = (\<langle>l1, x1, r1\<rangle>, aa, \<langle>l2, x2, r2\<rangle>) \<Longrightarrow> \<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle> = (let t2 = \<langle>l2, x2, r2\<rangle>; t1 = \<langle>l1, x1, r1\<rangle> in if aa \<le> x1 \<and> aa \<le> x2 then \<langle>t1, aa, t2\<rangle> else if x1 \<le> x2 then \<langle>sift_down_sumC (l1, aa, r1), x1, t2\<rangle> else \<langle>t1, x2, sift_down_sumC (l2, aa, r2)\<rangle>) 5. \<And>a uu_ vc vd ve va vb b. (\<langle>\<rangle>, a, uu_) = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> \<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle> = undefined 6. \<And>x uv_ a xa uva_ aa. (\<langle>\<langle>\<rangle>, x, uv_\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<langle>\<rangle>, xa, uva_\<rangle>, aa, \<langle>\<rangle>) \<Longrightarrow> (if a \<le> x then \<langle>\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>\<rangle> else \<langle>\<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle>, x, \<langle>\<rangle>\<rangle>) = (if aa \<le> xa then \<langle>\<langle>\<langle>\<rangle>, xa, \<langle>\<rangle>\<rangle>, aa, \<langle>\<rangle>\<rangle> else \<langle>\<langle>\<langle>\<rangle>, aa, \<langle>\<rangle>\<rangle>, xa, \<langle>\<rangle>\<rangle>) 7. \<And>x uv_ a l1 x1 r1 aa l2 x2 r2. (\<langle>\<langle>\<rangle>, x, uv_\<rangle>, a, \<langle>\<rangle>) = (\<langle>l1, x1, r1\<rangle>, aa, \<langle>l2, x2, r2\<rangle>) \<Longrightarrow> (if a \<le> x then \<langle>\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>\<rangle> else \<langle>\<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle>, x, \<langle>\<rangle>\<rangle>) = (let t2 = \<langle>l2, x2, r2\<rangle>; t1 = \<langle>l1, x1, r1\<rangle> in if aa \<le> x1 \<and> aa \<le> x2 then \<langle>t1, aa, t2\<rangle> else if x1 \<le> x2 then \<langle>sift_down_sumC (l1, aa, r1), x1, t2\<rangle> else \<langle>t1, x2, sift_down_sumC (l2, aa, r2)\<rangle>) 8. \<And>x uv_ a vc vd ve va vb b. (\<langle>\<langle>\<rangle>, x, uv_\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> (if a \<le> x then \<langle>\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>\<rangle> else \<langle>\<langle>\<langle>\<rangle>, a, \<langle>\<rangle>\<rangle>, x, \<langle>\<rangle>\<rangle>) = undefined 9. \<And>l1 x1 r1 a l2 x2 r2 l1a x1a r1a aa l2a x2a r2a. (\<langle>l1, x1, r1\<rangle>, a, \<langle>l2, x2, r2\<rangle>) = (\<langle>l1a, x1a, r1a\<rangle>, aa, \<langle>l2a, x2a, r2a\<rangle>) \<Longrightarrow> (let t2 = \<langle>l2, x2, r2\<rangle>; t1 = \<langle>l1, x1, r1\<rangle> in if a \<le> x1 \<and> a \<le> x2 then \<langle>t1, a, t2\<rangle> else if x1 \<le> x2 then \<langle>sift_down_sumC (l1, a, r1), x1, t2\<rangle> else \<langle>t1, x2, sift_down_sumC (l2, a, r2)\<rangle>) = (let t2 = \<langle>l2a, x2a, r2a\<rangle>; t1 = \<langle>l1a, x1a, r1a\<rangle> in if aa \<le> x1a \<and> aa \<le> x2a then \<langle>t1, aa, t2\<rangle> else if x1a \<le> x2a then \<langle>sift_down_sumC (l1a, aa, r1a), x1a, t2\<rangle> else \<langle>t1, x2a, sift_down_sumC (l2a, aa, r2a)\<rangle>) 10. \<And>l1 x1 r1 a l2 x2 r2 vc vd ve va vb b. (\<langle>l1, x1, r1\<rangle>, a, \<langle>l2, x2, r2\<rangle>) = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> (let t2 = \<langle>l2, x2, r2\<rangle>; t1 = \<langle>l1, x1, r1\<rangle> in if a \<le> x1 \<and> a \<le> x2 then \<langle>t1, a, t2\<rangle> else if x1 \<le> x2 then \<langle>sift_down_sumC (l1, a, r1), x1, t2\<rangle> else \<langle>t1, x2, sift_down_sumC (l2, a, r2)\<rangle>) = undefined A total of 11 subgoals...
<ISA_PRF> lemma del_left_braun: "del_left t = (x,t') \<Longrightarrow> braun t \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> braun t'" \n by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size) \n by pat_completeness auto <ISA_OBS> proof (prove) goal (1 subgoal): 1. All sift_down_dom
<ISA_PRF> lemma braun_del_min: "braun t \<Longrightarrow> braun(del_min t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> braun (del_min t)
<ISA_PRF> lemma braun_del_min: "braun t \<Longrightarrow> braun(del_min t)" \n apply(cases t rule: del_min.cases) <ISA_OBS> proof (prove) goal (3 subgoals): 1. \<lbrakk>braun t; t = \<langle>\<rangle>\<rbrakk> \<Longrightarrow> braun (del_min t) 2. \<And>x r. \<lbrakk>braun t; t = \<langle>\<langle>\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> braun (del_min t) 3. \<And>v va vb x r. \<lbrakk>braun t; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> braun (del_min t)
<ISA_PRF> lemma braun_del_min: "braun t \<Longrightarrow> braun(del_min t)" \n apply(cases t rule: del_min.cases) \n apply simp <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>x r. \<lbrakk>braun t; t = \<langle>\<langle>\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> braun (del_min t) 2. \<And>v va vb x r. \<lbrakk>braun t; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> braun (del_min t)
<ISA_PRF> lemma braun_del_min: "braun t \<Longrightarrow> braun(del_min t)" \n apply(cases t rule: del_min.cases) \n apply simp \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r. \<lbrakk>braun t; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> braun (del_min t)
<ISA_PRF> lemma braun_del_min: "braun t \<Longrightarrow> braun(del_min t)" \n apply(cases t rule: del_min.cases) \n apply simp \n apply simp \n apply (fastforce split: prod.split intro!: braun_sift_down dest: del_left_size del_left_braun) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma set_sift_down: "braun(Node l a r) \<Longrightarrow> set_tree(sift_down l a r) = {a} \<union> (set_tree l \<union> set_tree r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, a, r\<rangle> \<Longrightarrow> set_tree (sift_down l a r) = {a} \<union> (set_tree l \<union> set_tree r)
<ISA_PRF> lemma mset_sift_down: "braun(Node l a r) \<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, a, r\<rangle> \<Longrightarrow> mset_tree (sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)
<ISA_PRF> lemma del_left_mset_plus: "del_left t = (x,t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> mset_tree t = {#x#} + mset_tree t'" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (x, t'); t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> mset_tree t = {#x#} + mset_tree t'
<ISA_PRF> lemma braun_insert: "braun t \<Longrightarrow> braun(insert x t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> braun (insert x t)
<ISA_PRF> lemma size_sift_down: "braun(Node l a r) \<Longrightarrow> size(sift_down l a r) = size l + size r + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, a, r\<rangle> \<Longrightarrow> size (sift_down l a r) = size l + size r + 1
<ISA_PRF> lemma size_prod_measure[measure_function]: "is_measure f \<Longrightarrow> is_measure g \<Longrightarrow> is_measure (size_prod f g)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>is_measure f; is_measure g\<rbrakk> \<Longrightarrow> is_measure (size_prod f g)
<ISA_PRF> lemma merge_height: "height (merge l r) \<le> Suc (max (height l) (height r))" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height (merge l r) \<le> Suc (max (height l) (height r))
<ISA_PRF> lemma merge_height: "height (merge l r) \<le> Suc (max (height l) (height r))" \n by (induct rule: merge.induct, auto) <ISA_OBS> proof (prove) goal (1 subgoal): 1. height (merge l r) \<le> height \<langle>l, x, r\<rangle>
<ISA_PRF> lemma merge_height: "height (merge l r) \<le> Suc (max (height l) (height r))" \n by (induct rule: merge.induct, auto) \n using merge_height <ISA_OBS> proof (prove) using this: height (merge ?l ?r) \<le> Suc (max (height ?l) (height ?r)) goal (1 subgoal): 1. height (merge l r) \<le> height \<langle>l, x, r\<rangle>
<ISA_PRF> lemma height_insert_ge: "height t \<le> height (insert x t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height t \<le> height (insert x t)
<ISA_PRF> lemma height_insert_ge: "height t \<le> height (insert x t)" \n apply (induct t arbitrary: x; simp add: le_max_iff_disj) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>t1 x2 t2 x. \<lbrakk>\<And>x. height t1 \<le> height (insert x t1); \<And>x. height t2 \<le> height (insert x t2)\<rbrakk> \<Longrightarrow> (x < x2 \<longrightarrow> height t1 \<le> height (insert x2 t2) \<or> height t2 \<le> height t1) \<and> (\<not> x < x2 \<longrightarrow> height t1 \<le> height (insert x t2) \<or> height t2 \<le> height t1)
<ISA_PRF> lemma height_insert_ge: "height t \<le> height (insert x t)" \n apply (induct t arbitrary: x; simp add: le_max_iff_disj) \n apply (metis less_imp_le_nat less_le_trans not_le_imp_less) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_heap_of_A_log_bound: "t_heap_of_A xs \<le> length xs * (nlog2 (length xs + 1) + 1)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> lemma t_heap_of_A_log_bound: "t_heap_of_A xs \<le> length xs * (nlog2 (length xs + 1) + 1)" \n using t_heap_of_A_bound[of xs] acomplete_if_braun[OF braun_heap_of_A, of xs] <ISA_OBS> proof (prove) using this: t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) acomplete (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> lemma sorted_list_of_B: "braun t \<Longrightarrow> heap t \<Longrightarrow> sorted (list_of_B t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>braun t; heap t\<rbrakk> \<Longrightarrow> sorted (list_of_B t)
<ISA_PRF> lemma sorted_list_of_B: "braun t \<Longrightarrow> heap t \<Longrightarrow> sorted (list_of_B t)" \n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> heap y \<longrightarrow> sorted (list_of_B y); braun x; heap x\<rbrakk> \<Longrightarrow> sorted (list_of_B x)
<ISA_PRF> lemma sorted_list_of_B: "braun t \<Longrightarrow> heap t \<Longrightarrow> sorted (list_of_B t)" \n apply (induct t rule: measure_induct[where f=size]) \n apply (case_tac x; simp add: list_of_B_braun_simps) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x x21 x22 x23. \<lbrakk>\<forall>y. size y < Suc (size x21 + size x23) \<longrightarrow> braun y \<longrightarrow> heap y \<longrightarrow> sorted (list_of_B y); (size x21 = size x23 \<or> size x21 = Suc (size x23)) \<and> braun x21 \<and> braun x23; (\<forall>x\<in>set_tree x21 \<union> set_tree x23. x22 \<le> x) \<and> heap x21 \<and> heap x23; x = \<langle>x21, x22, x23\<rangle>\<rbrakk> \<Longrightarrow> (\<forall>x\<in>set (list_of_B (del_min \<langle>x21, x22, x23\<rangle>)). x22 \<le> x) \<and> sorted (list_of_B (del_min \<langle>x21, x22, x23\<rangle>))
<ISA_PRF> lemma sorted_list_of_B: "braun t \<Longrightarrow> heap t \<Longrightarrow> sorted (list_of_B t)" \n apply (induct t rule: measure_induct[where f=size]) \n apply (case_tac x; simp add: list_of_B_braun_simps) \n apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x21 x22 x23 xa. \<lbrakk>\<forall>y. size y < Suc (size x21 + size x23) \<longrightarrow> braun y \<longrightarrow> heap y \<longrightarrow> sorted (list_of_B y); xa \<in> set_tree (del_min \<langle>x21, x22, x23\<rangle>); size x21 = size x23 \<or> size x21 = Suc (size x23); \<forall>x\<in>set_tree x21 \<union> set_tree x23. x22 \<le> x; braun x21; braun x23; heap x21; heap x23\<rbrakk> \<Longrightarrow> x22 \<le> xa
<ISA_PRF> lemma sorted_list_of_B: "braun t \<Longrightarrow> heap t \<Longrightarrow> sorted (list_of_B t)" \n apply (induct t rule: measure_induct[where f=size]) \n apply (case_tac x; simp add: list_of_B_braun_simps) \n apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min) \n apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma del_left_height: "del_left t = (v, t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> height t' \<le> height t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>del_left t = (v, t'); t \<noteq> \<langle>\<rangle>\<rbrakk> \<Longrightarrow> height t' \<le> height t
<ISA_PRF> lemma del_left_height: "del_left t = (v, t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> height t' \<le> height t" \n apply (induct t arbitrary: v t' rule: del_left.induct; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r vc t'. \<lbrakk>\<And>vaa t'. del_left \<langle>v, va, vb\<rangle> = (vaa, t') \<Longrightarrow> height t' \<le> Suc (max (height v) (height vb)); (case del_left \<langle>v, va, vb\<rangle> of (y, l') \<Rightarrow> (y, \<langle>r, x, l'\<rangle>)) = (vc, t')\<rbrakk> \<Longrightarrow> height t' \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_left_height: "del_left t = (v, t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> height t' \<le> height t" \n apply (induct t arbitrary: v t' rule: del_left.induct; simp) \n apply (atomize(full), clarsimp split: prod.splits) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb r x1 x2. \<lbrakk>height x2 \<le> Suc (max (height v) (height vb)); del_left \<langle>v, va, vb\<rangle> = (x1, x2)\<rbrakk> \<Longrightarrow> height x2 \<le> max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma del_left_height: "del_left t = (v, t') \<Longrightarrow> t \<noteq> Leaf \<Longrightarrow> height t' \<le> height t" \n apply (induct t arbitrary: v t' rule: del_left.induct; simp) \n apply (atomize(full), clarsimp split: prod.splits) \n apply simp <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma heapify_snd_tup: "heapify n xs = (t, ys) \<Longrightarrow> n \<le> length xs \<Longrightarrow> ys = drop n xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heapify n xs = (t, ys); n \<le> length xs\<rbrakk> \<Longrightarrow> ys = drop n xs
<ISA_PRF> lemma mset_tree_merge[simp]: "mset_tree (merge l r) = mset_tree l + mset_tree r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (merge l r) = mset_tree l + mset_tree r
<ISA_PRF> lemma braun_height_r_le: "braun (Node l x r) \<Longrightarrow> height r \<le> height l" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, x, r\<rangle> \<Longrightarrow> height r \<le> height l
<ISA_PRF> lemma braun_heapify: "n \<le> length xs \<Longrightarrow> braun (fst (heapify n xs))" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \<le> length xs \<Longrightarrow> braun (fst (heapify n xs))
<ISA_PRF> lemma sorted_list_of_A: "heap t \<Longrightarrow> sorted (list_of_A t)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap t \<Longrightarrow> sorted (list_of_A t)
<ISA_PRF> lemma braun_height_node_eq: assumes b: "braun (Node l x r)" shows "height (Node l x r) = Suc (height l)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height \<langle>l, x, r\<rangle> = Suc (height l)
<ISA_PRF> lemma braun_height_node_eq: assumes b: "braun (Node l x r)" shows "height (Node l x r) = Suc (height l)" \n using b braun_height_r_le[OF b] <ISA_OBS> proof (prove) using this: braun \<langle>l, x, r\<rangle> height r \<le> height l goal (1 subgoal): 1. height \<langle>l, x, r\<rangle> = Suc (height l)
<ISA_PRF> lemma mset_tree_heap_of_A: "mset_tree (heap_of_A xs) = mset xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset_tree (heap_of_A xs) = mset xs
<ISA_PRF> lemma sortedA: "sorted (list_of_A (heap_of_A xs))" <ISA_OBS> proof (prove) goal (1 subgoal): 1. sorted (list_of_A (heap_of_A xs))
<ISA_PRF> lemma t_list_of_A_log_bound: "braun t \<Longrightarrow> t_list_of_A t \<le> 2 * nlog2 (size t + 1) * size t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> t_list_of_A t \<le> 2 * nat \<lceil>log 2 (real (size t + 1))\<rceil> * size t
<ISA_PRF> lemma t_list_of_A_log_bound: "braun t \<Longrightarrow> t_list_of_A t \<le> 2 * nlog2 (size t + 1) * size t" \n using t_list_of_A_bound[of t] <ISA_OBS> proof (prove) using this: t_list_of_A t \<le> 2 * height t * size t goal (1 subgoal): 1. braun t \<Longrightarrow> t_list_of_A t \<le> 2 * nat \<lceil>log 2 (real (size t + 1))\<rceil> * size t
<ISA_PRF> lemma mset_list_of_B: "braun t \<Longrightarrow> mset (list_of_B t) = mset_tree t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> mset (list_of_B t) = mset_tree t
<ISA_PRF> lemma mset_list_of_B: "braun t \<Longrightarrow> mset (list_of_B t) = mset_tree t" \n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> mset (list_of_B y) = mset_tree y; braun x\<rbrakk> \<Longrightarrow> mset (list_of_B x) = mset_tree x
<ISA_PRF> lemma mset_list_of_B: "braun t \<Longrightarrow> mset (list_of_B t) = mset_tree t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (case_tac x; simp add: list_of_B_braun_simps) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x x21 x22 x23. \<lbrakk>\<forall>y. size y < Suc (size x21 + size x23) \<longrightarrow> braun y \<longrightarrow> mset (list_of_B y) = mset_tree y; (size x21 = size x23 \<or> size x21 = Suc (size x23)) \<and> braun x21 \<and> braun x23; x = \<langle>x21, x22, x23\<rangle>\<rbrakk> \<Longrightarrow> mset (list_of_B (del_min \<langle>x21, x22, x23\<rangle>)) = mset_tree x21 + mset_tree x23
<ISA_PRF> lemma mset_list_of_B: "braun t \<Longrightarrow> mset (list_of_B t) = mset_tree t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (case_tac x; simp add: list_of_B_braun_simps) \n apply (simp add: size_del_min braun_del_min mset_del_min) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_del_left_bound: "t \<noteq> Leaf \<Longrightarrow> t_del_left t \<le> 2 * height t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t \<noteq> \<langle>\<rangle> \<Longrightarrow> t_del_left t \<le> 2 * height t
<ISA_PRF> lemma t_del_left_bound: "t \<noteq> Leaf \<Longrightarrow> t_del_left t \<le> 2 * height t" \n apply (induct rule: t_del_left.induct; clarsimp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb r. (\<And>a b xb y. \<lbrakk>(a, b) = del_left \<langle>v, va, vb\<rangle>; (xb, y) = del_left \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> \<le> Suc (Suc (2 * max (height v) (height vb)))) \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> \<le> 2 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_left_bound: "t \<noteq> Leaf \<Longrightarrow> t_del_left t \<le> 2 * height t" \n apply (induct rule: t_del_left.induct; clarsimp) \n apply (atomize(full); clarsimp simp: prod_eq_iff) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb r. t_del_left \<langle>v, va, vb\<rangle> \<le> Suc (Suc (2 * max (height v) (height vb))) \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> \<le> 2 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_left_bound: "t \<noteq> Leaf \<Longrightarrow> t_del_left t \<le> 2 * height t" \n apply (induct rule: t_del_left.induct; clarsimp) \n apply (atomize(full); clarsimp simp: prod_eq_iff) \n apply (simp add: nat_mult_max_right le_max_iff_disj) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>n \<le> length xs; heapify n xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) <ISA_OBS> proof (state) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) <ISA_OBS> proof (state) this: \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (?t, ?ys)\<rbrakk> \<Longrightarrow> size ?t = Suc n div 2 \<and> heap ?t \<and> braun ?t \<and> mset_tree ?t = mset (take (Suc n div 2) xs) \<lbrakk>?xa = heapify (Suc n div 2) xs; (?xb, ?y) = ?xa; n div 2 \<le> length ?y; heapify (n div 2) ?y = (?t, ?ys)\<rbrakk> \<Longrightarrow> size ?t = n div 2 \<and> heap ?t \<and> braun ?t \<and> mset_tree ?t = mset (take (n div 2) ?y) Suc n \<le> length (x # xs) heapify (Suc n) (x # xs) = (t, ys) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) <ISA_OBS> proof (state) this: Suc n \<le> length (x # xs) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\<And>t1 ys1. heapify (Suc n div 2) xs = (t1, ys1) \<Longrightarrow> thesis) \<Longrightarrow> thesis
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (Suc n div 2) xs = (t1, ys1) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\<And>t2 ys2. heapify (n div 2) ys1 = (t2, ys2) \<Longrightarrow> thesis) \<Longrightarrow> thesis
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (n div 2) ys1 = (t2, ys2) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len <ISA_OBS> proof (chain) picking this: Suc n \<le> length (x # xs)
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" <ISA_OBS> proof (prove) using this: Suc n \<le> length (x # xs) goal (1 subgoal): 1. Suc n div 2 \<le> length xs
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp <ISA_OBS> proof (state) this: Suc n div 2 \<le> length xs goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] <ISA_OBS> proof (state) this: ys1 = drop (Suc n div 2) xs goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len <ISA_OBS> proof (chain) picking this: Suc n \<le> length (x # xs)
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" <ISA_OBS> proof (prove) using this: Suc n \<le> length (x # xs) goal (1 subgoal): 1. n div 2 \<le> length ys1
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) <ISA_OBS> proof (state) this: n div 2 \<le> length ys1 goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] <ISA_OBS> proof (state) this: size t1 = Suc n div 2 \<and> heap t1 \<and> braun t1 \<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \<and> heap t2 \<and> braun t2 \<and> mset_tree t2 = mset (take (n div 2) ys1) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" <ISA_OBS> proof (prove) using this: size t1 = Suc n div 2 \<and> heap t1 \<and> braun t1 \<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \<and> heap t2 \<and> braun t2 \<and> mset_tree t2 = mset (take (n div 2) ys1) goal (1 subgoal): 1. braun \<langle>t1, x, t2\<rangle>
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) <ISA_OBS> proof (state) this: braun \<langle>t1, x, t2\<rangle> goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n div 2 + Suc n div 2 = n
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp <ISA_OBS> proof (state) this: n div 2 + Suc n div 2 = n goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take (Suc n div 2) (take n xs)) + mset (drop (Suc n div 2) (take n xs))
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done <ISA_OBS> proof (state) this: mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs) goal (3 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>n x xs t ys. \<lbrakk>\<And>t ys. \<lbrakk>Suc n div 2 \<le> length xs; heapify (Suc n div 2) xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n div 2) xs); \<And>xa xb y t ys. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; n div 2 \<le> length y; heapify (n div 2) y = (t, ys)\<rbrakk> \<Longrightarrow> size t = n div 2 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (n div 2) y); Suc n \<le> length (x # xs); heapify (Suc n) (x # xs) = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) 3. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done \n from "2.prems" app_hyps msets <ISA_OBS> proof (chain) picking this: Suc n \<le> length (x # xs) heapify (Suc n) (x # xs) = (t, ys) size t1 = Suc n div 2 \<and> heap t1 \<and> braun t1 \<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \<and> heap t2 \<and> braun t2 \<and> mset_tree t2 = mset (take (n div 2) ys1) mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done \n from "2.prems" app_hyps msets \n show ?case <ISA_OBS> proof (prove) using this: Suc n \<le> length (x # xs) heapify (Suc n) (x # xs) = (t, ys) size t1 = Suc n div 2 \<and> heap t1 \<and> braun t1 \<and> mset_tree t1 = mset (take (Suc n div 2) xs) size t2 = n div 2 \<and> heap t2 \<and> braun t2 \<and> mset_tree t2 = mset (take (n div 2) ys1) mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs) goal (1 subgoal): 1. size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs))
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done \n from "2.prems" app_hyps msets \n show ?case \n apply (clarsimp simp: h1 h2 le2) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>n \<le> length xs; mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs); ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2; size t2 = n div 2; heap t1; heap t2; braun t1; mset_tree t1 = mset (take (Suc n div 2) xs); braun t2; mset_tree t2 = mset (take (n div 2) ys1)\<rbrakk> \<Longrightarrow> size (sift_down t1 x t2) = Suc n \<and> heap (sift_down t1 x t2) \<and> braun (sift_down t1 x t2) \<and> mset_tree (sift_down t1 x t2) = add_mset x (mset (take n xs))
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done \n from "2.prems" app_hyps msets \n show ?case \n apply (clarsimp simp: h1 h2 le2) \n apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>n \<le> length xs; mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs); ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2; size t2 = n div 2; heap t1; heap t2; braun t1; mset_tree t1 = mset (take (Suc n div 2) xs); braun t2; mset_tree t2 = mset (take (n div 2) ys1)\<rbrakk> \<Longrightarrow> Suc n div 2 + n div 2 = n \<and> heap (sift_down t1 x t2)
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done \n from "2.prems" app_hyps msets \n show ?case \n apply (clarsimp simp: h1 h2 le2) \n apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun]) \n apply (simp add: heap_sift_down[OF braun]) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma heapify_correct: "n \<le> length xs \<Longrightarrow> heapify n xs = (t, ys) \<Longrightarrow> size t = n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take n xs)" \n proof (induct n xs arbitrary: t ys rule: heapify.induct) \n case (2 n x xs) \n note len = "2.prems"(1) \n obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)" \n by (simp add: prod_eq_iff) \n obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)" \n by (simp add: prod_eq_iff) \n from len \n have le1: "Suc n div 2 \<le> length xs" \n by simp \n note ys1 = heapify_snd_tup[OF h1 le1] \n from len \n have le2: "n div 2 \<le> length ys1" \n by (simp add: ys1) \n note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2] \n hence braun: "braun (Node t1 x t2)" \n by (simp, linarith) \n have eq: "n div 2 + Suc n div 2 = n" \n by simp \n have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)" \n apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append) \n apply (simp add: take_drop min_absorb1 le1 eq ys1) \n done \n from "2.prems" app_hyps msets \n show ?case \n apply (clarsimp simp: h1 h2 le2) \n apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun]) \n apply (simp add: heap_sift_down[OF braun]) \n done <ISA_OBS> proof (state) this: size t = Suc n \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc n) (x # xs)) goal (2 subgoals): 1. \<And>xs t ys. \<lbrakk>0 \<le> length xs; heapify 0 xs = (t, ys)\<rbrakk> \<Longrightarrow> size t = 0 \<and> heap t \<and> braun t \<and> mset_tree t = mset (take 0 xs) 2. \<And>v t ys. \<lbrakk>Suc v \<le> length []; heapify (Suc v) [] = (t, ys)\<rbrakk> \<Longrightarrow> size t = Suc v \<and> heap t \<and> braun t \<and> mset_tree t = mset (take (Suc v) [])
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>braun t; height t \<le> n\<rbrakk> \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> height y \<le> n \<longrightarrow> t_list_of_B y \<le> 3 * (n + 1) * size y; braun x; height x \<le> n\<rbrakk> \<Longrightarrow> t_list_of_B x \<le> 3 * (n + 1) * size x
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>braun x; height x \<le> n; size (del_min x) < size x \<longrightarrow> braun (del_min x) \<longrightarrow> height (del_min x) \<le> n \<longrightarrow> t_list_of_B (del_min x) \<le> 3 * (n + 1) * size (del_min x)\<rbrakk> \<Longrightarrow> t_list_of_B x \<le> 3 * (n + 1) * size x
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>braun x; height x \<le> n; size (del_min x) < size x \<longrightarrow> braun (del_min x) \<longrightarrow> height (del_min x) \<le> n \<longrightarrow> t_list_of_B (del_min x) \<le> 3 * (n + 1) * size (del_min x); height (del_min x) \<le> height x\<rbrakk> \<Longrightarrow> t_list_of_B x \<le> 3 * (n + 1) * size x
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) \n apply (case_tac x; simp add: t_list_of_B_braun_simps) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x x21 x22 x23. \<lbrakk>(size x21 = size x23 \<or> size x21 = Suc (size x23)) \<and> braun x21 \<and> braun x23; Suc (max (height x21) (height x23)) \<le> n; size (del_min \<langle>x21, x22, x23\<rangle>) < Suc (size x21 + size x23) \<longrightarrow> braun (del_min \<langle>x21, x22, x23\<rangle>) \<longrightarrow> t_list_of_B (del_min \<langle>x21, x22, x23\<rangle>) \<le> (3 + 3 * n) * size (del_min \<langle>x21, x22, x23\<rangle>); height (del_min \<langle>x21, x22, x23\<rangle>) \<le> Suc (max (height x21) (height x23)); x = \<langle>x21, x22, x23\<rangle>\<rbrakk> \<Longrightarrow> t_del_min \<langle>x21, x22, x23\<rangle> + t_list_of_B (del_min \<langle>x21, x22, x23\<rangle>) \<le> Suc (Suc (3 * n + (3 + 3 * n) * (size x21 + size x23)))
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) \n apply (case_tac x; simp add: t_list_of_B_braun_simps) \n apply (rename_tac l x' r) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x l x' r. \<lbrakk>(size l = size r \<or> size l = Suc (size r)) \<and> braun l \<and> braun r; Suc (max (height l) (height r)) \<le> n; size (del_min \<langle>l, x', r\<rangle>) < Suc (size l + size r) \<longrightarrow> braun (del_min \<langle>l, x', r\<rangle>) \<longrightarrow> t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> (3 + 3 * n) * size (del_min \<langle>l, x', r\<rangle>); height (del_min \<langle>l, x', r\<rangle>) \<le> Suc (max (height l) (height r)); x = \<langle>l, x', r\<rangle>\<rbrakk> \<Longrightarrow> t_del_min \<langle>l, x', r\<rangle> + t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) \n apply (case_tac x; simp add: t_list_of_B_braun_simps) \n apply (rename_tac l x' r) \n apply (clarsimp simp: braun_del_min size_del_min) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l x' r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> (3 + 3 * n) * (size l + size r); height (del_min \<langle>l, x', r\<rangle>) \<le> Suc (max (height l) (height r)); size l = size r \<or> size l = Suc (size r); braun l; braun r\<rbrakk> \<Longrightarrow> t_del_min \<langle>l, x', r\<rangle> + t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) \n apply (case_tac x; simp add: t_list_of_B_braun_simps) \n apply (rename_tac l x' r) \n apply (clarsimp simp: braun_del_min size_del_min) \n apply (rule order_trans) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>l x' r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> (3 + 3 * n) * (size l + size r); height (del_min \<langle>l, x', r\<rangle>) \<le> Suc (max (height l) (height r)); size l = size r \<or> size l = Suc (size r); braun l; braun r\<rbrakk> \<Longrightarrow> t_del_min \<langle>l, x', r\<rangle> + t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> ?y21 l x' r 2. \<And>l x' r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> (3 + 3 * n) * (size l + size r); height (del_min \<langle>l, x', r\<rangle>) \<le> Suc (max (height l) (height r)); size l = size r \<or> size l = Suc (size r); braun l; braun r\<rbrakk> \<Longrightarrow> ?y21 l x' r \<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) \n apply (case_tac x; simp add: t_list_of_B_braun_simps) \n apply (rename_tac l x' r) \n apply (clarsimp simp: braun_del_min size_del_min) \n apply (rule order_trans) \n apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1] <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l x' r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_B (del_min \<langle>l, x', r\<rangle>) \<le> (3 + 3 * n) * (size l + size r); height (del_min \<langle>l, x', r\<rangle>) \<le> Suc (max (height l) (height r)); size l = size r \<or> size l = Suc (size r); braun l; braun r\<rbrakk> \<Longrightarrow> 3 * height \<langle>l, x', r\<rangle> + (3 + 3 * n) * (size l + size r) \<le> Suc (Suc (3 * n + (3 + 3 * n) * (size l + size r)))
<ISA_PRF> lemma t_list_of_B_induct: "braun t \<Longrightarrow> height t \<le> n \<Longrightarrow> t_list_of_B t \<le> 3 * (n + 1) * size t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (drule_tac x="del_min x" in spec) \n apply (frule del_min_height) \n apply (case_tac x; simp add: t_list_of_B_braun_simps) \n apply (rename_tac l x' r) \n apply (clarsimp simp: braun_del_min size_del_min) \n apply (rule order_trans) \n apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1] \n apply simp <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma msetA: "mset (list_of_A (heap_of_A xs)) = mset xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (list_of_A (heap_of_A xs)) = mset xs
<ISA_PRF> lemma t_merge_height: "t_merge l r \<le> max (height l) (height r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_merge l r \<le> max (height l) (height r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) <ISA_OBS> proof (prove) goal (2 subgoals): 1. height \<langle>\<rangle> \<le> n \<Longrightarrow> t_list_of_A \<langle>\<rangle> \<le> 2 * n * size \<langle>\<rangle> 2. \<And>l a r. \<lbrakk>height (merge l r) \<le> n \<Longrightarrow> t_list_of_A (merge l r) \<le> 2 * n * size (merge l r); height \<langle>l, a, r\<rangle> \<le> n\<rbrakk> \<Longrightarrow> t_list_of_A \<langle>l, a, r\<rangle> \<le> 2 * n * size \<langle>l, a, r\<rangle>
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l a r. \<lbrakk>height (merge l r) \<le> n \<Longrightarrow> t_list_of_A (merge l r) \<le> 2 * n * size (merge l r); height \<langle>l, a, r\<rangle> \<le> n\<rbrakk> \<Longrightarrow> t_list_of_A \<langle>l, a, r\<rangle> \<le> 2 * n * size \<langle>l, a, r\<rangle>
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l r. \<lbrakk>height (merge l r) \<le> n \<Longrightarrow> t_list_of_A (merge l r) \<le> 2 * n * size (merge l r); Suc (max (height l) (height r)) \<le> n\<rbrakk> \<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \<le> 2 * n + 2 * n * (size l + size r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp \n apply (drule meta_mp) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>l r. Suc (max (height l) (height r)) \<le> n \<Longrightarrow> height (merge l r) \<le> n 2. \<And>l r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_A (merge l r) \<le> 2 * n * size (merge l r)\<rbrakk> \<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \<le> 2 * n + 2 * n * (size l + size r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp \n apply (drule meta_mp) \n apply (rule order_trans, rule merge_height) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>l r. Suc (max (height l) (height r)) \<le> n \<Longrightarrow> Suc (max (height l) (height r)) \<le> n 2. \<And>l r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_A (merge l r) \<le> 2 * n * size (merge l r)\<rbrakk> \<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \<le> 2 * n + 2 * n * (size l + size r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp \n apply (drule meta_mp) \n apply (rule order_trans, rule merge_height) \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_A (merge l r) \<le> 2 * n * size (merge l r)\<rbrakk> \<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \<le> 2 * n + 2 * n * (size l + size r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp \n apply (drule meta_mp) \n apply (rule order_trans, rule merge_height) \n apply simp \n apply (simp add: merge_size) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_A (merge l r) \<le> 2 * n * (size l + size r)\<rbrakk> \<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \<le> 2 * n + 2 * n * (size l + size r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp \n apply (drule meta_mp) \n apply (rule order_trans, rule merge_height) \n apply simp \n apply (simp add: merge_size) \n apply (cut_tac l=l and r=r in t_merge_height) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>l r. \<lbrakk>Suc (max (height l) (height r)) \<le> n; t_list_of_A (merge l r) \<le> 2 * n * (size l + size r); t_merge l r \<le> max (height l) (height r)\<rbrakk> \<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r)) \<le> 2 * n + 2 * n * (size l + size r)
<ISA_PRF> lemma t_list_of_A_induct: "height t \<le> n \<Longrightarrow> t_list_of_A t \<le> 2 * n * size t" \n apply (induct rule: t_list_of_A.induct) \n apply simp \n apply simp \n apply (drule meta_mp) \n apply (rule order_trans, rule merge_height) \n apply simp \n apply (simp add: merge_size) \n apply (cut_tac l=l and r=r in t_merge_height) \n apply linarith <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) <ISA_OBS> proof (state) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) <ISA_OBS> proof (state) this: t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" <ISA_OBS> proof (state) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> t_insert x (heap_of_A xs) + t_heap_of_A xs
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp <ISA_OBS> proof (state) this: t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> t_insert x (heap_of_A xs) + t_heap_of_A xs goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also <ISA_OBS> proof (state) this: t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> t_insert x (heap_of_A xs) + t_heap_of_A xs goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons <ISA_OBS> proof (state) this: t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also <ISA_OBS> proof (state) this: t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] <ISA_OBS> proof (state) this: height (heap_of_A xs) \<le> height (insert x (heap_of_A xs)) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also <ISA_OBS> proof (state) this: height (heap_of_A xs) \<le> height (insert x (heap_of_A xs)) goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] <ISA_OBS> proof (state) this: t_insert x (heap_of_A xs) \<le> height (heap_of_A xs) + 1 goal (2 subgoals): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1) 2. \<And>a xs. t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1) \<Longrightarrow> t_heap_of_A (a # xs) \<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] \n finally <ISA_OBS> proof (chain) picking this: \<lbrakk>\<And>xa y. xa \<le> y \<Longrightarrow> t_insert x (heap_of_A xs) + xa \<le> t_insert x (heap_of_A xs) + y; \<And>xa y. xa \<le> y \<Longrightarrow> t_insert x (heap_of_A xs) + length xs * (xa + 1) \<le> t_insert x (heap_of_A xs) + length xs * (y + 1); \<And>xa y. xa \<le> y \<Longrightarrow> xa + length xs * (height (insert x (heap_of_A xs)) + 1) \<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\<rbrakk> \<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> height (heap_of_A xs) + 1 + length xs * (height (insert x (heap_of_A xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] \n finally \n show ?case <ISA_OBS> proof (prove) using this: \<lbrakk>\<And>xa y. xa \<le> y \<Longrightarrow> t_insert x (heap_of_A xs) + xa \<le> t_insert x (heap_of_A xs) + y; \<And>xa y. xa \<le> y \<Longrightarrow> t_insert x (heap_of_A xs) + length xs * (xa + 1) \<le> t_insert x (heap_of_A xs) + length xs * (y + 1); \<And>xa y. xa \<le> y \<Longrightarrow> xa + length xs * (height (insert x (heap_of_A xs)) + 1) \<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\<rbrakk> \<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> height (heap_of_A xs) + 1 + length xs * (height (insert x (heap_of_A xs)) + 1) goal (1 subgoal): 1. t_heap_of_A (x # xs) \<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1)
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] \n finally \n show ?case \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> Suc (height (heap_of_A xs) + (length xs + length xs * height (insert x (heap_of_A xs)))) \<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs \<le> Suc (length xs + (height (insert x (heap_of_A xs)) + length xs * height (insert x (heap_of_A xs))))
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] \n finally \n show ?case \n apply simp \n apply (erule order_trans) <ISA_OBS> proof (prove) goal (1 subgoal): 1. Suc (height (heap_of_A xs) + (length xs + length xs * height (insert x (heap_of_A xs)))) \<le> Suc (length xs + (height (insert x (heap_of_A xs)) + length xs * height (insert x (heap_of_A xs))))
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] \n finally \n show ?case \n apply simp \n apply (erule order_trans) \n apply (simp add: height_insert_ge) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_heap_of_A_bound: "t_heap_of_A xs \<le> length xs * (height (heap_of_A xs) + 1)" \n proof (induct xs) \n case (Cons x xs) \n let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs" \n have "?lhs \<le> ?lhs" \n by simp \n also \n note Cons \n also \n note height_insert_ge[of "heap_of_A xs" x] \n also \n note t_insert_height[of x "heap_of_A xs"] \n finally \n show ?case \n apply simp \n apply (erule order_trans) \n apply (simp add: height_insert_ge) \n done <ISA_OBS> proof (state) this: t_heap_of_A (x # xs) \<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1) goal (1 subgoal): 1. t_heap_of_A [] \<le> length [] * (height (heap_of_A []) + 1)
<ISA_PRF> lemma list_of_B_braun_ptermination: "braun t \<Longrightarrow> list_of_B_dom t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> list_of_B_dom t
<ISA_PRF> lemma list_of_B_braun_ptermination: "braun t \<Longrightarrow> list_of_B_dom t" \n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> list_of_B_dom y; braun x\<rbrakk> \<Longrightarrow> list_of_B_dom x
<ISA_PRF> lemma list_of_B_braun_ptermination: "braun t \<Longrightarrow> list_of_B_dom t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (rule accpI, erule list_of_B_rel.cases) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x y l a r. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> list_of_B_dom y; braun x; y = del_min \<langle>l, a, r\<rangle>; x = \<langle>l, a, r\<rangle>\<rbrakk> \<Longrightarrow> list_of_B_dom y
<ISA_PRF> lemma list_of_B_braun_ptermination: "braun t \<Longrightarrow> list_of_B_dom t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (rule accpI, erule list_of_B_rel.cases) \n apply (clarsimp simp: size_del_min braun_del_min) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma heap_heapify: "n \<le> length xs \<Longrightarrow> heap (fst (heapify n xs))" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \<le> length xs \<Longrightarrow> heap (fst (heapify n xs))
<ISA_PRF> lemma mset_list_of_A[simp]: "mset (list_of_A t) = mset_tree t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (list_of_A t) = mset_tree t
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> height (del_min t) \<le> height t
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r. \<lbrakk>(Suc (size v + size vb) = size r \<or> size v + size vb = size r) \<and> (size v = size vb \<or> size v = Suc (size vb)) \<and> braun v \<and> braun vb \<and> braun r; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> height (case del_left \<langle>v, va, vb\<rangle> of (x, xa) \<Rightarrow> sift_down r x xa) \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) \n apply (clarsimp split: prod.split) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size v + size vb) = size r \<or> size v + size vb = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2)\<rbrakk> \<Longrightarrow> height (sift_down r x1 x2) \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size v + size vb) = size r \<or> size v + size vb = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2\<rbrakk> \<Longrightarrow> height (sift_down r x1 x2) \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2\<rbrakk> \<Longrightarrow> height (sift_down r x1 x2) \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (drule del_left_height) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; braun x2; size v + size vb = size x2\<rbrakk> \<Longrightarrow> \<langle>v, va, vb\<rangle> \<noteq> \<langle>\<rangle> 2. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> height (sift_down r x1 x2) \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (drule del_left_height) \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> height (sift_down r x1 x2) \<le> Suc (max (Suc (max (height v) (height vb))) (height r))
<ISA_PRF> lemma del_min_height: "braun t \<Longrightarrow> height (del_min t) \<le> height t" \n apply (cases t rule: del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (drule del_left_height) \n apply simp \n apply (rule order_trans, rule sift_down_height, auto) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma braun_heap_of_A: "braun (heap_of_A xs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun (heap_of_A xs)
<ISA_PRF> lemma set_list_of_B: "braun t \<Longrightarrow> set (list_of_B t) = set_tree t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> set (list_of_B t) = set_tree t
<ISA_PRF> lemma braun_height_l_le: assumes b: "braun (Node l x r)" shows "height l \<le> Suc (height r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. height l \<le> Suc (height r)
<ISA_PRF> lemma braun_height_l_le: assumes b: "braun (Node l x r)" shows "height l \<le> Suc (height r)" \n using b acomplete_if_braun[OF b] min_height_le_height[of r] <ISA_OBS> proof (prove) using this: braun \<langle>l, x, r\<rangle> acomplete \<langle>l, x, r\<rangle> min_height r \<le> height r goal (1 subgoal): 1. height l \<le> Suc (height r)
<ISA_PRF> lemma size_heap_of_A: "size (heap_of_A xs) = length xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (heap_of_A xs) = length xs
<ISA_PRF> lemma size_heap_of_A: "size (heap_of_A xs) = length xs" \n using arg_cong[OF mset_tree_heap_of_A, of size xs] <ISA_OBS> proof (prove) using this: size (mset_tree (heap_of_A xs)) = size (mset xs) goal (1 subgoal): 1. size (heap_of_A xs) = length xs
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> t_del_min t \<le> 3 * height t
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r. \<lbrakk>(Suc (size v + size vb) = size r \<or> size v + size vb = size r) \<and> (size v = size vb \<or> size v = Suc (size vb)) \<and> braun v \<and> braun vb \<and> braun r; t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>\<rbrakk> \<Longrightarrow> (case del_left \<langle>v, va, vb\<rangle> of (y, l') \<Rightarrow> t_del_left \<langle>v, va, vb\<rangle> + t_sift_down r y l') \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size v + size vb) = size r \<or> size v + size vb = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2)\<rbrakk> \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> + t_sift_down r x1 x2 \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size v + size vb) = size r \<or> size v + size vb = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2\<rbrakk> \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> + t_sift_down r x1 x2 \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2\<rbrakk> \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> + t_sift_down r x1 x2 \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (frule del_left_height, simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> + t_sift_down r x1 x2 \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (frule del_left_height, simp) \n apply (rule order_trans) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> t_del_left \<langle>v, va, vb\<rangle> + t_sift_down r x1 x2 \<le> ?y30 v va vb x r x1 x2 2. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> ?y30 v va vb x r x1 x2 \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (frule del_left_height, simp) \n apply (rule order_trans) \n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \<le> Suc (max (height v) (height vb))\<rbrakk> \<Longrightarrow> size r = size x2 \<or> size r = Suc (size x2) 2. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> 2 * height \<langle>v, va, vb\<rangle> + height \<langle>r, x1, x2\<rangle> \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (frule del_left_height, simp) \n apply (rule order_trans) \n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] \n apply auto[1] <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>v va vb x r x1 x2. \<lbrakk>t = \<langle>\<langle>v, va, vb\<rangle>, x, r\<rangle>; Suc (size x2) = size r \<or> size x2 = size r; size v = size vb \<or> size v = Suc (size vb); braun v; braun vb; braun r; del_left \<langle>v, va, vb\<rangle> = (x1, x2); braun x2; size v + size vb = size x2; height x2 \<le> height \<langle>v, va, vb\<rangle>\<rbrakk> \<Longrightarrow> 2 * height \<langle>v, va, vb\<rangle> + height \<langle>r, x1, x2\<rangle> \<le> 3 + 3 * max (Suc (max (height v) (height vb))) (height r)
<ISA_PRF> lemma t_del_min_bound: "braun t \<Longrightarrow> t_del_min t \<le> 3 * height t" \n apply (cases t rule: t_del_min.cases; simp) \n apply (clarsimp split: prod.split) \n apply (frule del_left_braun, simp+) \n apply (frule del_left_size, simp+) \n apply (frule del_left_height, simp) \n apply (rule order_trans) \n apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1] \n apply auto[1] \n apply (simp add: max_def) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_list_of_B_braun_ptermination: "braun t \<Longrightarrow> t_list_of_B_dom t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> t_list_of_B_dom t
<ISA_PRF> lemma t_list_of_B_braun_ptermination: "braun t \<Longrightarrow> t_list_of_B_dom t" \n apply (induct t rule: measure_induct[where f=size]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> t_list_of_B_dom y; braun x\<rbrakk> \<Longrightarrow> t_list_of_B_dom x
<ISA_PRF> lemma t_list_of_B_braun_ptermination: "braun t \<Longrightarrow> t_list_of_B_dom t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (rule accpI, erule t_list_of_B_rel.cases) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x y l a r. \<lbrakk>\<forall>y. size y < size x \<longrightarrow> braun y \<longrightarrow> t_list_of_B_dom y; braun x; y = del_min \<langle>l, a, r\<rangle>; x = \<langle>l, a, r\<rangle>\<rbrakk> \<Longrightarrow> t_list_of_B_dom y
<ISA_PRF> lemma t_list_of_B_braun_ptermination: "braun t \<Longrightarrow> t_list_of_B_dom t" \n apply (induct t rule: measure_induct[where f=size]) \n apply (rule accpI, erule t_list_of_B_rel.cases) \n apply (clarsimp simp: size_del_min braun_del_min) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_list_of_A_bound: "t_list_of_A t \<le> 2 * height t * size t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_list_of_A t \<le> 2 * height t * size t
<ISA_PRF> lemma set_tree_merge[simp]: "set_tree (merge l r) = set_tree l \<union> set_tree r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set_tree (merge l r) = set_tree l \<union> set_tree r
<ISA_PRF> lemma msetB: "mset (list_of_B (heap_of_B xs)) = mset xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. mset (list_of_B (heap_of_B xs)) = mset xs
<ISA_PRF> lemma msetB: "mset (list_of_B (heap_of_B xs)) = mset xs" \n by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B) <ISA_OBS> proof (prove) goal (4 subgoals): 1. \<And>P x. \<lbrakk>x = \<langle>\<rangle> \<Longrightarrow> P; \<And>l a r. x = \<langle>l, a, r\<rangle> \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P 2. \<langle>\<rangle> = \<langle>\<rangle> \<Longrightarrow> 0 = 0 3. \<And>l a r. \<langle>\<rangle> = \<langle>l, a, r\<rangle> \<Longrightarrow> 0 = 1 + t_del_min \<langle>l, a, r\<rangle> + t_list_of_B_sumC (del_min \<langle>l, a, r\<rangle>) 4. \<And>l a r la aa ra. \<langle>l, a, r\<rangle> = \<langle>la, aa, ra\<rangle> \<Longrightarrow> 1 + t_del_min \<langle>l, a, r\<rangle> + t_list_of_B_sumC (del_min \<langle>l, a, r\<rangle>) = 1 + t_del_min \<langle>la, aa, ra\<rangle> + t_list_of_B_sumC (del_min \<langle>la, aa, ra\<rangle>)
<ISA_PRF> lemma mset_heapify: "n \<le> length xs \<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \<le> length xs \<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)
<ISA_PRF> lemma mset_heapify: "n \<le> length xs \<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)" \n by (cases "heapify n xs", drule(1) heapify_correct, simp) <ISA_OBS> proof (prove) goal (22 subgoals): 1. \<And>P x. \<lbrakk>\<And>a. x = (\<langle>\<rangle>, a, \<langle>\<rangle>) \<Longrightarrow> P; \<And>xa a. x = (\<langle>\<langle>\<rangle>, xa, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>) \<Longrightarrow> P; \<And>l1 x1 r1 a l2 x2 r2. x = (\<langle>l1, x1, r1\<rangle>, a, \<langle>l2, x2, r2\<rangle>) \<Longrightarrow> P; \<And>vc vd ve va vb b. x = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> P; \<And>v va vc vd ve b. x = (\<langle>v, va, \<langle>vc, vd, ve\<rangle>\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> P; \<And>b v va vb. x = (\<langle>\<rangle>, b, \<langle>v, va, vb\<rangle>) \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P 2. \<And>a aa. (\<langle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<rangle>, aa, \<langle>\<rangle>) \<Longrightarrow> 1 = 1 3. \<And>a x aa. (\<langle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, aa, \<langle>\<rangle>) \<Longrightarrow> 1 = 2 4. \<And>a l1 x1 r1 aa l2 x2 r2. (\<langle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>l1, x1, r1\<rangle>, aa, \<langle>l2, x2, r2\<rangle>) \<Longrightarrow> 1 = (let t2 = \<langle>l2, x2, r2\<rangle>; t1 = \<langle>l1, x1, r1\<rangle> in if aa \<le> x1 \<and> aa \<le> x2 then 1 else if x1 \<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1) else 1 + t_sift_down_sumC (l2, aa, r2)) 5. \<And>a vc vd ve va vb b. (\<langle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> 1 = undefined 6. \<And>a v va vc vd ve b. (\<langle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>v, va, \<langle>vc, vd, ve\<rangle>\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> 1 = undefined 7. \<And>a b v va vb. (\<langle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<rangle>, b, \<langle>v, va, vb\<rangle>) \<Longrightarrow> 1 = undefined 8. \<And>x a xa aa. (\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<langle>\<rangle>, xa, \<langle>\<rangle>\<rangle>, aa, \<langle>\<rangle>) \<Longrightarrow> 2 = 2 9. \<And>x a l1 x1 r1 aa l2 x2 r2. (\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>l1, x1, r1\<rangle>, aa, \<langle>l2, x2, r2\<rangle>) \<Longrightarrow> 2 = (let t2 = \<langle>l2, x2, r2\<rangle>; t1 = \<langle>l1, x1, r1\<rangle> in if aa \<le> x1 \<and> aa \<le> x2 then 1 else if x1 \<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1) else 1 + t_sift_down_sumC (l2, aa, r2)) 10. \<And>x a vc vd ve va vb b. (\<langle>\<langle>\<rangle>, x, \<langle>\<rangle>\<rangle>, a, \<langle>\<rangle>) = (\<langle>\<langle>vc, vd, ve\<rangle>, va, vb\<rangle>, b, \<langle>\<rangle>) \<Longrightarrow> 2 = undefined A total of 22 subgoals...
<ISA_PRF> lemma mset_heapify: "n \<le> length xs \<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)" \n by (cases "heapify n xs", drule(1) heapify_correct, simp) \n by pat_completeness auto <ISA_OBS> proof (prove) goal (1 subgoal): 1. All t_sift_down_dom
<ISA_PRF> lemma heapify_snd: "n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs
<ISA_PRF> lemma heapify_snd: "n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs" \n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x n. \<lbrakk>\<forall>y. length y < length x \<longrightarrow> (\<forall>x\<le>length y. snd (heapify x y) = drop x y); n \<le> length x\<rbrakk> \<Longrightarrow> snd (heapify n x) = drop n x
<ISA_PRF> lemma heapify_snd: "n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs" \n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \n apply (case_tac n; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>x n nat. \<lbrakk>\<forall>y. length y < length x \<longrightarrow> (\<forall>x\<le>length y. snd (heapify x y) = drop x y); Suc nat \<le> length x; n = Suc nat\<rbrakk> \<Longrightarrow> snd (heapify (Suc nat) x) = drop (Suc nat) x
<ISA_PRF> lemma heapify_snd: "n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs" \n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \n apply (case_tac n; simp) \n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>nat ys. \<lbrakk>\<forall>y. length y < Suc (length ys) \<longrightarrow> (\<forall>x\<le>length y. snd (heapify x y) = drop x y); nat \<le> length ys\<rbrakk> \<Longrightarrow> drop (nat div 2 + Suc nat div 2) ys = drop nat ys
<ISA_PRF> lemma heapify_snd: "n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs" \n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \n apply (case_tac n; simp) \n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) \n apply (rule arg_cong[where f="\<lambda>n. drop n xs" for xs]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>nat ys. \<lbrakk>\<forall>y. length y < Suc (length ys) \<longrightarrow> (\<forall>x\<le>length y. snd (heapify x y) = drop x y); nat \<le> length ys\<rbrakk> \<Longrightarrow> nat div 2 + Suc nat div 2 = nat
<ISA_PRF> lemma heapify_snd: "n \<le> length xs \<Longrightarrow> snd (heapify n xs) = drop n xs" \n apply (induct xs arbitrary: n rule: measure_induct[where f=length]) \n apply (case_tac n; simp) \n apply (clarsimp simp: Suc_le_length_iff case_prod_beta) \n apply (rule arg_cong[where f="\<lambda>n. drop n xs" for xs]) \n apply simp <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp <ISA_OBS> proof (state) this: t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also <ISA_OBS> proof (state) this: t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] <ISA_OBS> proof (state) this: t_heap_of_A xs \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] \n also <ISA_OBS> proof (state) this: t_heap_of_A xs \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] \n also \n note t_list_of_A_log_bound[of "heap_of_A xs", OF braun_heap_of_A] <ISA_OBS> proof (state) this: t_list_of_A (heap_of_A xs) \<le> 2 * nat \<lceil>log 2 (real (size (heap_of_A xs) + 1))\<rceil> * size (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] \n also \n note t_list_of_A_log_bound[of "heap_of_A xs", OF braun_heap_of_A] \n finally <ISA_OBS> proof (chain) picking this: \<lbrakk>\<And>x y. x \<le> y \<Longrightarrow> x + t_list_of_A (heap_of_A xs) \<le> y + t_list_of_A (heap_of_A xs); \<And>x y. x \<le> y \<Longrightarrow> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) + x \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) + y\<rbrakk> \<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) + 2 * nat \<lceil>log 2 (real (size (heap_of_A xs) + 1))\<rceil> * size (heap_of_A xs)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] \n also \n note t_list_of_A_log_bound[of "heap_of_A xs", OF braun_heap_of_A] \n finally \n show ?thesis <ISA_OBS> proof (prove) using this: \<lbrakk>\<And>x y. x \<le> y \<Longrightarrow> x + t_list_of_A (heap_of_A xs) \<le> y + t_list_of_A (heap_of_A xs); \<And>x y. x \<le> y \<Longrightarrow> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) + x \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) + y\<rbrakk> \<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) + 2 * nat \<lceil>log 2 (real (size (heap_of_A xs) + 1))\<rceil> * size (heap_of_A xs) goal (1 subgoal): 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1)
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] \n also \n note t_list_of_A_log_bound[of "heap_of_A xs", OF braun_heap_of_A] \n finally \n show ?thesis \n by (simp add: size_heap_of_A) <ISA_OBS> proof (state) this: t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 1) goal: No subgoals!
<ISA_PRF> theorem t_sortA: "t_heap_of_A xs + t_list_of_A (heap_of_A xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 1)" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_A_log_bound[of xs] \n also \n note t_list_of_A_log_bound[of "heap_of_A xs", OF braun_heap_of_A] \n finally \n show ?thesis \n by (simp add: size_heap_of_A) \n qed <ISA_OBS> proof (prove) goal (4 subgoals): 1. \<And>P x. \<lbrakk>x = \<langle>\<rangle> \<Longrightarrow> P; \<And>l a r. x = \<langle>l, a, r\<rangle> \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P 2. \<langle>\<rangle> = \<langle>\<rangle> \<Longrightarrow> [] = [] 3. \<And>l a r. \<langle>\<rangle> = \<langle>l, a, r\<rangle> \<Longrightarrow> [] = a # list_of_B_sumC (del_min \<langle>l, a, r\<rangle>) 4. \<And>l a r la aa ra. \<langle>l, a, r\<rangle> = \<langle>la, aa, ra\<rangle> \<Longrightarrow> a # list_of_B_sumC (del_min \<langle>l, a, r\<rangle>) = aa # list_of_B_sumC (del_min \<langle>la, aa, ra\<rangle>)
<ISA_PRF> lemma sift_down_height: "braun (Node l x r) \<Longrightarrow> height (sift_down l x r) \<le> height (Node l x r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, x, r\<rangle> \<Longrightarrow> height (sift_down l x r) \<le> height \<langle>l, x, r\<rangle>
<ISA_PRF> lemma t_list_of_B_bound: "braun t \<Longrightarrow> t_list_of_B t \<le> 3 * (height t + 1) * size t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun t \<Longrightarrow> t_list_of_B t \<le> 3 * (height t + 1) * size t
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) <ISA_OBS> proof (state) goal (3 subgoals): 1. \<And>xs. 0 \<le> length xs \<Longrightarrow> t_heapify 0 xs + height (fst (heapify 0 xs)) \<le> 5 * 0 + 1 2. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 3. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) <ISA_OBS> proof (state) this: 0 \<le> length vs goal (3 subgoals): 1. \<And>xs. 0 \<le> length xs \<Longrightarrow> t_heapify 0 xs + height (fst (heapify 0 xs)) \<le> 5 * 0 + 1 2. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 3. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case <ISA_OBS> proof (prove) using this: 0 \<le> length vs goal (1 subgoal): 1. t_heapify 0 vs + height (fst (heapify 0 vs)) \<le> 5 * 0 + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp <ISA_OBS> proof (state) this: t_heapify 0 vs + height (fst (heapify 0 vs)) \<le> 5 * 0 + 1 goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next <ISA_OBS> proof (state) goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) <ISA_OBS> proof (state) this: \<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa; Suc i div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) \<le> 5 * (Suc i div 2) + 1 \<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa; ?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ?y; (?xac, ?ya) = ?xab; i div 2 \<le> length ?y\<rbrakk> \<Longrightarrow> t_heapify (i div 2) ?y + height (fst (heapify (i div 2) ?y)) \<le> 5 * (i div 2) + 1 Suc i \<le> length (x # xs) goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\<And>l ys. heapify (Suc i div 2) xs = (l, ys) \<Longrightarrow> thesis) \<Longrightarrow> thesis
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (Suc i div 2) xs = (l, ys) goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] <ISA_OBS> proof (state) this: Suc i div 2 \<le> length xs \<Longrightarrow> t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) \<le> Suc (5 * (Suc i div 2)) \<lbrakk>?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ys; (?xac, ?ya) = ?xab; i div 2 \<le> length ys\<rbrakk> \<Longrightarrow> t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys)) \<le> Suc (5 * (i div 2)) goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. (\<And>r zs. heapify (i div 2) ys = (r, zs) \<Longrightarrow> thesis) \<Longrightarrow> thesis
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) <ISA_OBS> proof (state) this: heapify (i div 2) ys = (r, zs) goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] <ISA_OBS> proof (chain) picking this: Suc i \<le> length (x # xs) Suc i div 2 \<le> length xs \<Longrightarrow> ys = drop (Suc i div 2) xs
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" <ISA_OBS> proof (prove) using this: Suc i \<le> length (x # xs) Suc i div 2 \<le> length xs \<Longrightarrow> ys = drop (Suc i div 2) xs goal (1 subgoal): 1. Suc i div 2 \<le> length xs &&& i div 2 \<le> length xs &&& i div 2 \<le> length ys
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all <ISA_OBS> proof (state) this: Suc i div 2 \<le> length xs i div 2 \<le> length xs i div 2 \<le> length ys goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] <ISA_OBS> proof (state) this: t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) \<le> Suc (5 * (Suc i div 2)) t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys)) \<le> Suc (5 * (i div 2)) goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] <ISA_OBS> proof (state) this: t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) + (t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))) + 3 \<le> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3 goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] <ISA_OBS> proof (chain) picking this: size l = Suc i div 2 \<and> heap l \<and> braun l \<and> mset_tree l = mset (take (Suc i div 2) xs) size r = i div 2 \<and> heap r \<and> braun r \<and> mset_tree r = mset (take (i div 2) ys)
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" <ISA_OBS> proof (prove) using this: size l = Suc i div 2 \<and> heap l \<and> braun l \<and> mset_tree l = mset (take (Suc i div 2) xs) size r = i div 2 \<and> heap r \<and> braun r \<and> mset_tree r = mset (take (i div 2) ys) goal (1 subgoal): 1. braun \<langle>l, x, r\<rangle>
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto <ISA_OBS> proof (state) this: braun \<langle>l, x, r\<rangle> goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_sift_down l x r \<le> height l + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] <ISA_OBS> proof (prove) using this: t_sift_down l x r \<le> height \<langle>l, x, r\<rangle> height r \<le> height l goal (1 subgoal): 1. t_sift_down l x r \<le> height l + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp <ISA_OBS> proof (state) this: t_sift_down l x r \<le> height l + 1 goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] <ISA_OBS> proof (chain) picking this: t_sift_down l x r \<le> height \<langle>l, x, r\<rangle>
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" <ISA_OBS> proof (prove) using this: t_sift_down l x r \<le> height \<langle>l, x, r\<rangle> goal (1 subgoal): 1. height (sift_down l x r) \<le> height r + 2
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] <ISA_OBS> proof (prove) using this: t_sift_down l x r \<le> height \<langle>l, x, r\<rangle> height (sift_down l x r) \<le> height \<langle>l, x, r\<rangle> height l \<le> Suc (height r) goal (1 subgoal): 1. height (sift_down l x r) \<le> height r + 2
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp <ISA_OBS> proof (state) this: height (sift_down l x r) \<le> height r + 2 goal (2 subgoals): 1. \<And>n x xs. \<lbrakk>\<And>xa xb y. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; Suc n div 2 \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc n div 2) xs + height (fst (heapify (Suc n div 2) xs)) \<le> 5 * (Suc n div 2) + 1; \<And>xa xb y xaa xab xac ya. \<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa; xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y; (xac, ya) = xab; n div 2 \<le> length y\<rbrakk> \<Longrightarrow> t_heapify (n div 2) y + height (fst (heapify (n div 2) y)) \<le> 5 * (n div 2) + 1; Suc n \<le> length (x # xs)\<rbrakk> \<Longrightarrow> t_heapify (Suc n) (x # xs) + height (fst (heapify (Suc n) (x # xs))) \<le> 5 * Suc n + 1 2. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" <ISA_OBS> proof (chain) picking this: heapify (Suc i div 2) xs = (l, ys) heapify (i div 2) ys = (r, zs) t_sift_down l x r \<le> height l + 1 height (sift_down l x r) \<le> height r + 2 Suc i \<le> length (x # xs)
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case <ISA_OBS> proof (prove) using this: heapify (Suc i div 2) xs = (l, ys) heapify (i div 2) ys = (r, zs) t_sift_down l x r \<le> height l + 1 height (sift_down l x r) \<le> height r + 2 Suc i \<le> length (x # xs) goal (1 subgoal): 1. t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs))) \<le> 5 * Suc i + 1
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case \n apply simp <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \<le> Suc (height l); height (sift_down l x r) \<le> Suc (Suc (height r)); i \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc i div 2) xs + (t_heapify (i div 2) ys + (t_sift_down l x r + height (sift_down l x r))) \<le> 5 + 5 * i
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case \n apply simp \n apply (rule order_trans, rule order_trans[rotated], rule prem) <ISA_OBS> proof (prove) goal (2 subgoals): 1. \<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \<le> Suc (height l); height (sift_down l x r) \<le> Suc (Suc (height r)); i \<le> length xs\<rbrakk> \<Longrightarrow> t_heapify (Suc i div 2) xs + (t_heapify (i div 2) ys + (t_sift_down l x r + height (sift_down l x r))) \<le> t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) + (t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))) + 3 2. \<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \<le> Suc (height l); height (sift_down l x r) \<le> Suc (Suc (height r)); i \<le> length xs\<rbrakk> \<Longrightarrow> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3 \<le> 5 + 5 * i
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case \n apply simp \n apply (rule order_trans, rule order_trans[rotated], rule prem) \n apply simp_all <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \<le> Suc (height l); height (sift_down l x r) \<le> Suc (Suc (height r)); i \<le> length xs\<rbrakk> \<Longrightarrow> 5 * (Suc i div 2) + 5 * (i div 2) \<le> 5 * i
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case \n apply simp \n apply (rule order_trans, rule order_trans[rotated], rule prem) \n apply simp_all \n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heapify (Suc i div 2) xs = (l, ys); heapify (i div 2) ys = (r, zs); t_sift_down l x r \<le> Suc (height l); height (sift_down l x r) \<le> Suc (Suc (height r)); i \<le> length xs\<rbrakk> \<Longrightarrow> 0 < 5 \<longrightarrow> Suc i div 2 + i div 2 \<le> i
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case \n apply simp \n apply (rule order_trans, rule order_trans[rotated], rule prem) \n apply simp_all \n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) \n apply simp <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma t_heapify_induct: "i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1" \n proof (induct i xs rule: t_heapify.induct) \n case (1 vs) \n thus ?case \n by simp \n next \n case (2 i x xs) \n obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)" \n by (simp add: prod_eq_iff) \n note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified] \n obtain r zs where h2: "heapify (i div 2) ys = (r, zs)" \n by (simp add: prod_eq_iff) \n from "2.prems" heapify_snd_tup[OF h1] \n have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys" \n by simp_all \n note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4] \n note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]] \n from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2] \n have braun: "braun \<langle>l, x, r\<rangle>" \n by auto \n have t_sift_l: "t_sift_down l x r \<le> height l + 1" \n using t_sift_down_height[OF braun] braun_height_r_le[OF braun] \n by simp \n from t_sift_down_height[OF braun] \n have height_sift_r: "height (sift_down l x r) \<le> height r + 2" \n using sift_down_height[OF braun] braun_height_l_le[OF braun] \n by simp \n from h1 h2 t_sift_l height_sift_r "2.prems" \n show ?case \n apply simp \n apply (rule order_trans, rule order_trans[rotated], rule prem) \n apply simp_all \n apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric]) \n apply simp \n done <ISA_OBS> proof (state) this: t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs))) \<le> 5 * Suc i + 1 goal (1 subgoal): 1. \<And>v. Suc v \<le> length [] \<Longrightarrow> t_heapify (Suc v) [] + height (fst (heapify (Suc v) [])) \<le> 5 * Suc v + 1
<ISA_PRF> lemma heap_heap_of_A: "heap (heap_of_A xs)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. heap (heap_of_A xs)
<ISA_PRF> lemma t_heap_of_B_bound: "t_heap_of_B xs \<le> 6 * length xs + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs \<le> 6 * length xs + 1
<ISA_PRF> lemma t_insert_height: "t_insert x t \<le> height t + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_insert x t \<le> height t + 1
<ISA_PRF> lemma t_insert_height: "t_insert x t \<le> height t + 1" \n apply (induct t arbitrary: x; simp) <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<And>t1 x2 t2 x. \<lbrakk>\<And>x. t_insert x t1 \<le> Suc (height t1); \<And>x. t_insert x t2 \<le> Suc (height t2)\<rbrakk> \<Longrightarrow> (x < x2 \<longrightarrow> t_insert x2 t2 \<le> Suc (max (height t1) (height t2))) \<and> (\<not> x < x2 \<longrightarrow> t_insert x t2 \<le> Suc (max (height t1) (height t2)))
<ISA_PRF> lemma t_insert_height: "t_insert x t \<le> height t + 1" \n apply (induct t arbitrary: x; simp) \n apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> lemma merge_heap: "heap l \<Longrightarrow> heap r \<Longrightarrow> heap (merge l r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. \<lbrakk>heap l; heap r\<rbrakk> \<Longrightarrow> heap (merge l r)
<ISA_PRF> lemma sortedB: "sorted (list_of_B (heap_of_B xs))" <ISA_OBS> proof (prove) goal (1 subgoal): 1. sorted (list_of_B (heap_of_B xs))
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - <ISA_OBS> proof (state) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp <ISA_OBS> proof (state) this: t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also <ISA_OBS> proof (state) this: t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] <ISA_OBS> proof (state) this: t_heap_of_B xs \<le> 6 * length xs + 1 goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also <ISA_OBS> proof (state) this: t_heap_of_B xs \<le> 6 * length xs + 1 goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also \n note t_list_of_B_log_bound[of "heap_of_B xs"] <ISA_OBS> proof (state) this: braun (heap_of_B xs) \<Longrightarrow> t_list_of_B (heap_of_B xs) \<le> 3 * (nat \<lceil>log 2 (real (size (heap_of_B xs) + 1))\<rceil> + 1) * size (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also \n note t_list_of_B_log_bound[of "heap_of_B xs"] \n finally <ISA_OBS> proof (chain) picking this: \<lbrakk>\<And>x y. x \<le> y \<Longrightarrow> x + t_list_of_B (heap_of_B xs) \<le> y + t_list_of_B (heap_of_B xs); braun (heap_of_B xs); \<And>x y. x \<le> y \<Longrightarrow> 6 * length xs + 1 + x \<le> 6 * length xs + 1 + y\<rbrakk> \<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 6 * length xs + 1 + 3 * (nat \<lceil>log 2 (real (size (heap_of_B xs) + 1))\<rceil> + 1) * size (heap_of_B xs)
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also \n note t_list_of_B_log_bound[of "heap_of_B xs"] \n finally \n show ?thesis <ISA_OBS> proof (prove) using this: \<lbrakk>\<And>x y. x \<le> y \<Longrightarrow> x + t_list_of_B (heap_of_B xs) \<le> y + t_list_of_B (heap_of_B xs); braun (heap_of_B xs); \<And>x y. x \<le> y \<Longrightarrow> 6 * length xs + 1 + x \<le> 6 * length xs + 1 + y\<rbrakk> \<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 6 * length xs + 1 + 3 * (nat \<lceil>log 2 (real (size (heap_of_B xs) + 1))\<rceil> + 1) * size (heap_of_B xs) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also \n note t_list_of_B_log_bound[of "heap_of_B xs"] \n finally \n show ?thesis \n apply (simp add: size_heapify braun_heapify heap_of_B_def) <ISA_OBS> proof (prove) goal (1 subgoal): 1. t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs)) \<le> Suc (6 * length xs + (3 + 3 * nat \<lceil>log 2 (1 + real (length xs))\<rceil>) * length xs) \<Longrightarrow> t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs)) \<le> Suc (3 * length xs * (nat \<lceil>log 2 (1 + real (length xs))\<rceil> + 3))
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also \n note t_list_of_B_log_bound[of "heap_of_B xs"] \n finally \n show ?thesis \n apply (simp add: size_heapify braun_heapify heap_of_B_def) \n apply (simp add: field_simps) <ISA_OBS> proof (prove) goal: No subgoals!
<ISA_PRF> theorem t_sortB: "t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1" (is "?lhs \<le> _") \n proof - \n have "?lhs \<le> ?lhs" \n by simp \n also \n note t_heap_of_B_bound[of xs] \n also \n note t_list_of_B_log_bound[of "heap_of_B xs"] \n finally \n show ?thesis \n apply (simp add: size_heapify braun_heapify heap_of_B_def) \n apply (simp add: field_simps) \n done <ISA_OBS> proof (state) this: t_heap_of_B xs + t_list_of_B (heap_of_B xs) \<le> 3 * length xs * (nat \<lceil>log 2 (real (length xs + 1))\<rceil> + 3) + 1 goal: No subgoals!
<ISA_PRF> lemma t_heapify_bound: "i \<le> length xs \<Longrightarrow> t_heapify i xs \<le> 5 * i + 1" <ISA_OBS> proof (prove) goal (1 subgoal): 1. i \<le> length xs \<Longrightarrow> t_heapify i xs \<le> 5 * i + 1
<ISA_PRF> lemma t_heapify_bound: "i \<le> length xs \<Longrightarrow> t_heapify i xs \<le> 5 * i + 1" \n using t_heapify_induct[of i xs] <ISA_OBS> proof (prove) using this: i \<le> length xs \<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \<le> 5 * i + 1 goal (1 subgoal): 1. i \<le> length xs \<Longrightarrow> t_heapify i xs \<le> 5 * i + 1
<ISA_PRF> lemma merge_size[termination_simp]: "size (merge l r) = size l + size r" <ISA_OBS> proof (prove) goal (1 subgoal): 1. size (merge l r) = size l + size r
<ISA_PRF> lemma t_sift_down_height: "braun (Node l x r) \<Longrightarrow> t_sift_down l x r \<le> height (Node l x r)" <ISA_OBS> proof (prove) goal (1 subgoal): 1. braun \<langle>l, x, r\<rangle> \<Longrightarrow> t_sift_down l x r \<le> height \<langle>l, x, r\<rangle>
<ISA_PRF> lemma set_list_of_A[simp]: "set (list_of_A t) = set_tree t" <ISA_OBS> proof (prove) goal (1 subgoal): 1. set (list_of_A t) = set_tree t
