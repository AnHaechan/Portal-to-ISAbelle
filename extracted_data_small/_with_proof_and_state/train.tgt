proof
show "r\<^sup>* `` X \<subseteq> X"
proof -
{
fix x y
assume y: "y \<in> X"
assume "(y,x) \<in> r\<^sup>*"
then
have "x \<in> X"
by (induct) (insert assms y, auto simp add: Image_def)
}
then
show ?thesis
unfolding Image_def
by auto
qed
qed auto
proof(rule finite_subset)
show "finite (nodes_of g)"
by (auto simp add: nodes_of_def)
qed (auto)
by pat_completeness auto
apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))")
apply auto[1]
apply (simp_all add: finite_psubset_def)
by (case_tac "x \<in> nodes_of g") (auto simp add: List.member_def)
by pat_completeness auto
by (induct g) (auto simp add: nodes_of_def)
proof(induct g xs ys rule: dfs.induct)
case 1
then
show ?case
by simp
next
case (2 g x xs ys)
show ?case
proof (cases "x \<in> set ys")
case True
with 2
show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys"
by (auto simp add: reachable_def List.member_def)
next
case False
have "reachable g (nexts g x) \<subseteq> reachable g [x]"
by (rule reachable_nexts)
hence a: "reachable g (nexts g x @ xs) \<subseteq> reachable g (x#xs)"
by(simp add: reachable_append, auto simp add: reachable_def)
with False 2
show "set (dfs g (x#xs) ys) \<subseteq> reachable g (x#xs) \<union> set ys"
by (auto simp add: reachable_def List.member_def)
qed
qed
by (induct g xs zs rule: dfs.induct) auto
unfolding nextss_def
by (auto simp add:Image_def nexts_set)
unfolding reachable_def
by auto
unfolding reachable_def
by (auto intro: converse_rtrancl_into_rtrancl simp: nexts_set)
by (induct g xs ys rule: dfs.induct) auto
by(simp only:dfs_eq_reachable reachable_def, auto)
proof
qed (simp add: equal_node_def)
proof -
have "reachable g xs \<subseteq> reachable g (dfs g xs [])"
unfolding reachable_def
by (rule Image_mono) (auto simp add: next_subset_dfs)
also
have "\<dots> = set(dfs g xs [])"
unfolding reachable_def
proof (rule Image_closed_trancl)
from nextss_closed_dfs
show "set g `` set (dfs g xs []) \<subseteq> set (dfs g xs [])"
by (simp add: nextss_def)
qed
finally
show ?thesis
.
qed
proof
have "set (dfs g xs []) \<subseteq> reachable g xs \<union> set []"
by (rule dfs_subset_reachable_visit_nodes[of g xs "[]"])
thus "set (dfs g xs []) \<subseteq> reachable g xs"
by simp
qed(rule reachable_closed_dfs)
by (rule nextss_closed_dfs', simp add: nextss_def)
by (induct g xs ys rule:dfs.induct, auto simp add:nextss_Cons List.member_def)
by (induct g xs ys rule: dfs2.pinduct) (force simp add: dfs2.psimps)+
apply (relation "inv_image (finite_psubset <*lex*> less_than) (\<lambda>(g,xs,ys). (nodes_of g - set ys, size xs))")
apply auto[1]
apply (simp_all add: finite_psubset_def)
apply (case_tac "x \<in> nodes_of g")
apply (auto simp add: List.member_def)[2]
by (insert dfs2_invariant) force
proof(induct g xs ys rule:dfs.induct)
case(2 g x xs ys)
show ?case
proof(cases "x \<in> set ys")
case True
have "set ys \<subseteq> set (dfs g xs ys)"
by (rule visit_subset_dfs)
with 2 and True
show ?thesis
by (auto simp add: List.member_def)
next
case False
have "set (x#ys) \<subseteq> set (dfs g (nexts g x @ xs) (x#ys))"
by(rule visit_subset_dfs)
with 2 and False
show ?thesis
by (auto simp add: List.member_def)
qed
qed(simp)
apply(induction l r rule: merge.induct)
apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_braun_size split!: prod.split)
done
proof(standard, goal_cases)
case 1
show ?case
by simp
next
case 2
show ?case
by simp
next
case 3
show ?case
by(simp add: mset_insert)
next
case 4
thus ?case
by(auto simp: mset_tree_merge neq_Leaf_iff)
next
case 5
thus ?case
using get_min mset_tree.simps(1)
by blast
next
case 6
thus ?case
by(simp)
next
case 7
thus ?case
by(simp add: heap_insert braun_insert)
next
case 8
thus ?case
by(auto simp: heap_merge braun_size_merge neq_Leaf_iff)
qed
proof(induction l r rule: merge.induct)
case 1
thus ?case
by simp
next
case (2 l1 a1 r1 l2 a2 r2)
show ?case
proof cases
assume "a1 \<le> a2"
thus ?thesis
using 2
by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)
next
assume "\<not> a1 \<le> a2"
let ?l = "Node l1 a1 r1"
let ?r = "Node l2 a2 r2"
have "braun ?r"
using "2.prems"(1)
by auto
obtain x l' where dl: "del_left ?l = (x, l')"
by (metis surj_pair)
from del_left_heap[OF this _ "2.prems"(2)]
have "heap l'"
by auto
have hr: "heap(replace_min x ?r)"
using \<open>braun ?r\<close> "2.prems"(3)
by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)
have 0: "\<forall>x \<in> set_tree ?l. a2 \<le> x"
using "2.prems"(2) \<open>\<not> a1 \<le> a2\<close>
by (auto simp: ball_Un)
moreover
have "set_tree l' \<subseteq> set_tree ?l" "x \<in> set_tree ?l"
using del_left_mset[OF dl]
by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)
ultimately
have 1: "\<forall>x \<in> set_tree l'. a2 \<le> x"
by blast
have "\<forall>x \<in> set_tree ?r. a2 \<le> x"
using \<open>heap ?r\<close>
by auto
thus ?thesis
using \<open>\<not> a1 \<le> a2\<close> dl \<open>heap(replace_min x ?r)\<close> \<open>heap l'\<close> \<open>x \<in> set_tree ?l\<close> 0 1 \<open>braun ?r\<close>
by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree simp del: replace_min.simps)
qed
next
case 3
thus ?case
by simp
qed
by (simp add: del_left_braun del_left_size)
by(induction l x r rule: sift_down.induct)(auto)
by(induction l r rule: merge.induct) (auto simp: Let_def tree.set_sel(2) mset_sift_down replace_min_sift_down simp del: replace_min.simps dest!: del_left_mset split!: prod.split)
by(simp add: mset_insert flip: set_mset_tree)
by(induction t arbitrary: x) auto
proof(induction t)
case (Node t1)
show ?case
proof (cases "height t1")
case 0
thus ?thesis
using Node
by simp
next
case (Suc n)
hence "2 ^ n \<le> size t1"
using Node
by simp
thus ?thesis
using Suc Node
by(auto simp: max_def)
qed
qed simp
by(simp add: del_left_mset_plus flip: set_mset_tree)
by(induction t arbitrary: x) (auto simp: ac_simps)
by(induction t arbitrary: x) (auto simp add: ball_Un)
proof(cases t rule: del_min.cases)
case 1
with assms
show ?thesis
by simp
next
case 2
with assms
show ?thesis
by (simp)
next
case [simp]: (3 ll b lr a r)
have "mset_tree(sift_down r y l') = mset_tree t - {#a#}" if del: "del_left (Node ll b lr) = (y,l')" for y l'
using assms del_left_mset[OF del] del_left_size[OF del] del_left_braun[OF del] del_left_mset_plus[OF del]
apply (subst mset_sift_down)
apply (auto simp: ac_simps del_left_mset_plus[OF del])
done
thus ?thesis
by(auto split: prod.split)
qed
proof(standard, goal_cases)
case 1
show ?case
by simp
next
case 2
show ?case
by simp
next
case 3
show ?case
by(simp add: mset_insert)
next
case 4
thus ?case
by(simp add: mset_del_min)
next
case 5
thus ?case
using get_min mset_tree.simps(1)
by blast
next
case 6
thus ?case
by(simp)
next
case 7
thus ?case
by(simp add: heap_insert braun_insert)
next
case 8
thus ?case
by(simp add: heap_del_min braun_del_min)
qed
by (auto simp add: eq_Min_iff neq_Leaf_iff)
by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits)
by (induction t arbitrary: x t' rule: del_left.induct; fastforce split: prod.splits dest: del_left_set[THEN equalityD2])
apply(cases t rule: del_min.cases)
apply simp
apply simp
apply (fastforce split: prod.split intro!: heap_sift_down dest: del_left_size del_left_braun del_left_heap)
done
by(induction l a r rule: sift_down.induct) (auto simp: size_sift_down Let_def)
by (induction l a r rule: sift_down.induct) (auto simp: set_sift_down ball_Un Let_def)
by(induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits dest: del_left_size)
by pat_completeness auto
by (relation "measure (%(l,a,r). size l + size r)") auto
apply(cases t rule: del_min.cases)
apply simp
apply simp
apply (fastforce split: prod.split intro!: braun_sift_down dest: del_left_size del_left_braun)
done
by(drule arg_cong[where f=set_mset, OF mset_sift_down]) (simp)
by(induction l a r rule: sift_down.induct) (auto simp: ac_simps Let_def)
by (induction t arbitrary: x t' rule: del_left.induct; auto split: prod.splits)
by(induction t arbitrary: x) auto
by(induction l a r rule: sift_down.induct) (auto simp: Let_def)
by (rule is_measure_trivial)
by (induct rule: merge.induct, auto)
using merge_height
by simp
apply (induct t arbitrary: x; simp add: le_max_iff_disj)
apply (metis less_imp_le_nat less_le_trans not_le_imp_less)
done
using t_heap_of_A_bound[of xs] acomplete_if_braun[OF braun_heap_of_A, of xs]
by (simp add: height_acomplete size1_size size_heap_of_A)
apply (induct t rule: measure_induct[where f=size])
apply (case_tac x; simp add: list_of_B_braun_simps)
apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)
apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree)
done
apply (induct t arbitrary: v t' rule: del_left.induct; simp)
apply (atomize(full), clarsimp split: prod.splits)
apply simp
done
by (drule heapify_snd, simp)
by (induct l r rule: merge.induct; simp)
by (rule acomplete_optimal, auto intro: acomplete_if_braun)
by (cases "heapify n xs", drule(1) heapify_correct, simp)
by (induct t rule: list_of_A.induct; simp add: merge_heap)
using b braun_height_r_le[OF b]
by (auto simp add: max_def)
by(induction xs)(simp_all add: mset_insert)
by (simp add: heap_heap_of_A sorted_list_of_A)
using t_list_of_A_bound[of t]
by (simp add: height_acomplete acomplete_if_braun size1_size)
apply (induct t rule: measure_induct[where f=size])
apply (case_tac x; simp add: list_of_B_braun_simps)
apply (simp add: size_del_min braun_del_min mset_del_min)
done
apply (induct rule: t_del_left.induct; clarsimp)
apply (atomize(full); clarsimp simp: prod_eq_iff)
apply (simp add: nat_mult_max_right le_max_iff_disj)
done
proof (induct n xs arbitrary: t ys rule: heapify.induct)
case (2 n x xs)
note len = "2.prems"(1)
obtain t1 ys1 where h1: "heapify (Suc n div 2) xs = (t1, ys1)"
by (simp add: prod_eq_iff)
obtain t2 ys2 where h2: "heapify (n div 2) ys1 = (t2, ys2)"
by (simp add: prod_eq_iff)
from len
have le1: "Suc n div 2 \<le> length xs"
by simp
note ys1 = heapify_snd_tup[OF h1 le1]
from len
have le2: "n div 2 \<le> length ys1"
by (simp add: ys1)
note app_hyps = "2.hyps"(1)[OF le1 h1] "2.hyps"(2)[OF refl h1[symmetric], simplified, OF le2 h2]
hence braun: "braun (Node t1 x t2)"
by (simp, linarith)
have eq: "n div 2 + Suc n div 2 = n"
by simp
have msets: "mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)"
apply (subst append_take_drop_id[symmetric, where n="Suc n div 2" and t="take n xs"], subst mset_append)
apply (simp add: take_drop min_absorb1 le1 eq ys1)
done
from "2.prems" app_hyps msets
show ?case
apply (clarsimp simp: h1 h2 le2)
apply (clarsimp simp: size_sift_down[OF braun] braun_sift_down[OF braun] mset_sift_down[OF braun])
apply (simp add: heap_sift_down[OF braun])
done
qed simp_all
apply (induct t rule: measure_induct[where f=size])
apply (drule_tac x="del_min x" in spec)
apply (frule del_min_height)
apply (case_tac x; simp add: t_list_of_B_braun_simps)
apply (rename_tac l x' r)
apply (clarsimp simp: braun_del_min size_del_min)
apply (rule order_trans)
apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]
apply simp
done
by (simp add: mset_tree_heap_of_A)
by (induct rule: t_merge.induct, auto)
apply (induct rule: t_list_of_A.induct)
apply simp
apply simp
apply (drule meta_mp)
apply (rule order_trans, rule merge_height)
apply simp
apply (simp add: merge_size)
apply (cut_tac l=l and r=r in t_merge_height)
apply linarith
done
proof (induct xs)
case (Cons x xs)
let ?lhs = "t_insert x (heap_of_A xs) + t_heap_of_A xs"
have "?lhs \<le> ?lhs"
by simp
also
note Cons
also
note height_insert_ge[of "heap_of_A xs" x]
also
note t_insert_height[of x "heap_of_A xs"]
finally
show ?case
apply simp
apply (erule order_trans)
apply (simp add: height_insert_ge)
done
qed simp_all
apply (induct t rule: measure_induct[where f=size])
apply (rule accpI, erule list_of_B_rel.cases)
apply (clarsimp simp: size_del_min braun_del_min)
done
by (cases "heapify n xs", drule(1) heapify_correct, simp)
by (induct t rule: list_of_A.induct; simp)
apply (cases t rule: del_min.cases; simp)
apply (clarsimp split: prod.split)
apply (frule del_left_braun, simp+)
apply (frule del_left_size, simp+)
apply (drule del_left_height)
apply simp
apply (rule order_trans, rule sift_down_height, auto)
done
by(induction xs)(simp_all add: braun_insert)
by (simp only: set_mset_mset[symmetric] mset_list_of_B, simp)
using b acomplete_if_braun[OF b] min_height_le_height[of r]
by (simp add: acomplete_def)
using arg_cong[OF mset_tree_heap_of_A, of size xs]
by simp
apply (cases t rule: t_del_min.cases; simp)
apply (clarsimp split: prod.split)
apply (frule del_left_braun, simp+)
apply (frule del_left_size, simp+)
apply (frule del_left_height, simp)
apply (rule order_trans)
apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]
apply auto[1]
apply (simp add: max_def)
done
apply (induct t rule: measure_induct[where f=size])
apply (rule accpI, erule t_list_of_B_rel.cases)
apply (clarsimp simp: size_del_min braun_del_min)
done
by (rule t_list_of_A_induct, simp)
by (induct l r rule: merge.induct; simp)
by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B)
by pat_completeness auto
by (cases "heapify n xs", drule(1) heapify_correct, simp)
by pat_completeness auto
by (relation "measure (%(l,a,r). size l + size r)") auto
apply (induct xs arbitrary: n rule: measure_induct[where f=length])
apply (case_tac n; simp)
apply (clarsimp simp: Suc_le_length_iff case_prod_beta)
apply (rule arg_cong[where f="\<lambda>n. drop n xs" for xs])
apply simp
done
proof -
have "?lhs \<le> ?lhs"
by simp
also
note t_heap_of_A_log_bound[of xs]
also
note t_list_of_A_log_bound[of "heap_of_A xs", OF braun_heap_of_A]
finally
show ?thesis
by (simp add: size_heap_of_A)
qed
by pat_completeness auto
by (induct l x r rule: sift_down.induct; auto simp: Let_def)
by (erule t_list_of_B_induct, simp)
proof (induct i xs rule: t_heapify.induct)
case (1 vs)
thus ?case
by simp
next
case (2 i x xs)
obtain l ys where h1: "heapify (Suc i div 2) xs = (l, ys)"
by (simp add: prod_eq_iff)
note hyps1 = "2.hyps"[OF h1[symmetric] refl, simplified]
obtain r zs where h2: "heapify (i div 2) ys = (r, zs)"
by (simp add: prod_eq_iff)
from "2.prems" heapify_snd_tup[OF h1]
have le1: "Suc i div 2 \<le> length xs" and le2: "i div 2 \<le> length xs" and le4: "i div 2 \<le> length ys"
by simp_all
note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]
note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]
from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]
have braun: "braun \<langle>l, x, r\<rangle>"
by auto
have t_sift_l: "t_sift_down l x r \<le> height l + 1"
using t_sift_down_height[OF braun] braun_height_r_le[OF braun]
by simp
from t_sift_down_height[OF braun]
have height_sift_r: "height (sift_down l x r) \<le> height r + 2"
using sift_down_height[OF braun] braun_height_l_le[OF braun]
by simp
from h1 h2 t_sift_l height_sift_r "2.prems"
show ?case
apply simp
apply (rule order_trans, rule order_trans[rotated], rule prem)
apply simp_all
apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])
apply simp
done
qed simp_all
by(induction xs)(simp_all add: heap_insert)
by (simp add: t_heap_of_B_def order_trans[OF t_heapify_bound])
apply (induct t arbitrary: x; simp)
apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp)
done
by (induct l r rule: merge.induct; auto simp: ball_Un)
by (simp add: heap_of_B_def braun_heapify heap_heapify sorted_list_of_B)
proof -
have "?lhs \<le> ?lhs"
by simp
also
note t_heap_of_B_bound[of xs]
also
note t_list_of_B_log_bound[of "heap_of_B xs"]
finally
show ?thesis
apply (simp add: size_heapify braun_heapify heap_of_B_def)
apply (simp add: field_simps)
done
qed
using t_heapify_induct[of i xs]
by simp
by (induct rule: merge.induct; simp)
by (induct l x r rule: t_sift_down.induct; auto)
by (induct t rule: list_of_A.induct; simp)
